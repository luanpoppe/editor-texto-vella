function fO(t, e) {
  for (var n = 0; n < e.length; n++) {
    const r = e[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const o in r)
        if (o !== "default" && !(o in t)) {
          const i = Object.getOwnPropertyDescriptor(r, o);
          i &&
            Object.defineProperty(
              t,
              o,
              i.get ? i : { enumerable: !0, get: () => r[o] }
            );
        }
    }
  }
  return Object.freeze(
    Object.defineProperty(t, Symbol.toStringTag, { value: "Module" })
  );
}
(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const o of document.querySelectorAll('link[rel="modulepreload"]')) r(o);
  new MutationObserver((o) => {
    for (const i of o)
      if (i.type === "childList")
        for (const l of i.addedNodes)
          l.tagName === "LINK" && l.rel === "modulepreload" && r(l);
  }).observe(document, { childList: !0, subtree: !0 });
  function n(o) {
    const i = {};
    return (
      o.integrity && (i.integrity = o.integrity),
      o.referrerPolicy && (i.referrerPolicy = o.referrerPolicy),
      o.crossOrigin === "use-credentials"
        ? (i.credentials = "include")
        : o.crossOrigin === "anonymous"
        ? (i.credentials = "omit")
        : (i.credentials = "same-origin"),
      i
    );
  }
  function r(o) {
    if (o.ep) return;
    o.ep = !0;
    const i = n(o);
    fetch(o.href, i);
  }
})();
function Jx(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default")
    ? t.default
    : t;
}
var nh = { exports: {} },
  Vl = {},
  rh = { exports: {} },
  De = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var c1;
function pO() {
  if (c1) return De;
  c1 = 1;
  var t = Symbol.for("react.element"),
    e = Symbol.for("react.portal"),
    n = Symbol.for("react.fragment"),
    r = Symbol.for("react.strict_mode"),
    o = Symbol.for("react.profiler"),
    i = Symbol.for("react.provider"),
    l = Symbol.for("react.context"),
    u = Symbol.for("react.forward_ref"),
    c = Symbol.for("react.suspense"),
    f = Symbol.for("react.memo"),
    p = Symbol.for("react.lazy"),
    m = Symbol.iterator;
  function y(D) {
    return D === null || typeof D != "object"
      ? null
      : ((D = (m && D[m]) || D["@@iterator"]),
        typeof D == "function" ? D : null);
  }
  var v = {
      isMounted: function () {
        return !1;
      },
      enqueueForceUpdate: function () {},
      enqueueReplaceState: function () {},
      enqueueSetState: function () {},
    },
    x = Object.assign,
    S = {};
  function C(D, A, X) {
    (this.props = D),
      (this.context = A),
      (this.refs = S),
      (this.updater = X || v);
  }
  (C.prototype.isReactComponent = {}),
    (C.prototype.setState = function (D, A) {
      if (typeof D != "object" && typeof D != "function" && D != null)
        throw Error(
          "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
        );
      this.updater.enqueueSetState(this, D, A, "setState");
    }),
    (C.prototype.forceUpdate = function (D) {
      this.updater.enqueueForceUpdate(this, D, "forceUpdate");
    });
  function E() {}
  E.prototype = C.prototype;
  function N(D, A, X) {
    (this.props = D),
      (this.context = A),
      (this.refs = S),
      (this.updater = X || v);
  }
  var $ = (N.prototype = new E());
  ($.constructor = N), x($, C.prototype), ($.isPureReactComponent = !0);
  var M = Array.isArray,
    I = Object.prototype.hasOwnProperty,
    R = { current: null },
    F = { key: !0, ref: !0, __self: !0, __source: !0 };
  function H(D, A, X) {
    var ne,
      Q = {},
      ie = null,
      he = null;
    if (A != null)
      for (ne in (A.ref !== void 0 && (he = A.ref),
      A.key !== void 0 && (ie = "" + A.key),
      A))
        I.call(A, ne) && !F.hasOwnProperty(ne) && (Q[ne] = A[ne]);
    var we = arguments.length - 2;
    if (we === 1) Q.children = X;
    else if (1 < we) {
      for (var be = Array(we), $e = 0; $e < we; $e++)
        be[$e] = arguments[$e + 2];
      Q.children = be;
    }
    if (D && D.defaultProps)
      for (ne in ((we = D.defaultProps), we))
        Q[ne] === void 0 && (Q[ne] = we[ne]);
    return {
      $$typeof: t,
      type: D,
      key: ie,
      ref: he,
      props: Q,
      _owner: R.current,
    };
  }
  function U(D, A) {
    return {
      $$typeof: t,
      type: D.type,
      key: A,
      ref: D.ref,
      props: D.props,
      _owner: D._owner,
    };
  }
  function re(D) {
    return typeof D == "object" && D !== null && D.$$typeof === t;
  }
  function ce(D) {
    var A = { "=": "=0", ":": "=2" };
    return (
      "$" +
      D.replace(/[=:]/g, function (X) {
        return A[X];
      })
    );
  }
  var ee = /\/+/g;
  function le(D, A) {
    return typeof D == "object" && D !== null && D.key != null
      ? ce("" + D.key)
      : A.toString(36);
  }
  function de(D, A, X, ne, Q) {
    var ie = typeof D;
    (ie === "undefined" || ie === "boolean") && (D = null);
    var he = !1;
    if (D === null) he = !0;
    else
      switch (ie) {
        case "string":
        case "number":
          he = !0;
          break;
        case "object":
          switch (D.$$typeof) {
            case t:
            case e:
              he = !0;
          }
      }
    if (he)
      return (
        (he = D),
        (Q = Q(he)),
        (D = ne === "" ? "." + le(he, 0) : ne),
        M(Q)
          ? ((X = ""),
            D != null && (X = D.replace(ee, "$&/") + "/"),
            de(Q, A, X, "", function ($e) {
              return $e;
            }))
          : Q != null &&
            (re(Q) &&
              (Q = U(
                Q,
                X +
                  (!Q.key || (he && he.key === Q.key)
                    ? ""
                    : ("" + Q.key).replace(ee, "$&/") + "/") +
                  D
              )),
            A.push(Q)),
        1
      );
    if (((he = 0), (ne = ne === "" ? "." : ne + ":"), M(D)))
      for (var we = 0; we < D.length; we++) {
        ie = D[we];
        var be = ne + le(ie, we);
        he += de(ie, A, X, be, Q);
      }
    else if (((be = y(D)), typeof be == "function"))
      for (D = be.call(D), we = 0; !(ie = D.next()).done; )
        (ie = ie.value), (be = ne + le(ie, we++)), (he += de(ie, A, X, be, Q));
    else if (ie === "object")
      throw (
        ((A = String(D)),
        Error(
          "Objects are not valid as a React child (found: " +
            (A === "[object Object]"
              ? "object with keys {" + Object.keys(D).join(", ") + "}"
              : A) +
            "). If you meant to render a collection of children, use an array instead."
        ))
      );
    return he;
  }
  function xe(D, A, X) {
    if (D == null) return D;
    var ne = [],
      Q = 0;
    return (
      de(D, ne, "", "", function (ie) {
        return A.call(X, ie, Q++);
      }),
      ne
    );
  }
  function oe(D) {
    if (D._status === -1) {
      var A = D._result;
      (A = A()),
        A.then(
          function (X) {
            (D._status === 0 || D._status === -1) &&
              ((D._status = 1), (D._result = X));
          },
          function (X) {
            (D._status === 0 || D._status === -1) &&
              ((D._status = 2), (D._result = X));
          }
        ),
        D._status === -1 && ((D._status = 0), (D._result = A));
    }
    if (D._status === 1) return D._result.default;
    throw D._result;
  }
  var se = { current: null },
    B = { transition: null },
    V = {
      ReactCurrentDispatcher: se,
      ReactCurrentBatchConfig: B,
      ReactCurrentOwner: R,
    };
  function K() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  return (
    (De.Children = {
      map: xe,
      forEach: function (D, A, X) {
        xe(
          D,
          function () {
            A.apply(this, arguments);
          },
          X
        );
      },
      count: function (D) {
        var A = 0;
        return (
          xe(D, function () {
            A++;
          }),
          A
        );
      },
      toArray: function (D) {
        return (
          xe(D, function (A) {
            return A;
          }) || []
        );
      },
      only: function (D) {
        if (!re(D))
          throw Error(
            "React.Children.only expected to receive a single React element child."
          );
        return D;
      },
    }),
    (De.Component = C),
    (De.Fragment = n),
    (De.Profiler = o),
    (De.PureComponent = N),
    (De.StrictMode = r),
    (De.Suspense = c),
    (De.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = V),
    (De.act = K),
    (De.cloneElement = function (D, A, X) {
      if (D == null)
        throw Error(
          "React.cloneElement(...): The argument must be a React element, but you passed " +
            D +
            "."
        );
      var ne = x({}, D.props),
        Q = D.key,
        ie = D.ref,
        he = D._owner;
      if (A != null) {
        if (
          (A.ref !== void 0 && ((ie = A.ref), (he = R.current)),
          A.key !== void 0 && (Q = "" + A.key),
          D.type && D.type.defaultProps)
        )
          var we = D.type.defaultProps;
        for (be in A)
          I.call(A, be) &&
            !F.hasOwnProperty(be) &&
            (ne[be] = A[be] === void 0 && we !== void 0 ? we[be] : A[be]);
      }
      var be = arguments.length - 2;
      if (be === 1) ne.children = X;
      else if (1 < be) {
        we = Array(be);
        for (var $e = 0; $e < be; $e++) we[$e] = arguments[$e + 2];
        ne.children = we;
      }
      return {
        $$typeof: t,
        type: D.type,
        key: Q,
        ref: ie,
        props: ne,
        _owner: he,
      };
    }),
    (De.createContext = function (D) {
      return (
        (D = {
          $$typeof: l,
          _currentValue: D,
          _currentValue2: D,
          _threadCount: 0,
          Provider: null,
          Consumer: null,
          _defaultValue: null,
          _globalName: null,
        }),
        (D.Provider = { $$typeof: i, _context: D }),
        (D.Consumer = D)
      );
    }),
    (De.createElement = H),
    (De.createFactory = function (D) {
      var A = H.bind(null, D);
      return (A.type = D), A;
    }),
    (De.createRef = function () {
      return { current: null };
    }),
    (De.forwardRef = function (D) {
      return { $$typeof: u, render: D };
    }),
    (De.isValidElement = re),
    (De.lazy = function (D) {
      return { $$typeof: p, _payload: { _status: -1, _result: D }, _init: oe };
    }),
    (De.memo = function (D, A) {
      return { $$typeof: f, type: D, compare: A === void 0 ? null : A };
    }),
    (De.startTransition = function (D) {
      var A = B.transition;
      B.transition = {};
      try {
        D();
      } finally {
        B.transition = A;
      }
    }),
    (De.unstable_act = K),
    (De.useCallback = function (D, A) {
      return se.current.useCallback(D, A);
    }),
    (De.useContext = function (D) {
      return se.current.useContext(D);
    }),
    (De.useDebugValue = function () {}),
    (De.useDeferredValue = function (D) {
      return se.current.useDeferredValue(D);
    }),
    (De.useEffect = function (D, A) {
      return se.current.useEffect(D, A);
    }),
    (De.useId = function () {
      return se.current.useId();
    }),
    (De.useImperativeHandle = function (D, A, X) {
      return se.current.useImperativeHandle(D, A, X);
    }),
    (De.useInsertionEffect = function (D, A) {
      return se.current.useInsertionEffect(D, A);
    }),
    (De.useLayoutEffect = function (D, A) {
      return se.current.useLayoutEffect(D, A);
    }),
    (De.useMemo = function (D, A) {
      return se.current.useMemo(D, A);
    }),
    (De.useReducer = function (D, A, X) {
      return se.current.useReducer(D, A, X);
    }),
    (De.useRef = function (D) {
      return se.current.useRef(D);
    }),
    (De.useState = function (D) {
      return se.current.useState(D);
    }),
    (De.useSyncExternalStore = function (D, A, X) {
      return se.current.useSyncExternalStore(D, A, X);
    }),
    (De.useTransition = function () {
      return se.current.useTransition();
    }),
    (De.version = "18.3.1"),
    De
  );
}
var d1;
function tg() {
  return d1 || ((d1 = 1), (rh.exports = pO())), rh.exports;
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var f1;
function hO() {
  if (f1) return Vl;
  f1 = 1;
  var t = tg(),
    e = Symbol.for("react.element"),
    n = Symbol.for("react.fragment"),
    r = Object.prototype.hasOwnProperty,
    o = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
    i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function l(u, c, f) {
    var p,
      m = {},
      y = null,
      v = null;
    f !== void 0 && (y = "" + f),
      c.key !== void 0 && (y = "" + c.key),
      c.ref !== void 0 && (v = c.ref);
    for (p in c) r.call(c, p) && !i.hasOwnProperty(p) && (m[p] = c[p]);
    if (u && u.defaultProps)
      for (p in ((c = u.defaultProps), c)) m[p] === void 0 && (m[p] = c[p]);
    return {
      $$typeof: e,
      type: u,
      key: y,
      ref: v,
      props: m,
      _owner: o.current,
    };
  }
  return (Vl.Fragment = n), (Vl.jsx = l), (Vl.jsxs = l), Vl;
}
var p1;
function mO() {
  return p1 || ((p1 = 1), (nh.exports = hO())), nh.exports;
}
var O = mO(),
  ic = {},
  oh = { exports: {} },
  Xt = {},
  ih = { exports: {} },
  sh = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var h1;
function gO() {
  return (
    h1 ||
      ((h1 = 1),
      (function (t) {
        function e(B, V) {
          var K = B.length;
          B.push(V);
          e: for (; 0 < K; ) {
            var D = (K - 1) >>> 1,
              A = B[D];
            if (0 < o(A, V)) (B[D] = V), (B[K] = A), (K = D);
            else break e;
          }
        }
        function n(B) {
          return B.length === 0 ? null : B[0];
        }
        function r(B) {
          if (B.length === 0) return null;
          var V = B[0],
            K = B.pop();
          if (K !== V) {
            B[0] = K;
            e: for (var D = 0, A = B.length, X = A >>> 1; D < X; ) {
              var ne = 2 * (D + 1) - 1,
                Q = B[ne],
                ie = ne + 1,
                he = B[ie];
              if (0 > o(Q, K))
                ie < A && 0 > o(he, Q)
                  ? ((B[D] = he), (B[ie] = K), (D = ie))
                  : ((B[D] = Q), (B[ne] = K), (D = ne));
              else if (ie < A && 0 > o(he, K))
                (B[D] = he), (B[ie] = K), (D = ie);
              else break e;
            }
          }
          return V;
        }
        function o(B, V) {
          var K = B.sortIndex - V.sortIndex;
          return K !== 0 ? K : B.id - V.id;
        }
        if (
          typeof performance == "object" &&
          typeof performance.now == "function"
        ) {
          var i = performance;
          t.unstable_now = function () {
            return i.now();
          };
        } else {
          var l = Date,
            u = l.now();
          t.unstable_now = function () {
            return l.now() - u;
          };
        }
        var c = [],
          f = [],
          p = 1,
          m = null,
          y = 3,
          v = !1,
          x = !1,
          S = !1,
          C = typeof setTimeout == "function" ? setTimeout : null,
          E = typeof clearTimeout == "function" ? clearTimeout : null,
          N = typeof setImmediate < "u" ? setImmediate : null;
        typeof navigator < "u" &&
          navigator.scheduling !== void 0 &&
          navigator.scheduling.isInputPending !== void 0 &&
          navigator.scheduling.isInputPending.bind(navigator.scheduling);
        function $(B) {
          for (var V = n(f); V !== null; ) {
            if (V.callback === null) r(f);
            else if (V.startTime <= B)
              r(f), (V.sortIndex = V.expirationTime), e(c, V);
            else break;
            V = n(f);
          }
        }
        function M(B) {
          if (((S = !1), $(B), !x))
            if (n(c) !== null) (x = !0), oe(I);
            else {
              var V = n(f);
              V !== null && se(M, V.startTime - B);
            }
        }
        function I(B, V) {
          (x = !1), S && ((S = !1), E(H), (H = -1)), (v = !0);
          var K = y;
          try {
            for (
              $(V), m = n(c);
              m !== null && (!(m.expirationTime > V) || (B && !ce()));

            ) {
              var D = m.callback;
              if (typeof D == "function") {
                (m.callback = null), (y = m.priorityLevel);
                var A = D(m.expirationTime <= V);
                (V = t.unstable_now()),
                  typeof A == "function"
                    ? (m.callback = A)
                    : m === n(c) && r(c),
                  $(V);
              } else r(c);
              m = n(c);
            }
            if (m !== null) var X = !0;
            else {
              var ne = n(f);
              ne !== null && se(M, ne.startTime - V), (X = !1);
            }
            return X;
          } finally {
            (m = null), (y = K), (v = !1);
          }
        }
        var R = !1,
          F = null,
          H = -1,
          U = 5,
          re = -1;
        function ce() {
          return !(t.unstable_now() - re < U);
        }
        function ee() {
          if (F !== null) {
            var B = t.unstable_now();
            re = B;
            var V = !0;
            try {
              V = F(!0, B);
            } finally {
              V ? le() : ((R = !1), (F = null));
            }
          } else R = !1;
        }
        var le;
        if (typeof N == "function")
          le = function () {
            N(ee);
          };
        else if (typeof MessageChannel < "u") {
          var de = new MessageChannel(),
            xe = de.port2;
          (de.port1.onmessage = ee),
            (le = function () {
              xe.postMessage(null);
            });
        } else
          le = function () {
            C(ee, 0);
          };
        function oe(B) {
          (F = B), R || ((R = !0), le());
        }
        function se(B, V) {
          H = C(function () {
            B(t.unstable_now());
          }, V);
        }
        (t.unstable_IdlePriority = 5),
          (t.unstable_ImmediatePriority = 1),
          (t.unstable_LowPriority = 4),
          (t.unstable_NormalPriority = 3),
          (t.unstable_Profiling = null),
          (t.unstable_UserBlockingPriority = 2),
          (t.unstable_cancelCallback = function (B) {
            B.callback = null;
          }),
          (t.unstable_continueExecution = function () {
            x || v || ((x = !0), oe(I));
          }),
          (t.unstable_forceFrameRate = function (B) {
            0 > B || 125 < B
              ? console.error(
                  "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
                )
              : (U = 0 < B ? Math.floor(1e3 / B) : 5);
          }),
          (t.unstable_getCurrentPriorityLevel = function () {
            return y;
          }),
          (t.unstable_getFirstCallbackNode = function () {
            return n(c);
          }),
          (t.unstable_next = function (B) {
            switch (y) {
              case 1:
              case 2:
              case 3:
                var V = 3;
                break;
              default:
                V = y;
            }
            var K = y;
            y = V;
            try {
              return B();
            } finally {
              y = K;
            }
          }),
          (t.unstable_pauseExecution = function () {}),
          (t.unstable_requestPaint = function () {}),
          (t.unstable_runWithPriority = function (B, V) {
            switch (B) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                B = 3;
            }
            var K = y;
            y = B;
            try {
              return V();
            } finally {
              y = K;
            }
          }),
          (t.unstable_scheduleCallback = function (B, V, K) {
            var D = t.unstable_now();
            switch (
              (typeof K == "object" && K !== null
                ? ((K = K.delay),
                  (K = typeof K == "number" && 0 < K ? D + K : D))
                : (K = D),
              B)
            ) {
              case 1:
                var A = -1;
                break;
              case 2:
                A = 250;
                break;
              case 5:
                A = 1073741823;
                break;
              case 4:
                A = 1e4;
                break;
              default:
                A = 5e3;
            }
            return (
              (A = K + A),
              (B = {
                id: p++,
                callback: V,
                priorityLevel: B,
                startTime: K,
                expirationTime: A,
                sortIndex: -1,
              }),
              K > D
                ? ((B.sortIndex = K),
                  e(f, B),
                  n(c) === null &&
                    B === n(f) &&
                    (S ? (E(H), (H = -1)) : (S = !0), se(M, K - D)))
                : ((B.sortIndex = A), e(c, B), x || v || ((x = !0), oe(I))),
              B
            );
          }),
          (t.unstable_shouldYield = ce),
          (t.unstable_wrapCallback = function (B) {
            var V = y;
            return function () {
              var K = y;
              y = V;
              try {
                return B.apply(this, arguments);
              } finally {
                y = K;
              }
            };
          });
      })(sh)),
    sh
  );
}
var m1;
function yO() {
  return m1 || ((m1 = 1), (ih.exports = gO())), ih.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var g1;
function vO() {
  if (g1) return Xt;
  g1 = 1;
  var t = tg(),
    e = yO();
  function n(s) {
    for (
      var a = "https://reactjs.org/docs/error-decoder.html?invariant=" + s,
        d = 1;
      d < arguments.length;
      d++
    )
      a += "&args[]=" + encodeURIComponent(arguments[d]);
    return (
      "Minified React error #" +
      s +
      "; visit " +
      a +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  var r = new Set(),
    o = {};
  function i(s, a) {
    l(s, a), l(s + "Capture", a);
  }
  function l(s, a) {
    for (o[s] = a, s = 0; s < a.length; s++) r.add(a[s]);
  }
  var u = !(
      typeof window > "u" ||
      typeof window.document > "u" ||
      typeof window.document.createElement > "u"
    ),
    c = Object.prototype.hasOwnProperty,
    f =
      /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    p = {},
    m = {};
  function y(s) {
    return c.call(m, s)
      ? !0
      : c.call(p, s)
      ? !1
      : f.test(s)
      ? (m[s] = !0)
      : ((p[s] = !0), !1);
  }
  function v(s, a, d, h) {
    if (d !== null && d.type === 0) return !1;
    switch (typeof a) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return h
          ? !1
          : d !== null
          ? !d.acceptsBooleans
          : ((s = s.toLowerCase().slice(0, 5)), s !== "data-" && s !== "aria-");
      default:
        return !1;
    }
  }
  function x(s, a, d, h) {
    if (a === null || typeof a > "u" || v(s, a, d, h)) return !0;
    if (h) return !1;
    if (d !== null)
      switch (d.type) {
        case 3:
          return !a;
        case 4:
          return a === !1;
        case 5:
          return isNaN(a);
        case 6:
          return isNaN(a) || 1 > a;
      }
    return !1;
  }
  function S(s, a, d, h, g, w, k) {
    (this.acceptsBooleans = a === 2 || a === 3 || a === 4),
      (this.attributeName = h),
      (this.attributeNamespace = g),
      (this.mustUseProperty = d),
      (this.propertyName = s),
      (this.type = a),
      (this.sanitizeURL = w),
      (this.removeEmptyString = k);
  }
  var C = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
    .split(" ")
    .forEach(function (s) {
      C[s] = new S(s, 0, !1, s, null, !1, !1);
    }),
    [
      ["acceptCharset", "accept-charset"],
      ["className", "class"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
    ].forEach(function (s) {
      var a = s[0];
      C[a] = new S(a, 1, !1, s[1], null, !1, !1);
    }),
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (
      s
    ) {
      C[s] = new S(s, 2, !1, s.toLowerCase(), null, !1, !1);
    }),
    [
      "autoReverse",
      "externalResourcesRequired",
      "focusable",
      "preserveAlpha",
    ].forEach(function (s) {
      C[s] = new S(s, 2, !1, s, null, !1, !1);
    }),
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
      .split(" ")
      .forEach(function (s) {
        C[s] = new S(s, 3, !1, s.toLowerCase(), null, !1, !1);
      }),
    ["checked", "multiple", "muted", "selected"].forEach(function (s) {
      C[s] = new S(s, 3, !0, s, null, !1, !1);
    }),
    ["capture", "download"].forEach(function (s) {
      C[s] = new S(s, 4, !1, s, null, !1, !1);
    }),
    ["cols", "rows", "size", "span"].forEach(function (s) {
      C[s] = new S(s, 6, !1, s, null, !1, !1);
    }),
    ["rowSpan", "start"].forEach(function (s) {
      C[s] = new S(s, 5, !1, s.toLowerCase(), null, !1, !1);
    });
  var E = /[\-:]([a-z])/g;
  function N(s) {
    return s[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
    .split(" ")
    .forEach(function (s) {
      var a = s.replace(E, N);
      C[a] = new S(a, 1, !1, s, null, !1, !1);
    }),
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
      .split(" ")
      .forEach(function (s) {
        var a = s.replace(E, N);
        C[a] = new S(a, 1, !1, s, "http://www.w3.org/1999/xlink", !1, !1);
      }),
    ["xml:base", "xml:lang", "xml:space"].forEach(function (s) {
      var a = s.replace(E, N);
      C[a] = new S(a, 1, !1, s, "http://www.w3.org/XML/1998/namespace", !1, !1);
    }),
    ["tabIndex", "crossOrigin"].forEach(function (s) {
      C[s] = new S(s, 1, !1, s.toLowerCase(), null, !1, !1);
    }),
    (C.xlinkHref = new S(
      "xlinkHref",
      1,
      !1,
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      !1
    )),
    ["src", "href", "action", "formAction"].forEach(function (s) {
      C[s] = new S(s, 1, !1, s.toLowerCase(), null, !0, !0);
    });
  function $(s, a, d, h) {
    var g = C.hasOwnProperty(a) ? C[a] : null;
    (g !== null
      ? g.type !== 0
      : h ||
        !(2 < a.length) ||
        (a[0] !== "o" && a[0] !== "O") ||
        (a[1] !== "n" && a[1] !== "N")) &&
      (x(a, d, g, h) && (d = null),
      h || g === null
        ? y(a) &&
          (d === null ? s.removeAttribute(a) : s.setAttribute(a, "" + d))
        : g.mustUseProperty
        ? (s[g.propertyName] = d === null ? (g.type === 3 ? !1 : "") : d)
        : ((a = g.attributeName),
          (h = g.attributeNamespace),
          d === null
            ? s.removeAttribute(a)
            : ((g = g.type),
              (d = g === 3 || (g === 4 && d === !0) ? "" : "" + d),
              h ? s.setAttributeNS(h, a, d) : s.setAttribute(a, d))));
  }
  var M = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    I = Symbol.for("react.element"),
    R = Symbol.for("react.portal"),
    F = Symbol.for("react.fragment"),
    H = Symbol.for("react.strict_mode"),
    U = Symbol.for("react.profiler"),
    re = Symbol.for("react.provider"),
    ce = Symbol.for("react.context"),
    ee = Symbol.for("react.forward_ref"),
    le = Symbol.for("react.suspense"),
    de = Symbol.for("react.suspense_list"),
    xe = Symbol.for("react.memo"),
    oe = Symbol.for("react.lazy"),
    se = Symbol.for("react.offscreen"),
    B = Symbol.iterator;
  function V(s) {
    return s === null || typeof s != "object"
      ? null
      : ((s = (B && s[B]) || s["@@iterator"]),
        typeof s == "function" ? s : null);
  }
  var K = Object.assign,
    D;
  function A(s) {
    if (D === void 0)
      try {
        throw Error();
      } catch (d) {
        var a = d.stack.trim().match(/\n( *(at )?)/);
        D = (a && a[1]) || "";
      }
    return (
      `
` +
      D +
      s
    );
  }
  var X = !1;
  function ne(s, a) {
    if (!s || X) return "";
    X = !0;
    var d = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (a)
        if (
          ((a = function () {
            throw Error();
          }),
          Object.defineProperty(a.prototype, "props", {
            set: function () {
              throw Error();
            },
          }),
          typeof Reflect == "object" && Reflect.construct)
        ) {
          try {
            Reflect.construct(a, []);
          } catch (j) {
            var h = j;
          }
          Reflect.construct(s, [], a);
        } else {
          try {
            a.call();
          } catch (j) {
            h = j;
          }
          s.call(a.prototype);
        }
      else {
        try {
          throw Error();
        } catch (j) {
          h = j;
        }
        s();
      }
    } catch (j) {
      if (j && h && typeof j.stack == "string") {
        for (
          var g = j.stack.split(`
`),
            w = h.stack.split(`
`),
            k = g.length - 1,
            T = w.length - 1;
          1 <= k && 0 <= T && g[k] !== w[T];

        )
          T--;
        for (; 1 <= k && 0 <= T; k--, T--)
          if (g[k] !== w[T]) {
            if (k !== 1 || T !== 1)
              do
                if ((k--, T--, 0 > T || g[k] !== w[T])) {
                  var P =
                    `
` + g[k].replace(" at new ", " at ");
                  return (
                    s.displayName &&
                      P.includes("<anonymous>") &&
                      (P = P.replace("<anonymous>", s.displayName)),
                    P
                  );
                }
              while (1 <= k && 0 <= T);
            break;
          }
      }
    } finally {
      (X = !1), (Error.prepareStackTrace = d);
    }
    return (s = s ? s.displayName || s.name : "") ? A(s) : "";
  }
  function Q(s) {
    switch (s.tag) {
      case 5:
        return A(s.type);
      case 16:
        return A("Lazy");
      case 13:
        return A("Suspense");
      case 19:
        return A("SuspenseList");
      case 0:
      case 2:
      case 15:
        return (s = ne(s.type, !1)), s;
      case 11:
        return (s = ne(s.type.render, !1)), s;
      case 1:
        return (s = ne(s.type, !0)), s;
      default:
        return "";
    }
  }
  function ie(s) {
    if (s == null) return null;
    if (typeof s == "function") return s.displayName || s.name || null;
    if (typeof s == "string") return s;
    switch (s) {
      case F:
        return "Fragment";
      case R:
        return "Portal";
      case U:
        return "Profiler";
      case H:
        return "StrictMode";
      case le:
        return "Suspense";
      case de:
        return "SuspenseList";
    }
    if (typeof s == "object")
      switch (s.$$typeof) {
        case ce:
          return (s.displayName || "Context") + ".Consumer";
        case re:
          return (s._context.displayName || "Context") + ".Provider";
        case ee:
          var a = s.render;
          return (
            (s = s.displayName),
            s ||
              ((s = a.displayName || a.name || ""),
              (s = s !== "" ? "ForwardRef(" + s + ")" : "ForwardRef")),
            s
          );
        case xe:
          return (
            (a = s.displayName || null), a !== null ? a : ie(s.type) || "Memo"
          );
        case oe:
          (a = s._payload), (s = s._init);
          try {
            return ie(s(a));
          } catch {}
      }
    return null;
  }
  function he(s) {
    var a = s.type;
    switch (s.tag) {
      case 24:
        return "Cache";
      case 9:
        return (a.displayName || "Context") + ".Consumer";
      case 10:
        return (a._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return (
          (s = a.render),
          (s = s.displayName || s.name || ""),
          a.displayName || (s !== "" ? "ForwardRef(" + s + ")" : "ForwardRef")
        );
      case 7:
        return "Fragment";
      case 5:
        return a;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return ie(a);
      case 8:
        return a === H ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof a == "function") return a.displayName || a.name || null;
        if (typeof a == "string") return a;
    }
    return null;
  }
  function we(s) {
    switch (typeof s) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return s;
      case "object":
        return s;
      default:
        return "";
    }
  }
  function be(s) {
    var a = s.type;
    return (
      (s = s.nodeName) &&
      s.toLowerCase() === "input" &&
      (a === "checkbox" || a === "radio")
    );
  }
  function $e(s) {
    var a = be(s) ? "checked" : "value",
      d = Object.getOwnPropertyDescriptor(s.constructor.prototype, a),
      h = "" + s[a];
    if (
      !s.hasOwnProperty(a) &&
      typeof d < "u" &&
      typeof d.get == "function" &&
      typeof d.set == "function"
    ) {
      var g = d.get,
        w = d.set;
      return (
        Object.defineProperty(s, a, {
          configurable: !0,
          get: function () {
            return g.call(this);
          },
          set: function (k) {
            (h = "" + k), w.call(this, k);
          },
        }),
        Object.defineProperty(s, a, { enumerable: d.enumerable }),
        {
          getValue: function () {
            return h;
          },
          setValue: function (k) {
            h = "" + k;
          },
          stopTracking: function () {
            (s._valueTracker = null), delete s[a];
          },
        }
      );
    }
  }
  function Kt(s) {
    s._valueTracker || (s._valueTracker = $e(s));
  }
  function tr(s) {
    if (!s) return !1;
    var a = s._valueTracker;
    if (!a) return !0;
    var d = a.getValue(),
      h = "";
    return (
      s && (h = be(s) ? (s.checked ? "true" : "false") : s.value),
      (s = h),
      s !== d ? (a.setValue(s), !0) : !1
    );
  }
  function Mt(s) {
    if (
      ((s = s || (typeof document < "u" ? document : void 0)), typeof s > "u")
    )
      return null;
    try {
      return s.activeElement || s.body;
    } catch {
      return s.body;
    }
  }
  function $n(s, a) {
    var d = a.checked;
    return K({}, a, {
      defaultChecked: void 0,
      defaultValue: void 0,
      value: void 0,
      checked: d ?? s._wrapperState.initialChecked,
    });
  }
  function Sr(s, a) {
    var d = a.defaultValue == null ? "" : a.defaultValue,
      h = a.checked != null ? a.checked : a.defaultChecked;
    (d = we(a.value != null ? a.value : d)),
      (s._wrapperState = {
        initialChecked: h,
        initialValue: d,
        controlled:
          a.type === "checkbox" || a.type === "radio"
            ? a.checked != null
            : a.value != null,
      });
  }
  function nr(s, a) {
    (a = a.checked), a != null && $(s, "checked", a, !1);
  }
  function _n(s, a) {
    nr(s, a);
    var d = we(a.value),
      h = a.type;
    if (d != null)
      h === "number"
        ? ((d === 0 && s.value === "") || s.value != d) && (s.value = "" + d)
        : s.value !== "" + d && (s.value = "" + d);
    else if (h === "submit" || h === "reset") {
      s.removeAttribute("value");
      return;
    }
    a.hasOwnProperty("value")
      ? sn(s, a.type, d)
      : a.hasOwnProperty("defaultValue") && sn(s, a.type, we(a.defaultValue)),
      a.checked == null &&
        a.defaultChecked != null &&
        (s.defaultChecked = !!a.defaultChecked);
  }
  function Cr(s, a, d) {
    if (a.hasOwnProperty("value") || a.hasOwnProperty("defaultValue")) {
      var h = a.type;
      if (
        !(
          (h !== "submit" && h !== "reset") ||
          (a.value !== void 0 && a.value !== null)
        )
      )
        return;
      (a = "" + s._wrapperState.initialValue),
        d || a === s.value || (s.value = a),
        (s.defaultValue = a);
    }
    (d = s.name),
      d !== "" && (s.name = ""),
      (s.defaultChecked = !!s._wrapperState.initialChecked),
      d !== "" && (s.name = d);
  }
  function sn(s, a, d) {
    (a !== "number" || Mt(s.ownerDocument) !== s) &&
      (d == null
        ? (s.defaultValue = "" + s._wrapperState.initialValue)
        : s.defaultValue !== "" + d && (s.defaultValue = "" + d));
  }
  var $t = Array.isArray;
  function _t(s, a, d, h) {
    if (((s = s.options), a)) {
      a = {};
      for (var g = 0; g < d.length; g++) a["$" + d[g]] = !0;
      for (d = 0; d < s.length; d++)
        (g = a.hasOwnProperty("$" + s[d].value)),
          s[d].selected !== g && (s[d].selected = g),
          g && h && (s[d].defaultSelected = !0);
    } else {
      for (d = "" + we(d), a = null, g = 0; g < s.length; g++) {
        if (s[g].value === d) {
          (s[g].selected = !0), h && (s[g].defaultSelected = !0);
          return;
        }
        a !== null || s[g].disabled || (a = s[g]);
      }
      a !== null && (a.selected = !0);
    }
  }
  function kr(s, a) {
    if (a.dangerouslySetInnerHTML != null) throw Error(n(91));
    return K({}, a, {
      value: void 0,
      defaultValue: void 0,
      children: "" + s._wrapperState.initialValue,
    });
  }
  function rr(s, a) {
    var d = a.value;
    if (d == null) {
      if (((d = a.children), (a = a.defaultValue), d != null)) {
        if (a != null) throw Error(n(92));
        if ($t(d)) {
          if (1 < d.length) throw Error(n(93));
          d = d[0];
        }
        a = d;
      }
      a == null && (a = ""), (d = a);
    }
    s._wrapperState = { initialValue: we(d) };
  }
  function Qr(s, a) {
    var d = we(a.value),
      h = we(a.defaultValue);
    d != null &&
      ((d = "" + d),
      d !== s.value && (s.value = d),
      a.defaultValue == null && s.defaultValue !== d && (s.defaultValue = d)),
      h != null && (s.defaultValue = "" + h);
  }
  function Zo(s) {
    var a = s.textContent;
    a === s._wrapperState.initialValue &&
      a !== "" &&
      a !== null &&
      (s.value = a);
  }
  function ei(s) {
    switch (s) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function Yr(s, a) {
    return s == null || s === "http://www.w3.org/1999/xhtml"
      ? ei(a)
      : s === "http://www.w3.org/2000/svg" && a === "foreignObject"
      ? "http://www.w3.org/1999/xhtml"
      : s;
  }
  var Er,
    Ja = (function (s) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
        ? function (a, d, h, g) {
            MSApp.execUnsafeLocalFunction(function () {
              return s(a, d, h, g);
            });
          }
        : s;
    })(function (s, a) {
      if (s.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in s)
        s.innerHTML = a;
      else {
        for (
          Er = Er || document.createElement("div"),
            Er.innerHTML = "<svg>" + a.valueOf().toString() + "</svg>",
            a = Er.firstChild;
          s.firstChild;

        )
          s.removeChild(s.firstChild);
        for (; a.firstChild; ) s.appendChild(a.firstChild);
      }
    });
  function ti(s, a) {
    if (a) {
      var d = s.firstChild;
      if (d && d === s.lastChild && d.nodeType === 3) {
        d.nodeValue = a;
        return;
      }
    }
    s.textContent = a;
  }
  var ni = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0,
    },
    wf = ["Webkit", "ms", "Moz", "O"];
  Object.keys(ni).forEach(function (s) {
    wf.forEach(function (a) {
      (a = a + s.charAt(0).toUpperCase() + s.substring(1)), (ni[a] = ni[s]);
    });
  });
  function Qa(s, a, d) {
    return a == null || typeof a == "boolean" || a === ""
      ? ""
      : d || typeof a != "number" || a === 0 || (ni.hasOwnProperty(s) && ni[s])
      ? ("" + a).trim()
      : a + "px";
  }
  function W(s, a) {
    s = s.style;
    for (var d in a)
      if (a.hasOwnProperty(d)) {
        var h = d.indexOf("--") === 0,
          g = Qa(d, a[d], h);
        d === "float" && (d = "cssFloat"), h ? s.setProperty(d, g) : (s[d] = g);
      }
  }
  var ge = K(
    { menuitem: !0 },
    {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0,
    }
  );
  function Ee(s, a) {
    if (a) {
      if (ge[s] && (a.children != null || a.dangerouslySetInnerHTML != null))
        throw Error(n(137, s));
      if (a.dangerouslySetInnerHTML != null) {
        if (a.children != null) throw Error(n(60));
        if (
          typeof a.dangerouslySetInnerHTML != "object" ||
          !("__html" in a.dangerouslySetInnerHTML)
        )
          throw Error(n(61));
      }
      if (a.style != null && typeof a.style != "object") throw Error(n(62));
    }
  }
  function _e(s, a) {
    if (s.indexOf("-") === -1) return typeof a.is == "string";
    switch (s) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var Ie = null;
  function lt(s) {
    return (
      (s = s.target || s.srcElement || window),
      s.correspondingUseElement && (s = s.correspondingUseElement),
      s.nodeType === 3 ? s.parentNode : s
    );
  }
  var Ot = null,
    ln = null,
    Mr = null;
  function or(s) {
    if ((s = Tl(s))) {
      if (typeof Ot != "function") throw Error(n(280));
      var a = s.stateNode;
      a && ((a = xu(a)), Ot(s.stateNode, s.type, a));
    }
  }
  function Qi(s) {
    ln ? (Mr ? Mr.push(s) : (Mr = [s])) : (ln = s);
  }
  function ri() {
    if (ln) {
      var s = ln,
        a = Mr;
      if (((Mr = ln = null), or(s), a)) for (s = 0; s < a.length; s++) or(a[s]);
    }
  }
  function Or(s, a) {
    return s(a);
  }
  function Ya() {}
  var oi = !1;
  function ii(s, a, d) {
    if (oi) return s(a, d);
    oi = !0;
    try {
      return Or(s, a, d);
    } finally {
      (oi = !1), (ln !== null || Mr !== null) && (Ya(), ri());
    }
  }
  function ll(s, a) {
    var d = s.stateNode;
    if (d === null) return null;
    var h = xu(d);
    if (h === null) return null;
    d = h[a];
    e: switch (a) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (h = !h.disabled) ||
          ((s = s.type),
          (h = !(
            s === "button" ||
            s === "input" ||
            s === "select" ||
            s === "textarea"
          ))),
          (s = !h);
        break e;
      default:
        s = !1;
    }
    if (s) return null;
    if (d && typeof d != "function") throw Error(n(231, a, typeof d));
    return d;
  }
  var xf = !1;
  if (u)
    try {
      var al = {};
      Object.defineProperty(al, "passive", {
        get: function () {
          xf = !0;
        },
      }),
        window.addEventListener("test", al, al),
        window.removeEventListener("test", al, al);
    } catch {
      xf = !1;
    }
  function wM(s, a, d, h, g, w, k, T, P) {
    var j = Array.prototype.slice.call(arguments, 3);
    try {
      a.apply(d, j);
    } catch (G) {
      this.onError(G);
    }
  }
  var ul = !1,
    Xa = null,
    Za = !1,
    bf = null,
    xM = {
      onError: function (s) {
        (ul = !0), (Xa = s);
      },
    };
  function bM(s, a, d, h, g, w, k, T, P) {
    (ul = !1), (Xa = null), wM.apply(xM, arguments);
  }
  function SM(s, a, d, h, g, w, k, T, P) {
    if ((bM.apply(this, arguments), ul)) {
      if (ul) {
        var j = Xa;
        (ul = !1), (Xa = null);
      } else throw Error(n(198));
      Za || ((Za = !0), (bf = j));
    }
  }
  function si(s) {
    var a = s,
      d = s;
    if (s.alternate) for (; a.return; ) a = a.return;
    else {
      s = a;
      do (a = s), a.flags & 4098 && (d = a.return), (s = a.return);
      while (s);
    }
    return a.tag === 3 ? d : null;
  }
  function Dy(s) {
    if (s.tag === 13) {
      var a = s.memoizedState;
      if (
        (a === null && ((s = s.alternate), s !== null && (a = s.memoizedState)),
        a !== null)
      )
        return a.dehydrated;
    }
    return null;
  }
  function Iy(s) {
    if (si(s) !== s) throw Error(n(188));
  }
  function CM(s) {
    var a = s.alternate;
    if (!a) {
      if (((a = si(s)), a === null)) throw Error(n(188));
      return a !== s ? null : s;
    }
    for (var d = s, h = a; ; ) {
      var g = d.return;
      if (g === null) break;
      var w = g.alternate;
      if (w === null) {
        if (((h = g.return), h !== null)) {
          d = h;
          continue;
        }
        break;
      }
      if (g.child === w.child) {
        for (w = g.child; w; ) {
          if (w === d) return Iy(g), s;
          if (w === h) return Iy(g), a;
          w = w.sibling;
        }
        throw Error(n(188));
      }
      if (d.return !== h.return) (d = g), (h = w);
      else {
        for (var k = !1, T = g.child; T; ) {
          if (T === d) {
            (k = !0), (d = g), (h = w);
            break;
          }
          if (T === h) {
            (k = !0), (h = g), (d = w);
            break;
          }
          T = T.sibling;
        }
        if (!k) {
          for (T = w.child; T; ) {
            if (T === d) {
              (k = !0), (d = w), (h = g);
              break;
            }
            if (T === h) {
              (k = !0), (h = w), (d = g);
              break;
            }
            T = T.sibling;
          }
          if (!k) throw Error(n(189));
        }
      }
      if (d.alternate !== h) throw Error(n(190));
    }
    if (d.tag !== 3) throw Error(n(188));
    return d.stateNode.current === d ? s : a;
  }
  function Ly(s) {
    return (s = CM(s)), s !== null ? $y(s) : null;
  }
  function $y(s) {
    if (s.tag === 5 || s.tag === 6) return s;
    for (s = s.child; s !== null; ) {
      var a = $y(s);
      if (a !== null) return a;
      s = s.sibling;
    }
    return null;
  }
  var _y = e.unstable_scheduleCallback,
    Fy = e.unstable_cancelCallback,
    kM = e.unstable_shouldYield,
    EM = e.unstable_requestPaint,
    rt = e.unstable_now,
    MM = e.unstable_getCurrentPriorityLevel,
    Sf = e.unstable_ImmediatePriority,
    zy = e.unstable_UserBlockingPriority,
    eu = e.unstable_NormalPriority,
    OM = e.unstable_LowPriority,
    jy = e.unstable_IdlePriority,
    tu = null,
    ir = null;
  function TM(s) {
    if (ir && typeof ir.onCommitFiberRoot == "function")
      try {
        ir.onCommitFiberRoot(tu, s, void 0, (s.current.flags & 128) === 128);
      } catch {}
  }
  var Fn = Math.clz32 ? Math.clz32 : RM,
    NM = Math.log,
    AM = Math.LN2;
  function RM(s) {
    return (s >>>= 0), s === 0 ? 32 : (31 - ((NM(s) / AM) | 0)) | 0;
  }
  var nu = 64,
    ru = 4194304;
  function cl(s) {
    switch (s & -s) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return s & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return s & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return s;
    }
  }
  function ou(s, a) {
    var d = s.pendingLanes;
    if (d === 0) return 0;
    var h = 0,
      g = s.suspendedLanes,
      w = s.pingedLanes,
      k = d & 268435455;
    if (k !== 0) {
      var T = k & ~g;
      T !== 0 ? (h = cl(T)) : ((w &= k), w !== 0 && (h = cl(w)));
    } else (k = d & ~g), k !== 0 ? (h = cl(k)) : w !== 0 && (h = cl(w));
    if (h === 0) return 0;
    if (
      a !== 0 &&
      a !== h &&
      !(a & g) &&
      ((g = h & -h), (w = a & -a), g >= w || (g === 16 && (w & 4194240) !== 0))
    )
      return a;
    if ((h & 4 && (h |= d & 16), (a = s.entangledLanes), a !== 0))
      for (s = s.entanglements, a &= h; 0 < a; )
        (d = 31 - Fn(a)), (g = 1 << d), (h |= s[d]), (a &= ~g);
    return h;
  }
  function PM(s, a) {
    switch (s) {
      case 1:
      case 2:
      case 4:
        return a + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function DM(s, a) {
    for (
      var d = s.suspendedLanes,
        h = s.pingedLanes,
        g = s.expirationTimes,
        w = s.pendingLanes;
      0 < w;

    ) {
      var k = 31 - Fn(w),
        T = 1 << k,
        P = g[k];
      P === -1
        ? (!(T & d) || T & h) && (g[k] = PM(T, a))
        : P <= a && (s.expiredLanes |= T),
        (w &= ~T);
    }
  }
  function Cf(s) {
    return (
      (s = s.pendingLanes & -1073741825),
      s !== 0 ? s : s & 1073741824 ? 1073741824 : 0
    );
  }
  function By() {
    var s = nu;
    return (nu <<= 1), !(nu & 4194240) && (nu = 64), s;
  }
  function kf(s) {
    for (var a = [], d = 0; 31 > d; d++) a.push(s);
    return a;
  }
  function dl(s, a, d) {
    (s.pendingLanes |= a),
      a !== 536870912 && ((s.suspendedLanes = 0), (s.pingedLanes = 0)),
      (s = s.eventTimes),
      (a = 31 - Fn(a)),
      (s[a] = d);
  }
  function IM(s, a) {
    var d = s.pendingLanes & ~a;
    (s.pendingLanes = a),
      (s.suspendedLanes = 0),
      (s.pingedLanes = 0),
      (s.expiredLanes &= a),
      (s.mutableReadLanes &= a),
      (s.entangledLanes &= a),
      (a = s.entanglements);
    var h = s.eventTimes;
    for (s = s.expirationTimes; 0 < d; ) {
      var g = 31 - Fn(d),
        w = 1 << g;
      (a[g] = 0), (h[g] = -1), (s[g] = -1), (d &= ~w);
    }
  }
  function Ef(s, a) {
    var d = (s.entangledLanes |= a);
    for (s = s.entanglements; d; ) {
      var h = 31 - Fn(d),
        g = 1 << h;
      (g & a) | (s[h] & a) && (s[h] |= a), (d &= ~g);
    }
  }
  var je = 0;
  function Hy(s) {
    return (
      (s &= -s), 1 < s ? (4 < s ? (s & 268435455 ? 16 : 536870912) : 4) : 1
    );
  }
  var Vy,
    Mf,
    Wy,
    Uy,
    Ky,
    Of = !1,
    iu = [],
    Xr = null,
    Zr = null,
    eo = null,
    fl = new Map(),
    pl = new Map(),
    to = [],
    LM =
      "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
        " "
      );
  function qy(s, a) {
    switch (s) {
      case "focusin":
      case "focusout":
        Xr = null;
        break;
      case "dragenter":
      case "dragleave":
        Zr = null;
        break;
      case "mouseover":
      case "mouseout":
        eo = null;
        break;
      case "pointerover":
      case "pointerout":
        fl.delete(a.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        pl.delete(a.pointerId);
    }
  }
  function hl(s, a, d, h, g, w) {
    return s === null || s.nativeEvent !== w
      ? ((s = {
          blockedOn: a,
          domEventName: d,
          eventSystemFlags: h,
          nativeEvent: w,
          targetContainers: [g],
        }),
        a !== null && ((a = Tl(a)), a !== null && Mf(a)),
        s)
      : ((s.eventSystemFlags |= h),
        (a = s.targetContainers),
        g !== null && a.indexOf(g) === -1 && a.push(g),
        s);
  }
  function $M(s, a, d, h, g) {
    switch (a) {
      case "focusin":
        return (Xr = hl(Xr, s, a, d, h, g)), !0;
      case "dragenter":
        return (Zr = hl(Zr, s, a, d, h, g)), !0;
      case "mouseover":
        return (eo = hl(eo, s, a, d, h, g)), !0;
      case "pointerover":
        var w = g.pointerId;
        return fl.set(w, hl(fl.get(w) || null, s, a, d, h, g)), !0;
      case "gotpointercapture":
        return (
          (w = g.pointerId), pl.set(w, hl(pl.get(w) || null, s, a, d, h, g)), !0
        );
    }
    return !1;
  }
  function Gy(s) {
    var a = li(s.target);
    if (a !== null) {
      var d = si(a);
      if (d !== null) {
        if (((a = d.tag), a === 13)) {
          if (((a = Dy(d)), a !== null)) {
            (s.blockedOn = a),
              Ky(s.priority, function () {
                Wy(d);
              });
            return;
          }
        } else if (a === 3 && d.stateNode.current.memoizedState.isDehydrated) {
          s.blockedOn = d.tag === 3 ? d.stateNode.containerInfo : null;
          return;
        }
      }
    }
    s.blockedOn = null;
  }
  function su(s) {
    if (s.blockedOn !== null) return !1;
    for (var a = s.targetContainers; 0 < a.length; ) {
      var d = Nf(s.domEventName, s.eventSystemFlags, a[0], s.nativeEvent);
      if (d === null) {
        d = s.nativeEvent;
        var h = new d.constructor(d.type, d);
        (Ie = h), d.target.dispatchEvent(h), (Ie = null);
      } else return (a = Tl(d)), a !== null && Mf(a), (s.blockedOn = d), !1;
      a.shift();
    }
    return !0;
  }
  function Jy(s, a, d) {
    su(s) && d.delete(a);
  }
  function _M() {
    (Of = !1),
      Xr !== null && su(Xr) && (Xr = null),
      Zr !== null && su(Zr) && (Zr = null),
      eo !== null && su(eo) && (eo = null),
      fl.forEach(Jy),
      pl.forEach(Jy);
  }
  function ml(s, a) {
    s.blockedOn === a &&
      ((s.blockedOn = null),
      Of ||
        ((Of = !0),
        e.unstable_scheduleCallback(e.unstable_NormalPriority, _M)));
  }
  function gl(s) {
    function a(g) {
      return ml(g, s);
    }
    if (0 < iu.length) {
      ml(iu[0], s);
      for (var d = 1; d < iu.length; d++) {
        var h = iu[d];
        h.blockedOn === s && (h.blockedOn = null);
      }
    }
    for (
      Xr !== null && ml(Xr, s),
        Zr !== null && ml(Zr, s),
        eo !== null && ml(eo, s),
        fl.forEach(a),
        pl.forEach(a),
        d = 0;
      d < to.length;
      d++
    )
      (h = to[d]), h.blockedOn === s && (h.blockedOn = null);
    for (; 0 < to.length && ((d = to[0]), d.blockedOn === null); )
      Gy(d), d.blockedOn === null && to.shift();
  }
  var Yi = M.ReactCurrentBatchConfig,
    lu = !0;
  function FM(s, a, d, h) {
    var g = je,
      w = Yi.transition;
    Yi.transition = null;
    try {
      (je = 1), Tf(s, a, d, h);
    } finally {
      (je = g), (Yi.transition = w);
    }
  }
  function zM(s, a, d, h) {
    var g = je,
      w = Yi.transition;
    Yi.transition = null;
    try {
      (je = 4), Tf(s, a, d, h);
    } finally {
      (je = g), (Yi.transition = w);
    }
  }
  function Tf(s, a, d, h) {
    if (lu) {
      var g = Nf(s, a, d, h);
      if (g === null) Kf(s, a, h, au, d), qy(s, h);
      else if ($M(g, s, a, d, h)) h.stopPropagation();
      else if ((qy(s, h), a & 4 && -1 < LM.indexOf(s))) {
        for (; g !== null; ) {
          var w = Tl(g);
          if (
            (w !== null && Vy(w),
            (w = Nf(s, a, d, h)),
            w === null && Kf(s, a, h, au, d),
            w === g)
          )
            break;
          g = w;
        }
        g !== null && h.stopPropagation();
      } else Kf(s, a, h, null, d);
    }
  }
  var au = null;
  function Nf(s, a, d, h) {
    if (((au = null), (s = lt(h)), (s = li(s)), s !== null))
      if (((a = si(s)), a === null)) s = null;
      else if (((d = a.tag), d === 13)) {
        if (((s = Dy(a)), s !== null)) return s;
        s = null;
      } else if (d === 3) {
        if (a.stateNode.current.memoizedState.isDehydrated)
          return a.tag === 3 ? a.stateNode.containerInfo : null;
        s = null;
      } else a !== s && (s = null);
    return (au = s), null;
  }
  function Qy(s) {
    switch (s) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (MM()) {
          case Sf:
            return 1;
          case zy:
            return 4;
          case eu:
          case OM:
            return 16;
          case jy:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var no = null,
    Af = null,
    uu = null;
  function Yy() {
    if (uu) return uu;
    var s,
      a = Af,
      d = a.length,
      h,
      g = "value" in no ? no.value : no.textContent,
      w = g.length;
    for (s = 0; s < d && a[s] === g[s]; s++);
    var k = d - s;
    for (h = 1; h <= k && a[d - h] === g[w - h]; h++);
    return (uu = g.slice(s, 1 < h ? 1 - h : void 0));
  }
  function cu(s) {
    var a = s.keyCode;
    return (
      "charCode" in s
        ? ((s = s.charCode), s === 0 && a === 13 && (s = 13))
        : (s = a),
      s === 10 && (s = 13),
      32 <= s || s === 13 ? s : 0
    );
  }
  function du() {
    return !0;
  }
  function Xy() {
    return !1;
  }
  function an(s) {
    function a(d, h, g, w, k) {
      (this._reactName = d),
        (this._targetInst = g),
        (this.type = h),
        (this.nativeEvent = w),
        (this.target = k),
        (this.currentTarget = null);
      for (var T in s)
        s.hasOwnProperty(T) && ((d = s[T]), (this[T] = d ? d(w) : w[T]));
      return (
        (this.isDefaultPrevented = (
          w.defaultPrevented != null ? w.defaultPrevented : w.returnValue === !1
        )
          ? du
          : Xy),
        (this.isPropagationStopped = Xy),
        this
      );
    }
    return (
      K(a.prototype, {
        preventDefault: function () {
          this.defaultPrevented = !0;
          var d = this.nativeEvent;
          d &&
            (d.preventDefault
              ? d.preventDefault()
              : typeof d.returnValue != "unknown" && (d.returnValue = !1),
            (this.isDefaultPrevented = du));
        },
        stopPropagation: function () {
          var d = this.nativeEvent;
          d &&
            (d.stopPropagation
              ? d.stopPropagation()
              : typeof d.cancelBubble != "unknown" && (d.cancelBubble = !0),
            (this.isPropagationStopped = du));
        },
        persist: function () {},
        isPersistent: du,
      }),
      a
    );
  }
  var Xi = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function (s) {
        return s.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0,
    },
    Rf = an(Xi),
    yl = K({}, Xi, { view: 0, detail: 0 }),
    jM = an(yl),
    Pf,
    Df,
    vl,
    fu = K({}, yl, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: Lf,
      button: 0,
      buttons: 0,
      relatedTarget: function (s) {
        return s.relatedTarget === void 0
          ? s.fromElement === s.srcElement
            ? s.toElement
            : s.fromElement
          : s.relatedTarget;
      },
      movementX: function (s) {
        return "movementX" in s
          ? s.movementX
          : (s !== vl &&
              (vl && s.type === "mousemove"
                ? ((Pf = s.screenX - vl.screenX), (Df = s.screenY - vl.screenY))
                : (Df = Pf = 0),
              (vl = s)),
            Pf);
      },
      movementY: function (s) {
        return "movementY" in s ? s.movementY : Df;
      },
    }),
    Zy = an(fu),
    BM = K({}, fu, { dataTransfer: 0 }),
    HM = an(BM),
    VM = K({}, yl, { relatedTarget: 0 }),
    If = an(VM),
    WM = K({}, Xi, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
    UM = an(WM),
    KM = K({}, Xi, {
      clipboardData: function (s) {
        return "clipboardData" in s ? s.clipboardData : window.clipboardData;
      },
    }),
    qM = an(KM),
    GM = K({}, Xi, { data: 0 }),
    ev = an(GM),
    JM = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified",
    },
    QM = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta",
    },
    YM = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey",
    };
  function XM(s) {
    var a = this.nativeEvent;
    return a.getModifierState
      ? a.getModifierState(s)
      : (s = YM[s])
      ? !!a[s]
      : !1;
  }
  function Lf() {
    return XM;
  }
  var ZM = K({}, yl, {
      key: function (s) {
        if (s.key) {
          var a = JM[s.key] || s.key;
          if (a !== "Unidentified") return a;
        }
        return s.type === "keypress"
          ? ((s = cu(s)), s === 13 ? "Enter" : String.fromCharCode(s))
          : s.type === "keydown" || s.type === "keyup"
          ? QM[s.keyCode] || "Unidentified"
          : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: Lf,
      charCode: function (s) {
        return s.type === "keypress" ? cu(s) : 0;
      },
      keyCode: function (s) {
        return s.type === "keydown" || s.type === "keyup" ? s.keyCode : 0;
      },
      which: function (s) {
        return s.type === "keypress"
          ? cu(s)
          : s.type === "keydown" || s.type === "keyup"
          ? s.keyCode
          : 0;
      },
    }),
    e2 = an(ZM),
    t2 = K({}, fu, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0,
    }),
    tv = an(t2),
    n2 = K({}, yl, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: Lf,
    }),
    r2 = an(n2),
    o2 = K({}, Xi, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
    i2 = an(o2),
    s2 = K({}, fu, {
      deltaX: function (s) {
        return "deltaX" in s
          ? s.deltaX
          : "wheelDeltaX" in s
          ? -s.wheelDeltaX
          : 0;
      },
      deltaY: function (s) {
        return "deltaY" in s
          ? s.deltaY
          : "wheelDeltaY" in s
          ? -s.wheelDeltaY
          : "wheelDelta" in s
          ? -s.wheelDelta
          : 0;
      },
      deltaZ: 0,
      deltaMode: 0,
    }),
    l2 = an(s2),
    a2 = [9, 13, 27, 32],
    $f = u && "CompositionEvent" in window,
    wl = null;
  u && "documentMode" in document && (wl = document.documentMode);
  var u2 = u && "TextEvent" in window && !wl,
    nv = u && (!$f || (wl && 8 < wl && 11 >= wl)),
    rv = " ",
    ov = !1;
  function iv(s, a) {
    switch (s) {
      case "keyup":
        return a2.indexOf(a.keyCode) !== -1;
      case "keydown":
        return a.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function sv(s) {
    return (s = s.detail), typeof s == "object" && "data" in s ? s.data : null;
  }
  var Zi = !1;
  function c2(s, a) {
    switch (s) {
      case "compositionend":
        return sv(a);
      case "keypress":
        return a.which !== 32 ? null : ((ov = !0), rv);
      case "textInput":
        return (s = a.data), s === rv && ov ? null : s;
      default:
        return null;
    }
  }
  function d2(s, a) {
    if (Zi)
      return s === "compositionend" || (!$f && iv(s, a))
        ? ((s = Yy()), (uu = Af = no = null), (Zi = !1), s)
        : null;
    switch (s) {
      case "paste":
        return null;
      case "keypress":
        if (!(a.ctrlKey || a.altKey || a.metaKey) || (a.ctrlKey && a.altKey)) {
          if (a.char && 1 < a.char.length) return a.char;
          if (a.which) return String.fromCharCode(a.which);
        }
        return null;
      case "compositionend":
        return nv && a.locale !== "ko" ? null : a.data;
      default:
        return null;
    }
  }
  var f2 = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0,
  };
  function lv(s) {
    var a = s && s.nodeName && s.nodeName.toLowerCase();
    return a === "input" ? !!f2[s.type] : a === "textarea";
  }
  function av(s, a, d, h) {
    Qi(h),
      (a = yu(a, "onChange")),
      0 < a.length &&
        ((d = new Rf("onChange", "change", null, d, h)),
        s.push({ event: d, listeners: a }));
  }
  var xl = null,
    bl = null;
  function p2(s) {
    Mv(s, 0);
  }
  function pu(s) {
    var a = is(s);
    if (tr(a)) return s;
  }
  function h2(s, a) {
    if (s === "change") return a;
  }
  var uv = !1;
  if (u) {
    var _f;
    if (u) {
      var Ff = "oninput" in document;
      if (!Ff) {
        var cv = document.createElement("div");
        cv.setAttribute("oninput", "return;"),
          (Ff = typeof cv.oninput == "function");
      }
      _f = Ff;
    } else _f = !1;
    uv = _f && (!document.documentMode || 9 < document.documentMode);
  }
  function dv() {
    xl && (xl.detachEvent("onpropertychange", fv), (bl = xl = null));
  }
  function fv(s) {
    if (s.propertyName === "value" && pu(bl)) {
      var a = [];
      av(a, bl, s, lt(s)), ii(p2, a);
    }
  }
  function m2(s, a, d) {
    s === "focusin"
      ? (dv(), (xl = a), (bl = d), xl.attachEvent("onpropertychange", fv))
      : s === "focusout" && dv();
  }
  function g2(s) {
    if (s === "selectionchange" || s === "keyup" || s === "keydown")
      return pu(bl);
  }
  function y2(s, a) {
    if (s === "click") return pu(a);
  }
  function v2(s, a) {
    if (s === "input" || s === "change") return pu(a);
  }
  function w2(s, a) {
    return (s === a && (s !== 0 || 1 / s === 1 / a)) || (s !== s && a !== a);
  }
  var zn = typeof Object.is == "function" ? Object.is : w2;
  function Sl(s, a) {
    if (zn(s, a)) return !0;
    if (
      typeof s != "object" ||
      s === null ||
      typeof a != "object" ||
      a === null
    )
      return !1;
    var d = Object.keys(s),
      h = Object.keys(a);
    if (d.length !== h.length) return !1;
    for (h = 0; h < d.length; h++) {
      var g = d[h];
      if (!c.call(a, g) || !zn(s[g], a[g])) return !1;
    }
    return !0;
  }
  function pv(s) {
    for (; s && s.firstChild; ) s = s.firstChild;
    return s;
  }
  function hv(s, a) {
    var d = pv(s);
    s = 0;
    for (var h; d; ) {
      if (d.nodeType === 3) {
        if (((h = s + d.textContent.length), s <= a && h >= a))
          return { node: d, offset: a - s };
        s = h;
      }
      e: {
        for (; d; ) {
          if (d.nextSibling) {
            d = d.nextSibling;
            break e;
          }
          d = d.parentNode;
        }
        d = void 0;
      }
      d = pv(d);
    }
  }
  function mv(s, a) {
    return s && a
      ? s === a
        ? !0
        : s && s.nodeType === 3
        ? !1
        : a && a.nodeType === 3
        ? mv(s, a.parentNode)
        : "contains" in s
        ? s.contains(a)
        : s.compareDocumentPosition
        ? !!(s.compareDocumentPosition(a) & 16)
        : !1
      : !1;
  }
  function gv() {
    for (var s = window, a = Mt(); a instanceof s.HTMLIFrameElement; ) {
      try {
        var d = typeof a.contentWindow.location.href == "string";
      } catch {
        d = !1;
      }
      if (d) s = a.contentWindow;
      else break;
      a = Mt(s.document);
    }
    return a;
  }
  function zf(s) {
    var a = s && s.nodeName && s.nodeName.toLowerCase();
    return (
      a &&
      ((a === "input" &&
        (s.type === "text" ||
          s.type === "search" ||
          s.type === "tel" ||
          s.type === "url" ||
          s.type === "password")) ||
        a === "textarea" ||
        s.contentEditable === "true")
    );
  }
  function x2(s) {
    var a = gv(),
      d = s.focusedElem,
      h = s.selectionRange;
    if (
      a !== d &&
      d &&
      d.ownerDocument &&
      mv(d.ownerDocument.documentElement, d)
    ) {
      if (h !== null && zf(d)) {
        if (
          ((a = h.start),
          (s = h.end),
          s === void 0 && (s = a),
          "selectionStart" in d)
        )
          (d.selectionStart = a),
            (d.selectionEnd = Math.min(s, d.value.length));
        else if (
          ((s = ((a = d.ownerDocument || document) && a.defaultView) || window),
          s.getSelection)
        ) {
          s = s.getSelection();
          var g = d.textContent.length,
            w = Math.min(h.start, g);
          (h = h.end === void 0 ? w : Math.min(h.end, g)),
            !s.extend && w > h && ((g = h), (h = w), (w = g)),
            (g = hv(d, w));
          var k = hv(d, h);
          g &&
            k &&
            (s.rangeCount !== 1 ||
              s.anchorNode !== g.node ||
              s.anchorOffset !== g.offset ||
              s.focusNode !== k.node ||
              s.focusOffset !== k.offset) &&
            ((a = a.createRange()),
            a.setStart(g.node, g.offset),
            s.removeAllRanges(),
            w > h
              ? (s.addRange(a), s.extend(k.node, k.offset))
              : (a.setEnd(k.node, k.offset), s.addRange(a)));
        }
      }
      for (a = [], s = d; (s = s.parentNode); )
        s.nodeType === 1 &&
          a.push({ element: s, left: s.scrollLeft, top: s.scrollTop });
      for (typeof d.focus == "function" && d.focus(), d = 0; d < a.length; d++)
        (s = a[d]),
          (s.element.scrollLeft = s.left),
          (s.element.scrollTop = s.top);
    }
  }
  var b2 = u && "documentMode" in document && 11 >= document.documentMode,
    es = null,
    jf = null,
    Cl = null,
    Bf = !1;
  function yv(s, a, d) {
    var h =
      d.window === d ? d.document : d.nodeType === 9 ? d : d.ownerDocument;
    Bf ||
      es == null ||
      es !== Mt(h) ||
      ((h = es),
      "selectionStart" in h && zf(h)
        ? (h = { start: h.selectionStart, end: h.selectionEnd })
        : ((h = (
            (h.ownerDocument && h.ownerDocument.defaultView) ||
            window
          ).getSelection()),
          (h = {
            anchorNode: h.anchorNode,
            anchorOffset: h.anchorOffset,
            focusNode: h.focusNode,
            focusOffset: h.focusOffset,
          })),
      (Cl && Sl(Cl, h)) ||
        ((Cl = h),
        (h = yu(jf, "onSelect")),
        0 < h.length &&
          ((a = new Rf("onSelect", "select", null, a, d)),
          s.push({ event: a, listeners: h }),
          (a.target = es))));
  }
  function hu(s, a) {
    var d = {};
    return (
      (d[s.toLowerCase()] = a.toLowerCase()),
      (d["Webkit" + s] = "webkit" + a),
      (d["Moz" + s] = "moz" + a),
      d
    );
  }
  var ts = {
      animationend: hu("Animation", "AnimationEnd"),
      animationiteration: hu("Animation", "AnimationIteration"),
      animationstart: hu("Animation", "AnimationStart"),
      transitionend: hu("Transition", "TransitionEnd"),
    },
    Hf = {},
    vv = {};
  u &&
    ((vv = document.createElement("div").style),
    "AnimationEvent" in window ||
      (delete ts.animationend.animation,
      delete ts.animationiteration.animation,
      delete ts.animationstart.animation),
    "TransitionEvent" in window || delete ts.transitionend.transition);
  function mu(s) {
    if (Hf[s]) return Hf[s];
    if (!ts[s]) return s;
    var a = ts[s],
      d;
    for (d in a) if (a.hasOwnProperty(d) && d in vv) return (Hf[s] = a[d]);
    return s;
  }
  var wv = mu("animationend"),
    xv = mu("animationiteration"),
    bv = mu("animationstart"),
    Sv = mu("transitionend"),
    Cv = new Map(),
    kv =
      "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
        " "
      );
  function ro(s, a) {
    Cv.set(s, a), i(a, [s]);
  }
  for (var Vf = 0; Vf < kv.length; Vf++) {
    var Wf = kv[Vf],
      S2 = Wf.toLowerCase(),
      C2 = Wf[0].toUpperCase() + Wf.slice(1);
    ro(S2, "on" + C2);
  }
  ro(wv, "onAnimationEnd"),
    ro(xv, "onAnimationIteration"),
    ro(bv, "onAnimationStart"),
    ro("dblclick", "onDoubleClick"),
    ro("focusin", "onFocus"),
    ro("focusout", "onBlur"),
    ro(Sv, "onTransitionEnd"),
    l("onMouseEnter", ["mouseout", "mouseover"]),
    l("onMouseLeave", ["mouseout", "mouseover"]),
    l("onPointerEnter", ["pointerout", "pointerover"]),
    l("onPointerLeave", ["pointerout", "pointerover"]),
    i(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(
        " "
      )
    ),
    i(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " "
      )
    ),
    i("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
    i(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" ")
    ),
    i(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" ")
    ),
    i(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
    );
  var kl =
      "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
        " "
      ),
    k2 = new Set(
      "cancel close invalid load scroll toggle".split(" ").concat(kl)
    );
  function Ev(s, a, d) {
    var h = s.type || "unknown-event";
    (s.currentTarget = d), SM(h, a, void 0, s), (s.currentTarget = null);
  }
  function Mv(s, a) {
    a = (a & 4) !== 0;
    for (var d = 0; d < s.length; d++) {
      var h = s[d],
        g = h.event;
      h = h.listeners;
      e: {
        var w = void 0;
        if (a)
          for (var k = h.length - 1; 0 <= k; k--) {
            var T = h[k],
              P = T.instance,
              j = T.currentTarget;
            if (((T = T.listener), P !== w && g.isPropagationStopped()))
              break e;
            Ev(g, T, j), (w = P);
          }
        else
          for (k = 0; k < h.length; k++) {
            if (
              ((T = h[k]),
              (P = T.instance),
              (j = T.currentTarget),
              (T = T.listener),
              P !== w && g.isPropagationStopped())
            )
              break e;
            Ev(g, T, j), (w = P);
          }
      }
    }
    if (Za) throw ((s = bf), (Za = !1), (bf = null), s);
  }
  function We(s, a) {
    var d = a[Xf];
    d === void 0 && (d = a[Xf] = new Set());
    var h = s + "__bubble";
    d.has(h) || (Ov(a, s, 2, !1), d.add(h));
  }
  function Uf(s, a, d) {
    var h = 0;
    a && (h |= 4), Ov(d, s, h, a);
  }
  var gu = "_reactListening" + Math.random().toString(36).slice(2);
  function El(s) {
    if (!s[gu]) {
      (s[gu] = !0),
        r.forEach(function (d) {
          d !== "selectionchange" && (k2.has(d) || Uf(d, !1, s), Uf(d, !0, s));
        });
      var a = s.nodeType === 9 ? s : s.ownerDocument;
      a === null || a[gu] || ((a[gu] = !0), Uf("selectionchange", !1, a));
    }
  }
  function Ov(s, a, d, h) {
    switch (Qy(a)) {
      case 1:
        var g = FM;
        break;
      case 4:
        g = zM;
        break;
      default:
        g = Tf;
    }
    (d = g.bind(null, a, d, s)),
      (g = void 0),
      !xf ||
        (a !== "touchstart" && a !== "touchmove" && a !== "wheel") ||
        (g = !0),
      h
        ? g !== void 0
          ? s.addEventListener(a, d, { capture: !0, passive: g })
          : s.addEventListener(a, d, !0)
        : g !== void 0
        ? s.addEventListener(a, d, { passive: g })
        : s.addEventListener(a, d, !1);
  }
  function Kf(s, a, d, h, g) {
    var w = h;
    if (!(a & 1) && !(a & 2) && h !== null)
      e: for (;;) {
        if (h === null) return;
        var k = h.tag;
        if (k === 3 || k === 4) {
          var T = h.stateNode.containerInfo;
          if (T === g || (T.nodeType === 8 && T.parentNode === g)) break;
          if (k === 4)
            for (k = h.return; k !== null; ) {
              var P = k.tag;
              if (
                (P === 3 || P === 4) &&
                ((P = k.stateNode.containerInfo),
                P === g || (P.nodeType === 8 && P.parentNode === g))
              )
                return;
              k = k.return;
            }
          for (; T !== null; ) {
            if (((k = li(T)), k === null)) return;
            if (((P = k.tag), P === 5 || P === 6)) {
              h = w = k;
              continue e;
            }
            T = T.parentNode;
          }
        }
        h = h.return;
      }
    ii(function () {
      var j = w,
        G = lt(d),
        Y = [];
      e: {
        var q = Cv.get(s);
        if (q !== void 0) {
          var ue = Rf,
            pe = s;
          switch (s) {
            case "keypress":
              if (cu(d) === 0) break e;
            case "keydown":
            case "keyup":
              ue = e2;
              break;
            case "focusin":
              (pe = "focus"), (ue = If);
              break;
            case "focusout":
              (pe = "blur"), (ue = If);
              break;
            case "beforeblur":
            case "afterblur":
              ue = If;
              break;
            case "click":
              if (d.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              ue = Zy;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              ue = HM;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              ue = r2;
              break;
            case wv:
            case xv:
            case bv:
              ue = UM;
              break;
            case Sv:
              ue = i2;
              break;
            case "scroll":
              ue = jM;
              break;
            case "wheel":
              ue = l2;
              break;
            case "copy":
            case "cut":
            case "paste":
              ue = qM;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              ue = tv;
          }
          var ye = (a & 4) !== 0,
            ot = !ye && s === "scroll",
            _ = ye ? (q !== null ? q + "Capture" : null) : q;
          ye = [];
          for (var L = j, z; L !== null; ) {
            z = L;
            var te = z.stateNode;
            if (
              (z.tag === 5 &&
                te !== null &&
                ((z = te),
                _ !== null &&
                  ((te = ll(L, _)), te != null && ye.push(Ml(L, te, z)))),
              ot)
            )
              break;
            L = L.return;
          }
          0 < ye.length &&
            ((q = new ue(q, pe, null, d, G)),
            Y.push({ event: q, listeners: ye }));
        }
      }
      if (!(a & 7)) {
        e: {
          if (
            ((q = s === "mouseover" || s === "pointerover"),
            (ue = s === "mouseout" || s === "pointerout"),
            q &&
              d !== Ie &&
              (pe = d.relatedTarget || d.fromElement) &&
              (li(pe) || pe[Tr]))
          )
            break e;
          if (
            (ue || q) &&
            ((q =
              G.window === G
                ? G
                : (q = G.ownerDocument)
                ? q.defaultView || q.parentWindow
                : window),
            ue
              ? ((pe = d.relatedTarget || d.toElement),
                (ue = j),
                (pe = pe ? li(pe) : null),
                pe !== null &&
                  ((ot = si(pe)),
                  pe !== ot || (pe.tag !== 5 && pe.tag !== 6)) &&
                  (pe = null))
              : ((ue = null), (pe = j)),
            ue !== pe)
          ) {
            if (
              ((ye = Zy),
              (te = "onMouseLeave"),
              (_ = "onMouseEnter"),
              (L = "mouse"),
              (s === "pointerout" || s === "pointerover") &&
                ((ye = tv),
                (te = "onPointerLeave"),
                (_ = "onPointerEnter"),
                (L = "pointer")),
              (ot = ue == null ? q : is(ue)),
              (z = pe == null ? q : is(pe)),
              (q = new ye(te, L + "leave", ue, d, G)),
              (q.target = ot),
              (q.relatedTarget = z),
              (te = null),
              li(G) === j &&
                ((ye = new ye(_, L + "enter", pe, d, G)),
                (ye.target = z),
                (ye.relatedTarget = ot),
                (te = ye)),
              (ot = te),
              ue && pe)
            )
              t: {
                for (ye = ue, _ = pe, L = 0, z = ye; z; z = ns(z)) L++;
                for (z = 0, te = _; te; te = ns(te)) z++;
                for (; 0 < L - z; ) (ye = ns(ye)), L--;
                for (; 0 < z - L; ) (_ = ns(_)), z--;
                for (; L--; ) {
                  if (ye === _ || (_ !== null && ye === _.alternate)) break t;
                  (ye = ns(ye)), (_ = ns(_));
                }
                ye = null;
              }
            else ye = null;
            ue !== null && Tv(Y, q, ue, ye, !1),
              pe !== null && ot !== null && Tv(Y, ot, pe, ye, !0);
          }
        }
        e: {
          if (
            ((q = j ? is(j) : window),
            (ue = q.nodeName && q.nodeName.toLowerCase()),
            ue === "select" || (ue === "input" && q.type === "file"))
          )
            var ve = h2;
          else if (lv(q))
            if (uv) ve = v2;
            else {
              ve = g2;
              var Se = m2;
            }
          else
            (ue = q.nodeName) &&
              ue.toLowerCase() === "input" &&
              (q.type === "checkbox" || q.type === "radio") &&
              (ve = y2);
          if (ve && (ve = ve(s, j))) {
            av(Y, ve, d, G);
            break e;
          }
          Se && Se(s, q, j),
            s === "focusout" &&
              (Se = q._wrapperState) &&
              Se.controlled &&
              q.type === "number" &&
              sn(q, "number", q.value);
        }
        switch (((Se = j ? is(j) : window), s)) {
          case "focusin":
            (lv(Se) || Se.contentEditable === "true") &&
              ((es = Se), (jf = j), (Cl = null));
            break;
          case "focusout":
            Cl = jf = es = null;
            break;
          case "mousedown":
            Bf = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            (Bf = !1), yv(Y, d, G);
            break;
          case "selectionchange":
            if (b2) break;
          case "keydown":
          case "keyup":
            yv(Y, d, G);
        }
        var Ce;
        if ($f)
          e: {
            switch (s) {
              case "compositionstart":
                var Me = "onCompositionStart";
                break e;
              case "compositionend":
                Me = "onCompositionEnd";
                break e;
              case "compositionupdate":
                Me = "onCompositionUpdate";
                break e;
            }
            Me = void 0;
          }
        else
          Zi
            ? iv(s, d) && (Me = "onCompositionEnd")
            : s === "keydown" &&
              d.keyCode === 229 &&
              (Me = "onCompositionStart");
        Me &&
          (nv &&
            d.locale !== "ko" &&
            (Zi || Me !== "onCompositionStart"
              ? Me === "onCompositionEnd" && Zi && (Ce = Yy())
              : ((no = G),
                (Af = "value" in no ? no.value : no.textContent),
                (Zi = !0))),
          (Se = yu(j, Me)),
          0 < Se.length &&
            ((Me = new ev(Me, s, null, d, G)),
            Y.push({ event: Me, listeners: Se }),
            Ce
              ? (Me.data = Ce)
              : ((Ce = sv(d)), Ce !== null && (Me.data = Ce)))),
          (Ce = u2 ? c2(s, d) : d2(s, d)) &&
            ((j = yu(j, "onBeforeInput")),
            0 < j.length &&
              ((G = new ev("onBeforeInput", "beforeinput", null, d, G)),
              Y.push({ event: G, listeners: j }),
              (G.data = Ce)));
      }
      Mv(Y, a);
    });
  }
  function Ml(s, a, d) {
    return { instance: s, listener: a, currentTarget: d };
  }
  function yu(s, a) {
    for (var d = a + "Capture", h = []; s !== null; ) {
      var g = s,
        w = g.stateNode;
      g.tag === 5 &&
        w !== null &&
        ((g = w),
        (w = ll(s, d)),
        w != null && h.unshift(Ml(s, w, g)),
        (w = ll(s, a)),
        w != null && h.push(Ml(s, w, g))),
        (s = s.return);
    }
    return h;
  }
  function ns(s) {
    if (s === null) return null;
    do s = s.return;
    while (s && s.tag !== 5);
    return s || null;
  }
  function Tv(s, a, d, h, g) {
    for (var w = a._reactName, k = []; d !== null && d !== h; ) {
      var T = d,
        P = T.alternate,
        j = T.stateNode;
      if (P !== null && P === h) break;
      T.tag === 5 &&
        j !== null &&
        ((T = j),
        g
          ? ((P = ll(d, w)), P != null && k.unshift(Ml(d, P, T)))
          : g || ((P = ll(d, w)), P != null && k.push(Ml(d, P, T)))),
        (d = d.return);
    }
    k.length !== 0 && s.push({ event: a, listeners: k });
  }
  var E2 = /\r\n?/g,
    M2 = /\u0000|\uFFFD/g;
  function Nv(s) {
    return (typeof s == "string" ? s : "" + s)
      .replace(
        E2,
        `
`
      )
      .replace(M2, "");
  }
  function vu(s, a, d) {
    if (((a = Nv(a)), Nv(s) !== a && d)) throw Error(n(425));
  }
  function wu() {}
  var qf = null,
    Gf = null;
  function Jf(s, a) {
    return (
      s === "textarea" ||
      s === "noscript" ||
      typeof a.children == "string" ||
      typeof a.children == "number" ||
      (typeof a.dangerouslySetInnerHTML == "object" &&
        a.dangerouslySetInnerHTML !== null &&
        a.dangerouslySetInnerHTML.__html != null)
    );
  }
  var Qf = typeof setTimeout == "function" ? setTimeout : void 0,
    O2 = typeof clearTimeout == "function" ? clearTimeout : void 0,
    Av = typeof Promise == "function" ? Promise : void 0,
    T2 =
      typeof queueMicrotask == "function"
        ? queueMicrotask
        : typeof Av < "u"
        ? function (s) {
            return Av.resolve(null).then(s).catch(N2);
          }
        : Qf;
  function N2(s) {
    setTimeout(function () {
      throw s;
    });
  }
  function Yf(s, a) {
    var d = a,
      h = 0;
    do {
      var g = d.nextSibling;
      if ((s.removeChild(d), g && g.nodeType === 8))
        if (((d = g.data), d === "/$")) {
          if (h === 0) {
            s.removeChild(g), gl(a);
            return;
          }
          h--;
        } else (d !== "$" && d !== "$?" && d !== "$!") || h++;
      d = g;
    } while (d);
    gl(a);
  }
  function oo(s) {
    for (; s != null; s = s.nextSibling) {
      var a = s.nodeType;
      if (a === 1 || a === 3) break;
      if (a === 8) {
        if (((a = s.data), a === "$" || a === "$!" || a === "$?")) break;
        if (a === "/$") return null;
      }
    }
    return s;
  }
  function Rv(s) {
    s = s.previousSibling;
    for (var a = 0; s; ) {
      if (s.nodeType === 8) {
        var d = s.data;
        if (d === "$" || d === "$!" || d === "$?") {
          if (a === 0) return s;
          a--;
        } else d === "/$" && a++;
      }
      s = s.previousSibling;
    }
    return null;
  }
  var rs = Math.random().toString(36).slice(2),
    sr = "__reactFiber$" + rs,
    Ol = "__reactProps$" + rs,
    Tr = "__reactContainer$" + rs,
    Xf = "__reactEvents$" + rs,
    A2 = "__reactListeners$" + rs,
    R2 = "__reactHandles$" + rs;
  function li(s) {
    var a = s[sr];
    if (a) return a;
    for (var d = s.parentNode; d; ) {
      if ((a = d[Tr] || d[sr])) {
        if (
          ((d = a.alternate),
          a.child !== null || (d !== null && d.child !== null))
        )
          for (s = Rv(s); s !== null; ) {
            if ((d = s[sr])) return d;
            s = Rv(s);
          }
        return a;
      }
      (s = d), (d = s.parentNode);
    }
    return null;
  }
  function Tl(s) {
    return (
      (s = s[sr] || s[Tr]),
      !s || (s.tag !== 5 && s.tag !== 6 && s.tag !== 13 && s.tag !== 3)
        ? null
        : s
    );
  }
  function is(s) {
    if (s.tag === 5 || s.tag === 6) return s.stateNode;
    throw Error(n(33));
  }
  function xu(s) {
    return s[Ol] || null;
  }
  var Zf = [],
    ss = -1;
  function io(s) {
    return { current: s };
  }
  function Ue(s) {
    0 > ss || ((s.current = Zf[ss]), (Zf[ss] = null), ss--);
  }
  function Ve(s, a) {
    ss++, (Zf[ss] = s.current), (s.current = a);
  }
  var so = {},
    Tt = io(so),
    qt = io(!1),
    ai = so;
  function ls(s, a) {
    var d = s.type.contextTypes;
    if (!d) return so;
    var h = s.stateNode;
    if (h && h.__reactInternalMemoizedUnmaskedChildContext === a)
      return h.__reactInternalMemoizedMaskedChildContext;
    var g = {},
      w;
    for (w in d) g[w] = a[w];
    return (
      h &&
        ((s = s.stateNode),
        (s.__reactInternalMemoizedUnmaskedChildContext = a),
        (s.__reactInternalMemoizedMaskedChildContext = g)),
      g
    );
  }
  function Gt(s) {
    return (s = s.childContextTypes), s != null;
  }
  function bu() {
    Ue(qt), Ue(Tt);
  }
  function Pv(s, a, d) {
    if (Tt.current !== so) throw Error(n(168));
    Ve(Tt, a), Ve(qt, d);
  }
  function Dv(s, a, d) {
    var h = s.stateNode;
    if (((a = a.childContextTypes), typeof h.getChildContext != "function"))
      return d;
    h = h.getChildContext();
    for (var g in h) if (!(g in a)) throw Error(n(108, he(s) || "Unknown", g));
    return K({}, d, h);
  }
  function Su(s) {
    return (
      (s =
        ((s = s.stateNode) && s.__reactInternalMemoizedMergedChildContext) ||
        so),
      (ai = Tt.current),
      Ve(Tt, s),
      Ve(qt, qt.current),
      !0
    );
  }
  function Iv(s, a, d) {
    var h = s.stateNode;
    if (!h) throw Error(n(169));
    d
      ? ((s = Dv(s, a, ai)),
        (h.__reactInternalMemoizedMergedChildContext = s),
        Ue(qt),
        Ue(Tt),
        Ve(Tt, s))
      : Ue(qt),
      Ve(qt, d);
  }
  var Nr = null,
    Cu = !1,
    ep = !1;
  function Lv(s) {
    Nr === null ? (Nr = [s]) : Nr.push(s);
  }
  function P2(s) {
    (Cu = !0), Lv(s);
  }
  function lo() {
    if (!ep && Nr !== null) {
      ep = !0;
      var s = 0,
        a = je;
      try {
        var d = Nr;
        for (je = 1; s < d.length; s++) {
          var h = d[s];
          do h = h(!0);
          while (h !== null);
        }
        (Nr = null), (Cu = !1);
      } catch (g) {
        throw (Nr !== null && (Nr = Nr.slice(s + 1)), _y(Sf, lo), g);
      } finally {
        (je = a), (ep = !1);
      }
    }
    return null;
  }
  var as = [],
    us = 0,
    ku = null,
    Eu = 0,
    vn = [],
    wn = 0,
    ui = null,
    Ar = 1,
    Rr = "";
  function ci(s, a) {
    (as[us++] = Eu), (as[us++] = ku), (ku = s), (Eu = a);
  }
  function $v(s, a, d) {
    (vn[wn++] = Ar), (vn[wn++] = Rr), (vn[wn++] = ui), (ui = s);
    var h = Ar;
    s = Rr;
    var g = 32 - Fn(h) - 1;
    (h &= ~(1 << g)), (d += 1);
    var w = 32 - Fn(a) + g;
    if (30 < w) {
      var k = g - (g % 5);
      (w = (h & ((1 << k) - 1)).toString(32)),
        (h >>= k),
        (g -= k),
        (Ar = (1 << (32 - Fn(a) + g)) | (d << g) | h),
        (Rr = w + s);
    } else (Ar = (1 << w) | (d << g) | h), (Rr = s);
  }
  function tp(s) {
    s.return !== null && (ci(s, 1), $v(s, 1, 0));
  }
  function np(s) {
    for (; s === ku; )
      (ku = as[--us]), (as[us] = null), (Eu = as[--us]), (as[us] = null);
    for (; s === ui; )
      (ui = vn[--wn]),
        (vn[wn] = null),
        (Rr = vn[--wn]),
        (vn[wn] = null),
        (Ar = vn[--wn]),
        (vn[wn] = null);
  }
  var un = null,
    cn = null,
    Ge = !1,
    jn = null;
  function _v(s, a) {
    var d = Cn(5, null, null, 0);
    (d.elementType = "DELETED"),
      (d.stateNode = a),
      (d.return = s),
      (a = s.deletions),
      a === null ? ((s.deletions = [d]), (s.flags |= 16)) : a.push(d);
  }
  function Fv(s, a) {
    switch (s.tag) {
      case 5:
        var d = s.type;
        return (
          (a =
            a.nodeType !== 1 || d.toLowerCase() !== a.nodeName.toLowerCase()
              ? null
              : a),
          a !== null
            ? ((s.stateNode = a), (un = s), (cn = oo(a.firstChild)), !0)
            : !1
        );
      case 6:
        return (
          (a = s.pendingProps === "" || a.nodeType !== 3 ? null : a),
          a !== null ? ((s.stateNode = a), (un = s), (cn = null), !0) : !1
        );
      case 13:
        return (
          (a = a.nodeType !== 8 ? null : a),
          a !== null
            ? ((d = ui !== null ? { id: Ar, overflow: Rr } : null),
              (s.memoizedState = {
                dehydrated: a,
                treeContext: d,
                retryLane: 1073741824,
              }),
              (d = Cn(18, null, null, 0)),
              (d.stateNode = a),
              (d.return = s),
              (s.child = d),
              (un = s),
              (cn = null),
              !0)
            : !1
        );
      default:
        return !1;
    }
  }
  function rp(s) {
    return (s.mode & 1) !== 0 && (s.flags & 128) === 0;
  }
  function op(s) {
    if (Ge) {
      var a = cn;
      if (a) {
        var d = a;
        if (!Fv(s, a)) {
          if (rp(s)) throw Error(n(418));
          a = oo(d.nextSibling);
          var h = un;
          a && Fv(s, a)
            ? _v(h, d)
            : ((s.flags = (s.flags & -4097) | 2), (Ge = !1), (un = s));
        }
      } else {
        if (rp(s)) throw Error(n(418));
        (s.flags = (s.flags & -4097) | 2), (Ge = !1), (un = s);
      }
    }
  }
  function zv(s) {
    for (
      s = s.return;
      s !== null && s.tag !== 5 && s.tag !== 3 && s.tag !== 13;

    )
      s = s.return;
    un = s;
  }
  function Mu(s) {
    if (s !== un) return !1;
    if (!Ge) return zv(s), (Ge = !0), !1;
    var a;
    if (
      ((a = s.tag !== 3) &&
        !(a = s.tag !== 5) &&
        ((a = s.type),
        (a = a !== "head" && a !== "body" && !Jf(s.type, s.memoizedProps))),
      a && (a = cn))
    ) {
      if (rp(s)) throw (jv(), Error(n(418)));
      for (; a; ) _v(s, a), (a = oo(a.nextSibling));
    }
    if ((zv(s), s.tag === 13)) {
      if (((s = s.memoizedState), (s = s !== null ? s.dehydrated : null), !s))
        throw Error(n(317));
      e: {
        for (s = s.nextSibling, a = 0; s; ) {
          if (s.nodeType === 8) {
            var d = s.data;
            if (d === "/$") {
              if (a === 0) {
                cn = oo(s.nextSibling);
                break e;
              }
              a--;
            } else (d !== "$" && d !== "$!" && d !== "$?") || a++;
          }
          s = s.nextSibling;
        }
        cn = null;
      }
    } else cn = un ? oo(s.stateNode.nextSibling) : null;
    return !0;
  }
  function jv() {
    for (var s = cn; s; ) s = oo(s.nextSibling);
  }
  function cs() {
    (cn = un = null), (Ge = !1);
  }
  function ip(s) {
    jn === null ? (jn = [s]) : jn.push(s);
  }
  var D2 = M.ReactCurrentBatchConfig;
  function Nl(s, a, d) {
    if (
      ((s = d.ref),
      s !== null && typeof s != "function" && typeof s != "object")
    ) {
      if (d._owner) {
        if (((d = d._owner), d)) {
          if (d.tag !== 1) throw Error(n(309));
          var h = d.stateNode;
        }
        if (!h) throw Error(n(147, s));
        var g = h,
          w = "" + s;
        return a !== null &&
          a.ref !== null &&
          typeof a.ref == "function" &&
          a.ref._stringRef === w
          ? a.ref
          : ((a = function (k) {
              var T = g.refs;
              k === null ? delete T[w] : (T[w] = k);
            }),
            (a._stringRef = w),
            a);
      }
      if (typeof s != "string") throw Error(n(284));
      if (!d._owner) throw Error(n(290, s));
    }
    return s;
  }
  function Ou(s, a) {
    throw (
      ((s = Object.prototype.toString.call(a)),
      Error(
        n(
          31,
          s === "[object Object]"
            ? "object with keys {" + Object.keys(a).join(", ") + "}"
            : s
        )
      ))
    );
  }
  function Bv(s) {
    var a = s._init;
    return a(s._payload);
  }
  function Hv(s) {
    function a(_, L) {
      if (s) {
        var z = _.deletions;
        z === null ? ((_.deletions = [L]), (_.flags |= 16)) : z.push(L);
      }
    }
    function d(_, L) {
      if (!s) return null;
      for (; L !== null; ) a(_, L), (L = L.sibling);
      return null;
    }
    function h(_, L) {
      for (_ = new Map(); L !== null; )
        L.key !== null ? _.set(L.key, L) : _.set(L.index, L), (L = L.sibling);
      return _;
    }
    function g(_, L) {
      return (_ = go(_, L)), (_.index = 0), (_.sibling = null), _;
    }
    function w(_, L, z) {
      return (
        (_.index = z),
        s
          ? ((z = _.alternate),
            z !== null
              ? ((z = z.index), z < L ? ((_.flags |= 2), L) : z)
              : ((_.flags |= 2), L))
          : ((_.flags |= 1048576), L)
      );
    }
    function k(_) {
      return s && _.alternate === null && (_.flags |= 2), _;
    }
    function T(_, L, z, te) {
      return L === null || L.tag !== 6
        ? ((L = Qp(z, _.mode, te)), (L.return = _), L)
        : ((L = g(L, z)), (L.return = _), L);
    }
    function P(_, L, z, te) {
      var ve = z.type;
      return ve === F
        ? G(_, L, z.props.children, te, z.key)
        : L !== null &&
          (L.elementType === ve ||
            (typeof ve == "object" &&
              ve !== null &&
              ve.$$typeof === oe &&
              Bv(ve) === L.type))
        ? ((te = g(L, z.props)), (te.ref = Nl(_, L, z)), (te.return = _), te)
        : ((te = Yu(z.type, z.key, z.props, null, _.mode, te)),
          (te.ref = Nl(_, L, z)),
          (te.return = _),
          te);
    }
    function j(_, L, z, te) {
      return L === null ||
        L.tag !== 4 ||
        L.stateNode.containerInfo !== z.containerInfo ||
        L.stateNode.implementation !== z.implementation
        ? ((L = Yp(z, _.mode, te)), (L.return = _), L)
        : ((L = g(L, z.children || [])), (L.return = _), L);
    }
    function G(_, L, z, te, ve) {
      return L === null || L.tag !== 7
        ? ((L = vi(z, _.mode, te, ve)), (L.return = _), L)
        : ((L = g(L, z)), (L.return = _), L);
    }
    function Y(_, L, z) {
      if ((typeof L == "string" && L !== "") || typeof L == "number")
        return (L = Qp("" + L, _.mode, z)), (L.return = _), L;
      if (typeof L == "object" && L !== null) {
        switch (L.$$typeof) {
          case I:
            return (
              (z = Yu(L.type, L.key, L.props, null, _.mode, z)),
              (z.ref = Nl(_, null, L)),
              (z.return = _),
              z
            );
          case R:
            return (L = Yp(L, _.mode, z)), (L.return = _), L;
          case oe:
            var te = L._init;
            return Y(_, te(L._payload), z);
        }
        if ($t(L) || V(L))
          return (L = vi(L, _.mode, z, null)), (L.return = _), L;
        Ou(_, L);
      }
      return null;
    }
    function q(_, L, z, te) {
      var ve = L !== null ? L.key : null;
      if ((typeof z == "string" && z !== "") || typeof z == "number")
        return ve !== null ? null : T(_, L, "" + z, te);
      if (typeof z == "object" && z !== null) {
        switch (z.$$typeof) {
          case I:
            return z.key === ve ? P(_, L, z, te) : null;
          case R:
            return z.key === ve ? j(_, L, z, te) : null;
          case oe:
            return (ve = z._init), q(_, L, ve(z._payload), te);
        }
        if ($t(z) || V(z)) return ve !== null ? null : G(_, L, z, te, null);
        Ou(_, z);
      }
      return null;
    }
    function ue(_, L, z, te, ve) {
      if ((typeof te == "string" && te !== "") || typeof te == "number")
        return (_ = _.get(z) || null), T(L, _, "" + te, ve);
      if (typeof te == "object" && te !== null) {
        switch (te.$$typeof) {
          case I:
            return (
              (_ = _.get(te.key === null ? z : te.key) || null), P(L, _, te, ve)
            );
          case R:
            return (
              (_ = _.get(te.key === null ? z : te.key) || null), j(L, _, te, ve)
            );
          case oe:
            var Se = te._init;
            return ue(_, L, z, Se(te._payload), ve);
        }
        if ($t(te) || V(te))
          return (_ = _.get(z) || null), G(L, _, te, ve, null);
        Ou(L, te);
      }
      return null;
    }
    function pe(_, L, z, te) {
      for (
        var ve = null, Se = null, Ce = L, Me = (L = 0), gt = null;
        Ce !== null && Me < z.length;
        Me++
      ) {
        Ce.index > Me ? ((gt = Ce), (Ce = null)) : (gt = Ce.sibling);
        var ze = q(_, Ce, z[Me], te);
        if (ze === null) {
          Ce === null && (Ce = gt);
          break;
        }
        s && Ce && ze.alternate === null && a(_, Ce),
          (L = w(ze, L, Me)),
          Se === null ? (ve = ze) : (Se.sibling = ze),
          (Se = ze),
          (Ce = gt);
      }
      if (Me === z.length) return d(_, Ce), Ge && ci(_, Me), ve;
      if (Ce === null) {
        for (; Me < z.length; Me++)
          (Ce = Y(_, z[Me], te)),
            Ce !== null &&
              ((L = w(Ce, L, Me)),
              Se === null ? (ve = Ce) : (Se.sibling = Ce),
              (Se = Ce));
        return Ge && ci(_, Me), ve;
      }
      for (Ce = h(_, Ce); Me < z.length; Me++)
        (gt = ue(Ce, _, Me, z[Me], te)),
          gt !== null &&
            (s &&
              gt.alternate !== null &&
              Ce.delete(gt.key === null ? Me : gt.key),
            (L = w(gt, L, Me)),
            Se === null ? (ve = gt) : (Se.sibling = gt),
            (Se = gt));
      return (
        s &&
          Ce.forEach(function (yo) {
            return a(_, yo);
          }),
        Ge && ci(_, Me),
        ve
      );
    }
    function ye(_, L, z, te) {
      var ve = V(z);
      if (typeof ve != "function") throw Error(n(150));
      if (((z = ve.call(z)), z == null)) throw Error(n(151));
      for (
        var Se = (ve = null), Ce = L, Me = (L = 0), gt = null, ze = z.next();
        Ce !== null && !ze.done;
        Me++, ze = z.next()
      ) {
        Ce.index > Me ? ((gt = Ce), (Ce = null)) : (gt = Ce.sibling);
        var yo = q(_, Ce, ze.value, te);
        if (yo === null) {
          Ce === null && (Ce = gt);
          break;
        }
        s && Ce && yo.alternate === null && a(_, Ce),
          (L = w(yo, L, Me)),
          Se === null ? (ve = yo) : (Se.sibling = yo),
          (Se = yo),
          (Ce = gt);
      }
      if (ze.done) return d(_, Ce), Ge && ci(_, Me), ve;
      if (Ce === null) {
        for (; !ze.done; Me++, ze = z.next())
          (ze = Y(_, ze.value, te)),
            ze !== null &&
              ((L = w(ze, L, Me)),
              Se === null ? (ve = ze) : (Se.sibling = ze),
              (Se = ze));
        return Ge && ci(_, Me), ve;
      }
      for (Ce = h(_, Ce); !ze.done; Me++, ze = z.next())
        (ze = ue(Ce, _, Me, ze.value, te)),
          ze !== null &&
            (s &&
              ze.alternate !== null &&
              Ce.delete(ze.key === null ? Me : ze.key),
            (L = w(ze, L, Me)),
            Se === null ? (ve = ze) : (Se.sibling = ze),
            (Se = ze));
      return (
        s &&
          Ce.forEach(function (dO) {
            return a(_, dO);
          }),
        Ge && ci(_, Me),
        ve
      );
    }
    function ot(_, L, z, te) {
      if (
        (typeof z == "object" &&
          z !== null &&
          z.type === F &&
          z.key === null &&
          (z = z.props.children),
        typeof z == "object" && z !== null)
      ) {
        switch (z.$$typeof) {
          case I:
            e: {
              for (var ve = z.key, Se = L; Se !== null; ) {
                if (Se.key === ve) {
                  if (((ve = z.type), ve === F)) {
                    if (Se.tag === 7) {
                      d(_, Se.sibling),
                        (L = g(Se, z.props.children)),
                        (L.return = _),
                        (_ = L);
                      break e;
                    }
                  } else if (
                    Se.elementType === ve ||
                    (typeof ve == "object" &&
                      ve !== null &&
                      ve.$$typeof === oe &&
                      Bv(ve) === Se.type)
                  ) {
                    d(_, Se.sibling),
                      (L = g(Se, z.props)),
                      (L.ref = Nl(_, Se, z)),
                      (L.return = _),
                      (_ = L);
                    break e;
                  }
                  d(_, Se);
                  break;
                } else a(_, Se);
                Se = Se.sibling;
              }
              z.type === F
                ? ((L = vi(z.props.children, _.mode, te, z.key)),
                  (L.return = _),
                  (_ = L))
                : ((te = Yu(z.type, z.key, z.props, null, _.mode, te)),
                  (te.ref = Nl(_, L, z)),
                  (te.return = _),
                  (_ = te));
            }
            return k(_);
          case R:
            e: {
              for (Se = z.key; L !== null; ) {
                if (L.key === Se)
                  if (
                    L.tag === 4 &&
                    L.stateNode.containerInfo === z.containerInfo &&
                    L.stateNode.implementation === z.implementation
                  ) {
                    d(_, L.sibling),
                      (L = g(L, z.children || [])),
                      (L.return = _),
                      (_ = L);
                    break e;
                  } else {
                    d(_, L);
                    break;
                  }
                else a(_, L);
                L = L.sibling;
              }
              (L = Yp(z, _.mode, te)), (L.return = _), (_ = L);
            }
            return k(_);
          case oe:
            return (Se = z._init), ot(_, L, Se(z._payload), te);
        }
        if ($t(z)) return pe(_, L, z, te);
        if (V(z)) return ye(_, L, z, te);
        Ou(_, z);
      }
      return (typeof z == "string" && z !== "") || typeof z == "number"
        ? ((z = "" + z),
          L !== null && L.tag === 6
            ? (d(_, L.sibling), (L = g(L, z)), (L.return = _), (_ = L))
            : (d(_, L), (L = Qp(z, _.mode, te)), (L.return = _), (_ = L)),
          k(_))
        : d(_, L);
    }
    return ot;
  }
  var ds = Hv(!0),
    Vv = Hv(!1),
    Tu = io(null),
    Nu = null,
    fs = null,
    sp = null;
  function lp() {
    sp = fs = Nu = null;
  }
  function ap(s) {
    var a = Tu.current;
    Ue(Tu), (s._currentValue = a);
  }
  function up(s, a, d) {
    for (; s !== null; ) {
      var h = s.alternate;
      if (
        ((s.childLanes & a) !== a
          ? ((s.childLanes |= a), h !== null && (h.childLanes |= a))
          : h !== null && (h.childLanes & a) !== a && (h.childLanes |= a),
        s === d)
      )
        break;
      s = s.return;
    }
  }
  function ps(s, a) {
    (Nu = s),
      (sp = fs = null),
      (s = s.dependencies),
      s !== null &&
        s.firstContext !== null &&
        (s.lanes & a && (Jt = !0), (s.firstContext = null));
  }
  function xn(s) {
    var a = s._currentValue;
    if (sp !== s)
      if (((s = { context: s, memoizedValue: a, next: null }), fs === null)) {
        if (Nu === null) throw Error(n(308));
        (fs = s), (Nu.dependencies = { lanes: 0, firstContext: s });
      } else fs = fs.next = s;
    return a;
  }
  var di = null;
  function cp(s) {
    di === null ? (di = [s]) : di.push(s);
  }
  function Wv(s, a, d, h) {
    var g = a.interleaved;
    return (
      g === null ? ((d.next = d), cp(a)) : ((d.next = g.next), (g.next = d)),
      (a.interleaved = d),
      Pr(s, h)
    );
  }
  function Pr(s, a) {
    s.lanes |= a;
    var d = s.alternate;
    for (d !== null && (d.lanes |= a), d = s, s = s.return; s !== null; )
      (s.childLanes |= a),
        (d = s.alternate),
        d !== null && (d.childLanes |= a),
        (d = s),
        (s = s.return);
    return d.tag === 3 ? d.stateNode : null;
  }
  var ao = !1;
  function dp(s) {
    s.updateQueue = {
      baseState: s.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, interleaved: null, lanes: 0 },
      effects: null,
    };
  }
  function Uv(s, a) {
    (s = s.updateQueue),
      a.updateQueue === s &&
        (a.updateQueue = {
          baseState: s.baseState,
          firstBaseUpdate: s.firstBaseUpdate,
          lastBaseUpdate: s.lastBaseUpdate,
          shared: s.shared,
          effects: s.effects,
        });
  }
  function Dr(s, a) {
    return {
      eventTime: s,
      lane: a,
      tag: 0,
      payload: null,
      callback: null,
      next: null,
    };
  }
  function uo(s, a, d) {
    var h = s.updateQueue;
    if (h === null) return null;
    if (((h = h.shared), Fe & 2)) {
      var g = h.pending;
      return (
        g === null ? (a.next = a) : ((a.next = g.next), (g.next = a)),
        (h.pending = a),
        Pr(s, d)
      );
    }
    return (
      (g = h.interleaved),
      g === null ? ((a.next = a), cp(h)) : ((a.next = g.next), (g.next = a)),
      (h.interleaved = a),
      Pr(s, d)
    );
  }
  function Au(s, a, d) {
    if (
      ((a = a.updateQueue), a !== null && ((a = a.shared), (d & 4194240) !== 0))
    ) {
      var h = a.lanes;
      (h &= s.pendingLanes), (d |= h), (a.lanes = d), Ef(s, d);
    }
  }
  function Kv(s, a) {
    var d = s.updateQueue,
      h = s.alternate;
    if (h !== null && ((h = h.updateQueue), d === h)) {
      var g = null,
        w = null;
      if (((d = d.firstBaseUpdate), d !== null)) {
        do {
          var k = {
            eventTime: d.eventTime,
            lane: d.lane,
            tag: d.tag,
            payload: d.payload,
            callback: d.callback,
            next: null,
          };
          w === null ? (g = w = k) : (w = w.next = k), (d = d.next);
        } while (d !== null);
        w === null ? (g = w = a) : (w = w.next = a);
      } else g = w = a;
      (d = {
        baseState: h.baseState,
        firstBaseUpdate: g,
        lastBaseUpdate: w,
        shared: h.shared,
        effects: h.effects,
      }),
        (s.updateQueue = d);
      return;
    }
    (s = d.lastBaseUpdate),
      s === null ? (d.firstBaseUpdate = a) : (s.next = a),
      (d.lastBaseUpdate = a);
  }
  function Ru(s, a, d, h) {
    var g = s.updateQueue;
    ao = !1;
    var w = g.firstBaseUpdate,
      k = g.lastBaseUpdate,
      T = g.shared.pending;
    if (T !== null) {
      g.shared.pending = null;
      var P = T,
        j = P.next;
      (P.next = null), k === null ? (w = j) : (k.next = j), (k = P);
      var G = s.alternate;
      G !== null &&
        ((G = G.updateQueue),
        (T = G.lastBaseUpdate),
        T !== k &&
          (T === null ? (G.firstBaseUpdate = j) : (T.next = j),
          (G.lastBaseUpdate = P)));
    }
    if (w !== null) {
      var Y = g.baseState;
      (k = 0), (G = j = P = null), (T = w);
      do {
        var q = T.lane,
          ue = T.eventTime;
        if ((h & q) === q) {
          G !== null &&
            (G = G.next =
              {
                eventTime: ue,
                lane: 0,
                tag: T.tag,
                payload: T.payload,
                callback: T.callback,
                next: null,
              });
          e: {
            var pe = s,
              ye = T;
            switch (((q = a), (ue = d), ye.tag)) {
              case 1:
                if (((pe = ye.payload), typeof pe == "function")) {
                  Y = pe.call(ue, Y, q);
                  break e;
                }
                Y = pe;
                break e;
              case 3:
                pe.flags = (pe.flags & -65537) | 128;
              case 0:
                if (
                  ((pe = ye.payload),
                  (q = typeof pe == "function" ? pe.call(ue, Y, q) : pe),
                  q == null)
                )
                  break e;
                Y = K({}, Y, q);
                break e;
              case 2:
                ao = !0;
            }
          }
          T.callback !== null &&
            T.lane !== 0 &&
            ((s.flags |= 64),
            (q = g.effects),
            q === null ? (g.effects = [T]) : q.push(T));
        } else
          (ue = {
            eventTime: ue,
            lane: q,
            tag: T.tag,
            payload: T.payload,
            callback: T.callback,
            next: null,
          }),
            G === null ? ((j = G = ue), (P = Y)) : (G = G.next = ue),
            (k |= q);
        if (((T = T.next), T === null)) {
          if (((T = g.shared.pending), T === null)) break;
          (q = T),
            (T = q.next),
            (q.next = null),
            (g.lastBaseUpdate = q),
            (g.shared.pending = null);
        }
      } while (!0);
      if (
        (G === null && (P = Y),
        (g.baseState = P),
        (g.firstBaseUpdate = j),
        (g.lastBaseUpdate = G),
        (a = g.shared.interleaved),
        a !== null)
      ) {
        g = a;
        do (k |= g.lane), (g = g.next);
        while (g !== a);
      } else w === null && (g.shared.lanes = 0);
      (hi |= k), (s.lanes = k), (s.memoizedState = Y);
    }
  }
  function qv(s, a, d) {
    if (((s = a.effects), (a.effects = null), s !== null))
      for (a = 0; a < s.length; a++) {
        var h = s[a],
          g = h.callback;
        if (g !== null) {
          if (((h.callback = null), (h = d), typeof g != "function"))
            throw Error(n(191, g));
          g.call(h);
        }
      }
  }
  var Al = {},
    lr = io(Al),
    Rl = io(Al),
    Pl = io(Al);
  function fi(s) {
    if (s === Al) throw Error(n(174));
    return s;
  }
  function fp(s, a) {
    switch ((Ve(Pl, a), Ve(Rl, s), Ve(lr, Al), (s = a.nodeType), s)) {
      case 9:
      case 11:
        a = (a = a.documentElement) ? a.namespaceURI : Yr(null, "");
        break;
      default:
        (s = s === 8 ? a.parentNode : a),
          (a = s.namespaceURI || null),
          (s = s.tagName),
          (a = Yr(a, s));
    }
    Ue(lr), Ve(lr, a);
  }
  function hs() {
    Ue(lr), Ue(Rl), Ue(Pl);
  }
  function Gv(s) {
    fi(Pl.current);
    var a = fi(lr.current),
      d = Yr(a, s.type);
    a !== d && (Ve(Rl, s), Ve(lr, d));
  }
  function pp(s) {
    Rl.current === s && (Ue(lr), Ue(Rl));
  }
  var Je = io(0);
  function Pu(s) {
    for (var a = s; a !== null; ) {
      if (a.tag === 13) {
        var d = a.memoizedState;
        if (
          d !== null &&
          ((d = d.dehydrated), d === null || d.data === "$?" || d.data === "$!")
        )
          return a;
      } else if (a.tag === 19 && a.memoizedProps.revealOrder !== void 0) {
        if (a.flags & 128) return a;
      } else if (a.child !== null) {
        (a.child.return = a), (a = a.child);
        continue;
      }
      if (a === s) break;
      for (; a.sibling === null; ) {
        if (a.return === null || a.return === s) return null;
        a = a.return;
      }
      (a.sibling.return = a.return), (a = a.sibling);
    }
    return null;
  }
  var hp = [];
  function mp() {
    for (var s = 0; s < hp.length; s++)
      hp[s]._workInProgressVersionPrimary = null;
    hp.length = 0;
  }
  var Du = M.ReactCurrentDispatcher,
    gp = M.ReactCurrentBatchConfig,
    pi = 0,
    Qe = null,
    at = null,
    ht = null,
    Iu = !1,
    Dl = !1,
    Il = 0,
    I2 = 0;
  function Nt() {
    throw Error(n(321));
  }
  function yp(s, a) {
    if (a === null) return !1;
    for (var d = 0; d < a.length && d < s.length; d++)
      if (!zn(s[d], a[d])) return !1;
    return !0;
  }
  function vp(s, a, d, h, g, w) {
    if (
      ((pi = w),
      (Qe = a),
      (a.memoizedState = null),
      (a.updateQueue = null),
      (a.lanes = 0),
      (Du.current = s === null || s.memoizedState === null ? F2 : z2),
      (s = d(h, g)),
      Dl)
    ) {
      w = 0;
      do {
        if (((Dl = !1), (Il = 0), 25 <= w)) throw Error(n(301));
        (w += 1),
          (ht = at = null),
          (a.updateQueue = null),
          (Du.current = j2),
          (s = d(h, g));
      } while (Dl);
    }
    if (
      ((Du.current = _u),
      (a = at !== null && at.next !== null),
      (pi = 0),
      (ht = at = Qe = null),
      (Iu = !1),
      a)
    )
      throw Error(n(300));
    return s;
  }
  function wp() {
    var s = Il !== 0;
    return (Il = 0), s;
  }
  function ar() {
    var s = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null,
    };
    return ht === null ? (Qe.memoizedState = ht = s) : (ht = ht.next = s), ht;
  }
  function bn() {
    if (at === null) {
      var s = Qe.alternate;
      s = s !== null ? s.memoizedState : null;
    } else s = at.next;
    var a = ht === null ? Qe.memoizedState : ht.next;
    if (a !== null) (ht = a), (at = s);
    else {
      if (s === null) throw Error(n(310));
      (at = s),
        (s = {
          memoizedState: at.memoizedState,
          baseState: at.baseState,
          baseQueue: at.baseQueue,
          queue: at.queue,
          next: null,
        }),
        ht === null ? (Qe.memoizedState = ht = s) : (ht = ht.next = s);
    }
    return ht;
  }
  function Ll(s, a) {
    return typeof a == "function" ? a(s) : a;
  }
  function xp(s) {
    var a = bn(),
      d = a.queue;
    if (d === null) throw Error(n(311));
    d.lastRenderedReducer = s;
    var h = at,
      g = h.baseQueue,
      w = d.pending;
    if (w !== null) {
      if (g !== null) {
        var k = g.next;
        (g.next = w.next), (w.next = k);
      }
      (h.baseQueue = g = w), (d.pending = null);
    }
    if (g !== null) {
      (w = g.next), (h = h.baseState);
      var T = (k = null),
        P = null,
        j = w;
      do {
        var G = j.lane;
        if ((pi & G) === G)
          P !== null &&
            (P = P.next =
              {
                lane: 0,
                action: j.action,
                hasEagerState: j.hasEagerState,
                eagerState: j.eagerState,
                next: null,
              }),
            (h = j.hasEagerState ? j.eagerState : s(h, j.action));
        else {
          var Y = {
            lane: G,
            action: j.action,
            hasEagerState: j.hasEagerState,
            eagerState: j.eagerState,
            next: null,
          };
          P === null ? ((T = P = Y), (k = h)) : (P = P.next = Y),
            (Qe.lanes |= G),
            (hi |= G);
        }
        j = j.next;
      } while (j !== null && j !== w);
      P === null ? (k = h) : (P.next = T),
        zn(h, a.memoizedState) || (Jt = !0),
        (a.memoizedState = h),
        (a.baseState = k),
        (a.baseQueue = P),
        (d.lastRenderedState = h);
    }
    if (((s = d.interleaved), s !== null)) {
      g = s;
      do (w = g.lane), (Qe.lanes |= w), (hi |= w), (g = g.next);
      while (g !== s);
    } else g === null && (d.lanes = 0);
    return [a.memoizedState, d.dispatch];
  }
  function bp(s) {
    var a = bn(),
      d = a.queue;
    if (d === null) throw Error(n(311));
    d.lastRenderedReducer = s;
    var h = d.dispatch,
      g = d.pending,
      w = a.memoizedState;
    if (g !== null) {
      d.pending = null;
      var k = (g = g.next);
      do (w = s(w, k.action)), (k = k.next);
      while (k !== g);
      zn(w, a.memoizedState) || (Jt = !0),
        (a.memoizedState = w),
        a.baseQueue === null && (a.baseState = w),
        (d.lastRenderedState = w);
    }
    return [w, h];
  }
  function Jv() {}
  function Qv(s, a) {
    var d = Qe,
      h = bn(),
      g = a(),
      w = !zn(h.memoizedState, g);
    if (
      (w && ((h.memoizedState = g), (Jt = !0)),
      (h = h.queue),
      Sp(Zv.bind(null, d, h, s), [s]),
      h.getSnapshot !== a || w || (ht !== null && ht.memoizedState.tag & 1))
    ) {
      if (
        ((d.flags |= 2048),
        $l(9, Xv.bind(null, d, h, g, a), void 0, null),
        mt === null)
      )
        throw Error(n(349));
      pi & 30 || Yv(d, a, g);
    }
    return g;
  }
  function Yv(s, a, d) {
    (s.flags |= 16384),
      (s = { getSnapshot: a, value: d }),
      (a = Qe.updateQueue),
      a === null
        ? ((a = { lastEffect: null, stores: null }),
          (Qe.updateQueue = a),
          (a.stores = [s]))
        : ((d = a.stores), d === null ? (a.stores = [s]) : d.push(s));
  }
  function Xv(s, a, d, h) {
    (a.value = d), (a.getSnapshot = h), e0(a) && t0(s);
  }
  function Zv(s, a, d) {
    return d(function () {
      e0(a) && t0(s);
    });
  }
  function e0(s) {
    var a = s.getSnapshot;
    s = s.value;
    try {
      var d = a();
      return !zn(s, d);
    } catch {
      return !0;
    }
  }
  function t0(s) {
    var a = Pr(s, 1);
    a !== null && Wn(a, s, 1, -1);
  }
  function n0(s) {
    var a = ar();
    return (
      typeof s == "function" && (s = s()),
      (a.memoizedState = a.baseState = s),
      (s = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Ll,
        lastRenderedState: s,
      }),
      (a.queue = s),
      (s = s.dispatch = _2.bind(null, Qe, s)),
      [a.memoizedState, s]
    );
  }
  function $l(s, a, d, h) {
    return (
      (s = { tag: s, create: a, destroy: d, deps: h, next: null }),
      (a = Qe.updateQueue),
      a === null
        ? ((a = { lastEffect: null, stores: null }),
          (Qe.updateQueue = a),
          (a.lastEffect = s.next = s))
        : ((d = a.lastEffect),
          d === null
            ? (a.lastEffect = s.next = s)
            : ((h = d.next), (d.next = s), (s.next = h), (a.lastEffect = s))),
      s
    );
  }
  function r0() {
    return bn().memoizedState;
  }
  function Lu(s, a, d, h) {
    var g = ar();
    (Qe.flags |= s),
      (g.memoizedState = $l(1 | a, d, void 0, h === void 0 ? null : h));
  }
  function $u(s, a, d, h) {
    var g = bn();
    h = h === void 0 ? null : h;
    var w = void 0;
    if (at !== null) {
      var k = at.memoizedState;
      if (((w = k.destroy), h !== null && yp(h, k.deps))) {
        g.memoizedState = $l(a, d, w, h);
        return;
      }
    }
    (Qe.flags |= s), (g.memoizedState = $l(1 | a, d, w, h));
  }
  function o0(s, a) {
    return Lu(8390656, 8, s, a);
  }
  function Sp(s, a) {
    return $u(2048, 8, s, a);
  }
  function i0(s, a) {
    return $u(4, 2, s, a);
  }
  function s0(s, a) {
    return $u(4, 4, s, a);
  }
  function l0(s, a) {
    if (typeof a == "function")
      return (
        (s = s()),
        a(s),
        function () {
          a(null);
        }
      );
    if (a != null)
      return (
        (s = s()),
        (a.current = s),
        function () {
          a.current = null;
        }
      );
  }
  function a0(s, a, d) {
    return (
      (d = d != null ? d.concat([s]) : null), $u(4, 4, l0.bind(null, a, s), d)
    );
  }
  function Cp() {}
  function u0(s, a) {
    var d = bn();
    a = a === void 0 ? null : a;
    var h = d.memoizedState;
    return h !== null && a !== null && yp(a, h[1])
      ? h[0]
      : ((d.memoizedState = [s, a]), s);
  }
  function c0(s, a) {
    var d = bn();
    a = a === void 0 ? null : a;
    var h = d.memoizedState;
    return h !== null && a !== null && yp(a, h[1])
      ? h[0]
      : ((s = s()), (d.memoizedState = [s, a]), s);
  }
  function d0(s, a, d) {
    return pi & 21
      ? (zn(d, a) ||
          ((d = By()), (Qe.lanes |= d), (hi |= d), (s.baseState = !0)),
        a)
      : (s.baseState && ((s.baseState = !1), (Jt = !0)), (s.memoizedState = d));
  }
  function L2(s, a) {
    var d = je;
    (je = d !== 0 && 4 > d ? d : 4), s(!0);
    var h = gp.transition;
    gp.transition = {};
    try {
      s(!1), a();
    } finally {
      (je = d), (gp.transition = h);
    }
  }
  function f0() {
    return bn().memoizedState;
  }
  function $2(s, a, d) {
    var h = ho(s);
    if (
      ((d = {
        lane: h,
        action: d,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      }),
      p0(s))
    )
      h0(a, d);
    else if (((d = Wv(s, a, d, h)), d !== null)) {
      var g = zt();
      Wn(d, s, h, g), m0(d, a, h);
    }
  }
  function _2(s, a, d) {
    var h = ho(s),
      g = {
        lane: h,
        action: d,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      };
    if (p0(s)) h0(a, g);
    else {
      var w = s.alternate;
      if (
        s.lanes === 0 &&
        (w === null || w.lanes === 0) &&
        ((w = a.lastRenderedReducer), w !== null)
      )
        try {
          var k = a.lastRenderedState,
            T = w(k, d);
          if (((g.hasEagerState = !0), (g.eagerState = T), zn(T, k))) {
            var P = a.interleaved;
            P === null
              ? ((g.next = g), cp(a))
              : ((g.next = P.next), (P.next = g)),
              (a.interleaved = g);
            return;
          }
        } catch {
        } finally {
        }
      (d = Wv(s, a, g, h)),
        d !== null && ((g = zt()), Wn(d, s, h, g), m0(d, a, h));
    }
  }
  function p0(s) {
    var a = s.alternate;
    return s === Qe || (a !== null && a === Qe);
  }
  function h0(s, a) {
    Dl = Iu = !0;
    var d = s.pending;
    d === null ? (a.next = a) : ((a.next = d.next), (d.next = a)),
      (s.pending = a);
  }
  function m0(s, a, d) {
    if (d & 4194240) {
      var h = a.lanes;
      (h &= s.pendingLanes), (d |= h), (a.lanes = d), Ef(s, d);
    }
  }
  var _u = {
      readContext: xn,
      useCallback: Nt,
      useContext: Nt,
      useEffect: Nt,
      useImperativeHandle: Nt,
      useInsertionEffect: Nt,
      useLayoutEffect: Nt,
      useMemo: Nt,
      useReducer: Nt,
      useRef: Nt,
      useState: Nt,
      useDebugValue: Nt,
      useDeferredValue: Nt,
      useTransition: Nt,
      useMutableSource: Nt,
      useSyncExternalStore: Nt,
      useId: Nt,
      unstable_isNewReconciler: !1,
    },
    F2 = {
      readContext: xn,
      useCallback: function (s, a) {
        return (ar().memoizedState = [s, a === void 0 ? null : a]), s;
      },
      useContext: xn,
      useEffect: o0,
      useImperativeHandle: function (s, a, d) {
        return (
          (d = d != null ? d.concat([s]) : null),
          Lu(4194308, 4, l0.bind(null, a, s), d)
        );
      },
      useLayoutEffect: function (s, a) {
        return Lu(4194308, 4, s, a);
      },
      useInsertionEffect: function (s, a) {
        return Lu(4, 2, s, a);
      },
      useMemo: function (s, a) {
        var d = ar();
        return (
          (a = a === void 0 ? null : a),
          (s = s()),
          (d.memoizedState = [s, a]),
          s
        );
      },
      useReducer: function (s, a, d) {
        var h = ar();
        return (
          (a = d !== void 0 ? d(a) : a),
          (h.memoizedState = h.baseState = a),
          (s = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: s,
            lastRenderedState: a,
          }),
          (h.queue = s),
          (s = s.dispatch = $2.bind(null, Qe, s)),
          [h.memoizedState, s]
        );
      },
      useRef: function (s) {
        var a = ar();
        return (s = { current: s }), (a.memoizedState = s);
      },
      useState: n0,
      useDebugValue: Cp,
      useDeferredValue: function (s) {
        return (ar().memoizedState = s);
      },
      useTransition: function () {
        var s = n0(!1),
          a = s[0];
        return (s = L2.bind(null, s[1])), (ar().memoizedState = s), [a, s];
      },
      useMutableSource: function () {},
      useSyncExternalStore: function (s, a, d) {
        var h = Qe,
          g = ar();
        if (Ge) {
          if (d === void 0) throw Error(n(407));
          d = d();
        } else {
          if (((d = a()), mt === null)) throw Error(n(349));
          pi & 30 || Yv(h, a, d);
        }
        g.memoizedState = d;
        var w = { value: d, getSnapshot: a };
        return (
          (g.queue = w),
          o0(Zv.bind(null, h, w, s), [s]),
          (h.flags |= 2048),
          $l(9, Xv.bind(null, h, w, d, a), void 0, null),
          d
        );
      },
      useId: function () {
        var s = ar(),
          a = mt.identifierPrefix;
        if (Ge) {
          var d = Rr,
            h = Ar;
          (d = (h & ~(1 << (32 - Fn(h) - 1))).toString(32) + d),
            (a = ":" + a + "R" + d),
            (d = Il++),
            0 < d && (a += "H" + d.toString(32)),
            (a += ":");
        } else (d = I2++), (a = ":" + a + "r" + d.toString(32) + ":");
        return (s.memoizedState = a);
      },
      unstable_isNewReconciler: !1,
    },
    z2 = {
      readContext: xn,
      useCallback: u0,
      useContext: xn,
      useEffect: Sp,
      useImperativeHandle: a0,
      useInsertionEffect: i0,
      useLayoutEffect: s0,
      useMemo: c0,
      useReducer: xp,
      useRef: r0,
      useState: function () {
        return xp(Ll);
      },
      useDebugValue: Cp,
      useDeferredValue: function (s) {
        var a = bn();
        return d0(a, at.memoizedState, s);
      },
      useTransition: function () {
        var s = xp(Ll)[0],
          a = bn().memoizedState;
        return [s, a];
      },
      useMutableSource: Jv,
      useSyncExternalStore: Qv,
      useId: f0,
      unstable_isNewReconciler: !1,
    },
    j2 = {
      readContext: xn,
      useCallback: u0,
      useContext: xn,
      useEffect: Sp,
      useImperativeHandle: a0,
      useInsertionEffect: i0,
      useLayoutEffect: s0,
      useMemo: c0,
      useReducer: bp,
      useRef: r0,
      useState: function () {
        return bp(Ll);
      },
      useDebugValue: Cp,
      useDeferredValue: function (s) {
        var a = bn();
        return at === null ? (a.memoizedState = s) : d0(a, at.memoizedState, s);
      },
      useTransition: function () {
        var s = bp(Ll)[0],
          a = bn().memoizedState;
        return [s, a];
      },
      useMutableSource: Jv,
      useSyncExternalStore: Qv,
      useId: f0,
      unstable_isNewReconciler: !1,
    };
  function Bn(s, a) {
    if (s && s.defaultProps) {
      (a = K({}, a)), (s = s.defaultProps);
      for (var d in s) a[d] === void 0 && (a[d] = s[d]);
      return a;
    }
    return a;
  }
  function kp(s, a, d, h) {
    (a = s.memoizedState),
      (d = d(h, a)),
      (d = d == null ? a : K({}, a, d)),
      (s.memoizedState = d),
      s.lanes === 0 && (s.updateQueue.baseState = d);
  }
  var Fu = {
    isMounted: function (s) {
      return (s = s._reactInternals) ? si(s) === s : !1;
    },
    enqueueSetState: function (s, a, d) {
      s = s._reactInternals;
      var h = zt(),
        g = ho(s),
        w = Dr(h, g);
      (w.payload = a),
        d != null && (w.callback = d),
        (a = uo(s, w, g)),
        a !== null && (Wn(a, s, g, h), Au(a, s, g));
    },
    enqueueReplaceState: function (s, a, d) {
      s = s._reactInternals;
      var h = zt(),
        g = ho(s),
        w = Dr(h, g);
      (w.tag = 1),
        (w.payload = a),
        d != null && (w.callback = d),
        (a = uo(s, w, g)),
        a !== null && (Wn(a, s, g, h), Au(a, s, g));
    },
    enqueueForceUpdate: function (s, a) {
      s = s._reactInternals;
      var d = zt(),
        h = ho(s),
        g = Dr(d, h);
      (g.tag = 2),
        a != null && (g.callback = a),
        (a = uo(s, g, h)),
        a !== null && (Wn(a, s, h, d), Au(a, s, h));
    },
  };
  function g0(s, a, d, h, g, w, k) {
    return (
      (s = s.stateNode),
      typeof s.shouldComponentUpdate == "function"
        ? s.shouldComponentUpdate(h, w, k)
        : a.prototype && a.prototype.isPureReactComponent
        ? !Sl(d, h) || !Sl(g, w)
        : !0
    );
  }
  function y0(s, a, d) {
    var h = !1,
      g = so,
      w = a.contextType;
    return (
      typeof w == "object" && w !== null
        ? (w = xn(w))
        : ((g = Gt(a) ? ai : Tt.current),
          (h = a.contextTypes),
          (w = (h = h != null) ? ls(s, g) : so)),
      (a = new a(d, w)),
      (s.memoizedState =
        a.state !== null && a.state !== void 0 ? a.state : null),
      (a.updater = Fu),
      (s.stateNode = a),
      (a._reactInternals = s),
      h &&
        ((s = s.stateNode),
        (s.__reactInternalMemoizedUnmaskedChildContext = g),
        (s.__reactInternalMemoizedMaskedChildContext = w)),
      a
    );
  }
  function v0(s, a, d, h) {
    (s = a.state),
      typeof a.componentWillReceiveProps == "function" &&
        a.componentWillReceiveProps(d, h),
      typeof a.UNSAFE_componentWillReceiveProps == "function" &&
        a.UNSAFE_componentWillReceiveProps(d, h),
      a.state !== s && Fu.enqueueReplaceState(a, a.state, null);
  }
  function Ep(s, a, d, h) {
    var g = s.stateNode;
    (g.props = d), (g.state = s.memoizedState), (g.refs = {}), dp(s);
    var w = a.contextType;
    typeof w == "object" && w !== null
      ? (g.context = xn(w))
      : ((w = Gt(a) ? ai : Tt.current), (g.context = ls(s, w))),
      (g.state = s.memoizedState),
      (w = a.getDerivedStateFromProps),
      typeof w == "function" && (kp(s, a, w, d), (g.state = s.memoizedState)),
      typeof a.getDerivedStateFromProps == "function" ||
        typeof g.getSnapshotBeforeUpdate == "function" ||
        (typeof g.UNSAFE_componentWillMount != "function" &&
          typeof g.componentWillMount != "function") ||
        ((a = g.state),
        typeof g.componentWillMount == "function" && g.componentWillMount(),
        typeof g.UNSAFE_componentWillMount == "function" &&
          g.UNSAFE_componentWillMount(),
        a !== g.state && Fu.enqueueReplaceState(g, g.state, null),
        Ru(s, d, g, h),
        (g.state = s.memoizedState)),
      typeof g.componentDidMount == "function" && (s.flags |= 4194308);
  }
  function ms(s, a) {
    try {
      var d = "",
        h = a;
      do (d += Q(h)), (h = h.return);
      while (h);
      var g = d;
    } catch (w) {
      g =
        `
Error generating stack: ` +
        w.message +
        `
` +
        w.stack;
    }
    return { value: s, source: a, stack: g, digest: null };
  }
  function Mp(s, a, d) {
    return { value: s, source: null, stack: d ?? null, digest: a ?? null };
  }
  function Op(s, a) {
    try {
      console.error(a.value);
    } catch (d) {
      setTimeout(function () {
        throw d;
      });
    }
  }
  var B2 = typeof WeakMap == "function" ? WeakMap : Map;
  function w0(s, a, d) {
    (d = Dr(-1, d)), (d.tag = 3), (d.payload = { element: null });
    var h = a.value;
    return (
      (d.callback = function () {
        Uu || ((Uu = !0), (Hp = h)), Op(s, a);
      }),
      d
    );
  }
  function x0(s, a, d) {
    (d = Dr(-1, d)), (d.tag = 3);
    var h = s.type.getDerivedStateFromError;
    if (typeof h == "function") {
      var g = a.value;
      (d.payload = function () {
        return h(g);
      }),
        (d.callback = function () {
          Op(s, a);
        });
    }
    var w = s.stateNode;
    return (
      w !== null &&
        typeof w.componentDidCatch == "function" &&
        (d.callback = function () {
          Op(s, a),
            typeof h != "function" &&
              (fo === null ? (fo = new Set([this])) : fo.add(this));
          var k = a.stack;
          this.componentDidCatch(a.value, {
            componentStack: k !== null ? k : "",
          });
        }),
      d
    );
  }
  function b0(s, a, d) {
    var h = s.pingCache;
    if (h === null) {
      h = s.pingCache = new B2();
      var g = new Set();
      h.set(a, g);
    } else (g = h.get(a)), g === void 0 && ((g = new Set()), h.set(a, g));
    g.has(d) || (g.add(d), (s = tO.bind(null, s, a, d)), a.then(s, s));
  }
  function S0(s) {
    do {
      var a;
      if (
        ((a = s.tag === 13) &&
          ((a = s.memoizedState),
          (a = a !== null ? a.dehydrated !== null : !0)),
        a)
      )
        return s;
      s = s.return;
    } while (s !== null);
    return null;
  }
  function C0(s, a, d, h, g) {
    return s.mode & 1
      ? ((s.flags |= 65536), (s.lanes = g), s)
      : (s === a
          ? (s.flags |= 65536)
          : ((s.flags |= 128),
            (d.flags |= 131072),
            (d.flags &= -52805),
            d.tag === 1 &&
              (d.alternate === null
                ? (d.tag = 17)
                : ((a = Dr(-1, 1)), (a.tag = 2), uo(d, a, 1))),
            (d.lanes |= 1)),
        s);
  }
  var H2 = M.ReactCurrentOwner,
    Jt = !1;
  function Ft(s, a, d, h) {
    a.child = s === null ? Vv(a, null, d, h) : ds(a, s.child, d, h);
  }
  function k0(s, a, d, h, g) {
    d = d.render;
    var w = a.ref;
    return (
      ps(a, g),
      (h = vp(s, a, d, h, w, g)),
      (d = wp()),
      s !== null && !Jt
        ? ((a.updateQueue = s.updateQueue),
          (a.flags &= -2053),
          (s.lanes &= ~g),
          Ir(s, a, g))
        : (Ge && d && tp(a), (a.flags |= 1), Ft(s, a, h, g), a.child)
    );
  }
  function E0(s, a, d, h, g) {
    if (s === null) {
      var w = d.type;
      return typeof w == "function" &&
        !Jp(w) &&
        w.defaultProps === void 0 &&
        d.compare === null &&
        d.defaultProps === void 0
        ? ((a.tag = 15), (a.type = w), M0(s, a, w, h, g))
        : ((s = Yu(d.type, null, h, a, a.mode, g)),
          (s.ref = a.ref),
          (s.return = a),
          (a.child = s));
    }
    if (((w = s.child), !(s.lanes & g))) {
      var k = w.memoizedProps;
      if (
        ((d = d.compare), (d = d !== null ? d : Sl), d(k, h) && s.ref === a.ref)
      )
        return Ir(s, a, g);
    }
    return (
      (a.flags |= 1),
      (s = go(w, h)),
      (s.ref = a.ref),
      (s.return = a),
      (a.child = s)
    );
  }
  function M0(s, a, d, h, g) {
    if (s !== null) {
      var w = s.memoizedProps;
      if (Sl(w, h) && s.ref === a.ref)
        if (((Jt = !1), (a.pendingProps = h = w), (s.lanes & g) !== 0))
          s.flags & 131072 && (Jt = !0);
        else return (a.lanes = s.lanes), Ir(s, a, g);
    }
    return Tp(s, a, d, h, g);
  }
  function O0(s, a, d) {
    var h = a.pendingProps,
      g = h.children,
      w = s !== null ? s.memoizedState : null;
    if (h.mode === "hidden")
      if (!(a.mode & 1))
        (a.memoizedState = {
          baseLanes: 0,
          cachePool: null,
          transitions: null,
        }),
          Ve(ys, dn),
          (dn |= d);
      else {
        if (!(d & 1073741824))
          return (
            (s = w !== null ? w.baseLanes | d : d),
            (a.lanes = a.childLanes = 1073741824),
            (a.memoizedState = {
              baseLanes: s,
              cachePool: null,
              transitions: null,
            }),
            (a.updateQueue = null),
            Ve(ys, dn),
            (dn |= s),
            null
          );
        (a.memoizedState = {
          baseLanes: 0,
          cachePool: null,
          transitions: null,
        }),
          (h = w !== null ? w.baseLanes : d),
          Ve(ys, dn),
          (dn |= h);
      }
    else
      w !== null ? ((h = w.baseLanes | d), (a.memoizedState = null)) : (h = d),
        Ve(ys, dn),
        (dn |= h);
    return Ft(s, a, g, d), a.child;
  }
  function T0(s, a) {
    var d = a.ref;
    ((s === null && d !== null) || (s !== null && s.ref !== d)) &&
      ((a.flags |= 512), (a.flags |= 2097152));
  }
  function Tp(s, a, d, h, g) {
    var w = Gt(d) ? ai : Tt.current;
    return (
      (w = ls(a, w)),
      ps(a, g),
      (d = vp(s, a, d, h, w, g)),
      (h = wp()),
      s !== null && !Jt
        ? ((a.updateQueue = s.updateQueue),
          (a.flags &= -2053),
          (s.lanes &= ~g),
          Ir(s, a, g))
        : (Ge && h && tp(a), (a.flags |= 1), Ft(s, a, d, g), a.child)
    );
  }
  function N0(s, a, d, h, g) {
    if (Gt(d)) {
      var w = !0;
      Su(a);
    } else w = !1;
    if ((ps(a, g), a.stateNode === null))
      ju(s, a), y0(a, d, h), Ep(a, d, h, g), (h = !0);
    else if (s === null) {
      var k = a.stateNode,
        T = a.memoizedProps;
      k.props = T;
      var P = k.context,
        j = d.contextType;
      typeof j == "object" && j !== null
        ? (j = xn(j))
        : ((j = Gt(d) ? ai : Tt.current), (j = ls(a, j)));
      var G = d.getDerivedStateFromProps,
        Y =
          typeof G == "function" ||
          typeof k.getSnapshotBeforeUpdate == "function";
      Y ||
        (typeof k.UNSAFE_componentWillReceiveProps != "function" &&
          typeof k.componentWillReceiveProps != "function") ||
        ((T !== h || P !== j) && v0(a, k, h, j)),
        (ao = !1);
      var q = a.memoizedState;
      (k.state = q),
        Ru(a, h, k, g),
        (P = a.memoizedState),
        T !== h || q !== P || qt.current || ao
          ? (typeof G == "function" && (kp(a, d, G, h), (P = a.memoizedState)),
            (T = ao || g0(a, d, T, h, q, P, j))
              ? (Y ||
                  (typeof k.UNSAFE_componentWillMount != "function" &&
                    typeof k.componentWillMount != "function") ||
                  (typeof k.componentWillMount == "function" &&
                    k.componentWillMount(),
                  typeof k.UNSAFE_componentWillMount == "function" &&
                    k.UNSAFE_componentWillMount()),
                typeof k.componentDidMount == "function" &&
                  (a.flags |= 4194308))
              : (typeof k.componentDidMount == "function" &&
                  (a.flags |= 4194308),
                (a.memoizedProps = h),
                (a.memoizedState = P)),
            (k.props = h),
            (k.state = P),
            (k.context = j),
            (h = T))
          : (typeof k.componentDidMount == "function" && (a.flags |= 4194308),
            (h = !1));
    } else {
      (k = a.stateNode),
        Uv(s, a),
        (T = a.memoizedProps),
        (j = a.type === a.elementType ? T : Bn(a.type, T)),
        (k.props = j),
        (Y = a.pendingProps),
        (q = k.context),
        (P = d.contextType),
        typeof P == "object" && P !== null
          ? (P = xn(P))
          : ((P = Gt(d) ? ai : Tt.current), (P = ls(a, P)));
      var ue = d.getDerivedStateFromProps;
      (G =
        typeof ue == "function" ||
        typeof k.getSnapshotBeforeUpdate == "function") ||
        (typeof k.UNSAFE_componentWillReceiveProps != "function" &&
          typeof k.componentWillReceiveProps != "function") ||
        ((T !== Y || q !== P) && v0(a, k, h, P)),
        (ao = !1),
        (q = a.memoizedState),
        (k.state = q),
        Ru(a, h, k, g);
      var pe = a.memoizedState;
      T !== Y || q !== pe || qt.current || ao
        ? (typeof ue == "function" && (kp(a, d, ue, h), (pe = a.memoizedState)),
          (j = ao || g0(a, d, j, h, q, pe, P) || !1)
            ? (G ||
                (typeof k.UNSAFE_componentWillUpdate != "function" &&
                  typeof k.componentWillUpdate != "function") ||
                (typeof k.componentWillUpdate == "function" &&
                  k.componentWillUpdate(h, pe, P),
                typeof k.UNSAFE_componentWillUpdate == "function" &&
                  k.UNSAFE_componentWillUpdate(h, pe, P)),
              typeof k.componentDidUpdate == "function" && (a.flags |= 4),
              typeof k.getSnapshotBeforeUpdate == "function" &&
                (a.flags |= 1024))
            : (typeof k.componentDidUpdate != "function" ||
                (T === s.memoizedProps && q === s.memoizedState) ||
                (a.flags |= 4),
              typeof k.getSnapshotBeforeUpdate != "function" ||
                (T === s.memoizedProps && q === s.memoizedState) ||
                (a.flags |= 1024),
              (a.memoizedProps = h),
              (a.memoizedState = pe)),
          (k.props = h),
          (k.state = pe),
          (k.context = P),
          (h = j))
        : (typeof k.componentDidUpdate != "function" ||
            (T === s.memoizedProps && q === s.memoizedState) ||
            (a.flags |= 4),
          typeof k.getSnapshotBeforeUpdate != "function" ||
            (T === s.memoizedProps && q === s.memoizedState) ||
            (a.flags |= 1024),
          (h = !1));
    }
    return Np(s, a, d, h, w, g);
  }
  function Np(s, a, d, h, g, w) {
    T0(s, a);
    var k = (a.flags & 128) !== 0;
    if (!h && !k) return g && Iv(a, d, !1), Ir(s, a, w);
    (h = a.stateNode), (H2.current = a);
    var T =
      k && typeof d.getDerivedStateFromError != "function" ? null : h.render();
    return (
      (a.flags |= 1),
      s !== null && k
        ? ((a.child = ds(a, s.child, null, w)), (a.child = ds(a, null, T, w)))
        : Ft(s, a, T, w),
      (a.memoizedState = h.state),
      g && Iv(a, d, !0),
      a.child
    );
  }
  function A0(s) {
    var a = s.stateNode;
    a.pendingContext
      ? Pv(s, a.pendingContext, a.pendingContext !== a.context)
      : a.context && Pv(s, a.context, !1),
      fp(s, a.containerInfo);
  }
  function R0(s, a, d, h, g) {
    return cs(), ip(g), (a.flags |= 256), Ft(s, a, d, h), a.child;
  }
  var Ap = { dehydrated: null, treeContext: null, retryLane: 0 };
  function Rp(s) {
    return { baseLanes: s, cachePool: null, transitions: null };
  }
  function P0(s, a, d) {
    var h = a.pendingProps,
      g = Je.current,
      w = !1,
      k = (a.flags & 128) !== 0,
      T;
    if (
      ((T = k) ||
        (T = s !== null && s.memoizedState === null ? !1 : (g & 2) !== 0),
      T
        ? ((w = !0), (a.flags &= -129))
        : (s === null || s.memoizedState !== null) && (g |= 1),
      Ve(Je, g & 1),
      s === null)
    )
      return (
        op(a),
        (s = a.memoizedState),
        s !== null && ((s = s.dehydrated), s !== null)
          ? (a.mode & 1
              ? s.data === "$!"
                ? (a.lanes = 8)
                : (a.lanes = 1073741824)
              : (a.lanes = 1),
            null)
          : ((k = h.children),
            (s = h.fallback),
            w
              ? ((h = a.mode),
                (w = a.child),
                (k = { mode: "hidden", children: k }),
                !(h & 1) && w !== null
                  ? ((w.childLanes = 0), (w.pendingProps = k))
                  : (w = Xu(k, h, 0, null)),
                (s = vi(s, h, d, null)),
                (w.return = a),
                (s.return = a),
                (w.sibling = s),
                (a.child = w),
                (a.child.memoizedState = Rp(d)),
                (a.memoizedState = Ap),
                s)
              : Pp(a, k))
      );
    if (((g = s.memoizedState), g !== null && ((T = g.dehydrated), T !== null)))
      return V2(s, a, k, h, T, g, d);
    if (w) {
      (w = h.fallback), (k = a.mode), (g = s.child), (T = g.sibling);
      var P = { mode: "hidden", children: h.children };
      return (
        !(k & 1) && a.child !== g
          ? ((h = a.child),
            (h.childLanes = 0),
            (h.pendingProps = P),
            (a.deletions = null))
          : ((h = go(g, P)), (h.subtreeFlags = g.subtreeFlags & 14680064)),
        T !== null ? (w = go(T, w)) : ((w = vi(w, k, d, null)), (w.flags |= 2)),
        (w.return = a),
        (h.return = a),
        (h.sibling = w),
        (a.child = h),
        (h = w),
        (w = a.child),
        (k = s.child.memoizedState),
        (k =
          k === null
            ? Rp(d)
            : {
                baseLanes: k.baseLanes | d,
                cachePool: null,
                transitions: k.transitions,
              }),
        (w.memoizedState = k),
        (w.childLanes = s.childLanes & ~d),
        (a.memoizedState = Ap),
        h
      );
    }
    return (
      (w = s.child),
      (s = w.sibling),
      (h = go(w, { mode: "visible", children: h.children })),
      !(a.mode & 1) && (h.lanes = d),
      (h.return = a),
      (h.sibling = null),
      s !== null &&
        ((d = a.deletions),
        d === null ? ((a.deletions = [s]), (a.flags |= 16)) : d.push(s)),
      (a.child = h),
      (a.memoizedState = null),
      h
    );
  }
  function Pp(s, a) {
    return (
      (a = Xu({ mode: "visible", children: a }, s.mode, 0, null)),
      (a.return = s),
      (s.child = a)
    );
  }
  function zu(s, a, d, h) {
    return (
      h !== null && ip(h),
      ds(a, s.child, null, d),
      (s = Pp(a, a.pendingProps.children)),
      (s.flags |= 2),
      (a.memoizedState = null),
      s
    );
  }
  function V2(s, a, d, h, g, w, k) {
    if (d)
      return a.flags & 256
        ? ((a.flags &= -257), (h = Mp(Error(n(422)))), zu(s, a, k, h))
        : a.memoizedState !== null
        ? ((a.child = s.child), (a.flags |= 128), null)
        : ((w = h.fallback),
          (g = a.mode),
          (h = Xu({ mode: "visible", children: h.children }, g, 0, null)),
          (w = vi(w, g, k, null)),
          (w.flags |= 2),
          (h.return = a),
          (w.return = a),
          (h.sibling = w),
          (a.child = h),
          a.mode & 1 && ds(a, s.child, null, k),
          (a.child.memoizedState = Rp(k)),
          (a.memoizedState = Ap),
          w);
    if (!(a.mode & 1)) return zu(s, a, k, null);
    if (g.data === "$!") {
      if (((h = g.nextSibling && g.nextSibling.dataset), h)) var T = h.dgst;
      return (
        (h = T), (w = Error(n(419))), (h = Mp(w, h, void 0)), zu(s, a, k, h)
      );
    }
    if (((T = (k & s.childLanes) !== 0), Jt || T)) {
      if (((h = mt), h !== null)) {
        switch (k & -k) {
          case 4:
            g = 2;
            break;
          case 16:
            g = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            g = 32;
            break;
          case 536870912:
            g = 268435456;
            break;
          default:
            g = 0;
        }
        (g = g & (h.suspendedLanes | k) ? 0 : g),
          g !== 0 &&
            g !== w.retryLane &&
            ((w.retryLane = g), Pr(s, g), Wn(h, s, g, -1));
      }
      return Gp(), (h = Mp(Error(n(421)))), zu(s, a, k, h);
    }
    return g.data === "$?"
      ? ((a.flags |= 128),
        (a.child = s.child),
        (a = nO.bind(null, s)),
        (g._reactRetry = a),
        null)
      : ((s = w.treeContext),
        (cn = oo(g.nextSibling)),
        (un = a),
        (Ge = !0),
        (jn = null),
        s !== null &&
          ((vn[wn++] = Ar),
          (vn[wn++] = Rr),
          (vn[wn++] = ui),
          (Ar = s.id),
          (Rr = s.overflow),
          (ui = a)),
        (a = Pp(a, h.children)),
        (a.flags |= 4096),
        a);
  }
  function D0(s, a, d) {
    s.lanes |= a;
    var h = s.alternate;
    h !== null && (h.lanes |= a), up(s.return, a, d);
  }
  function Dp(s, a, d, h, g) {
    var w = s.memoizedState;
    w === null
      ? (s.memoizedState = {
          isBackwards: a,
          rendering: null,
          renderingStartTime: 0,
          last: h,
          tail: d,
          tailMode: g,
        })
      : ((w.isBackwards = a),
        (w.rendering = null),
        (w.renderingStartTime = 0),
        (w.last = h),
        (w.tail = d),
        (w.tailMode = g));
  }
  function I0(s, a, d) {
    var h = a.pendingProps,
      g = h.revealOrder,
      w = h.tail;
    if ((Ft(s, a, h.children, d), (h = Je.current), h & 2))
      (h = (h & 1) | 2), (a.flags |= 128);
    else {
      if (s !== null && s.flags & 128)
        e: for (s = a.child; s !== null; ) {
          if (s.tag === 13) s.memoizedState !== null && D0(s, d, a);
          else if (s.tag === 19) D0(s, d, a);
          else if (s.child !== null) {
            (s.child.return = s), (s = s.child);
            continue;
          }
          if (s === a) break e;
          for (; s.sibling === null; ) {
            if (s.return === null || s.return === a) break e;
            s = s.return;
          }
          (s.sibling.return = s.return), (s = s.sibling);
        }
      h &= 1;
    }
    if ((Ve(Je, h), !(a.mode & 1))) a.memoizedState = null;
    else
      switch (g) {
        case "forwards":
          for (d = a.child, g = null; d !== null; )
            (s = d.alternate),
              s !== null && Pu(s) === null && (g = d),
              (d = d.sibling);
          (d = g),
            d === null
              ? ((g = a.child), (a.child = null))
              : ((g = d.sibling), (d.sibling = null)),
            Dp(a, !1, g, d, w);
          break;
        case "backwards":
          for (d = null, g = a.child, a.child = null; g !== null; ) {
            if (((s = g.alternate), s !== null && Pu(s) === null)) {
              a.child = g;
              break;
            }
            (s = g.sibling), (g.sibling = d), (d = g), (g = s);
          }
          Dp(a, !0, d, null, w);
          break;
        case "together":
          Dp(a, !1, null, null, void 0);
          break;
        default:
          a.memoizedState = null;
      }
    return a.child;
  }
  function ju(s, a) {
    !(a.mode & 1) &&
      s !== null &&
      ((s.alternate = null), (a.alternate = null), (a.flags |= 2));
  }
  function Ir(s, a, d) {
    if (
      (s !== null && (a.dependencies = s.dependencies),
      (hi |= a.lanes),
      !(d & a.childLanes))
    )
      return null;
    if (s !== null && a.child !== s.child) throw Error(n(153));
    if (a.child !== null) {
      for (
        s = a.child, d = go(s, s.pendingProps), a.child = d, d.return = a;
        s.sibling !== null;

      )
        (s = s.sibling),
          (d = d.sibling = go(s, s.pendingProps)),
          (d.return = a);
      d.sibling = null;
    }
    return a.child;
  }
  function W2(s, a, d) {
    switch (a.tag) {
      case 3:
        A0(a), cs();
        break;
      case 5:
        Gv(a);
        break;
      case 1:
        Gt(a.type) && Su(a);
        break;
      case 4:
        fp(a, a.stateNode.containerInfo);
        break;
      case 10:
        var h = a.type._context,
          g = a.memoizedProps.value;
        Ve(Tu, h._currentValue), (h._currentValue = g);
        break;
      case 13:
        if (((h = a.memoizedState), h !== null))
          return h.dehydrated !== null
            ? (Ve(Je, Je.current & 1), (a.flags |= 128), null)
            : d & a.child.childLanes
            ? P0(s, a, d)
            : (Ve(Je, Je.current & 1),
              (s = Ir(s, a, d)),
              s !== null ? s.sibling : null);
        Ve(Je, Je.current & 1);
        break;
      case 19:
        if (((h = (d & a.childLanes) !== 0), s.flags & 128)) {
          if (h) return I0(s, a, d);
          a.flags |= 128;
        }
        if (
          ((g = a.memoizedState),
          g !== null &&
            ((g.rendering = null), (g.tail = null), (g.lastEffect = null)),
          Ve(Je, Je.current),
          h)
        )
          break;
        return null;
      case 22:
      case 23:
        return (a.lanes = 0), O0(s, a, d);
    }
    return Ir(s, a, d);
  }
  var L0, Ip, $0, _0;
  (L0 = function (s, a) {
    for (var d = a.child; d !== null; ) {
      if (d.tag === 5 || d.tag === 6) s.appendChild(d.stateNode);
      else if (d.tag !== 4 && d.child !== null) {
        (d.child.return = d), (d = d.child);
        continue;
      }
      if (d === a) break;
      for (; d.sibling === null; ) {
        if (d.return === null || d.return === a) return;
        d = d.return;
      }
      (d.sibling.return = d.return), (d = d.sibling);
    }
  }),
    (Ip = function () {}),
    ($0 = function (s, a, d, h) {
      var g = s.memoizedProps;
      if (g !== h) {
        (s = a.stateNode), fi(lr.current);
        var w = null;
        switch (d) {
          case "input":
            (g = $n(s, g)), (h = $n(s, h)), (w = []);
            break;
          case "select":
            (g = K({}, g, { value: void 0 })),
              (h = K({}, h, { value: void 0 })),
              (w = []);
            break;
          case "textarea":
            (g = kr(s, g)), (h = kr(s, h)), (w = []);
            break;
          default:
            typeof g.onClick != "function" &&
              typeof h.onClick == "function" &&
              (s.onclick = wu);
        }
        Ee(d, h);
        var k;
        d = null;
        for (j in g)
          if (!h.hasOwnProperty(j) && g.hasOwnProperty(j) && g[j] != null)
            if (j === "style") {
              var T = g[j];
              for (k in T) T.hasOwnProperty(k) && (d || (d = {}), (d[k] = ""));
            } else
              j !== "dangerouslySetInnerHTML" &&
                j !== "children" &&
                j !== "suppressContentEditableWarning" &&
                j !== "suppressHydrationWarning" &&
                j !== "autoFocus" &&
                (o.hasOwnProperty(j)
                  ? w || (w = [])
                  : (w = w || []).push(j, null));
        for (j in h) {
          var P = h[j];
          if (
            ((T = g != null ? g[j] : void 0),
            h.hasOwnProperty(j) && P !== T && (P != null || T != null))
          )
            if (j === "style")
              if (T) {
                for (k in T)
                  !T.hasOwnProperty(k) ||
                    (P && P.hasOwnProperty(k)) ||
                    (d || (d = {}), (d[k] = ""));
                for (k in P)
                  P.hasOwnProperty(k) &&
                    T[k] !== P[k] &&
                    (d || (d = {}), (d[k] = P[k]));
              } else d || (w || (w = []), w.push(j, d)), (d = P);
            else
              j === "dangerouslySetInnerHTML"
                ? ((P = P ? P.__html : void 0),
                  (T = T ? T.__html : void 0),
                  P != null && T !== P && (w = w || []).push(j, P))
                : j === "children"
                ? (typeof P != "string" && typeof P != "number") ||
                  (w = w || []).push(j, "" + P)
                : j !== "suppressContentEditableWarning" &&
                  j !== "suppressHydrationWarning" &&
                  (o.hasOwnProperty(j)
                    ? (P != null && j === "onScroll" && We("scroll", s),
                      w || T === P || (w = []))
                    : (w = w || []).push(j, P));
        }
        d && (w = w || []).push("style", d);
        var j = w;
        (a.updateQueue = j) && (a.flags |= 4);
      }
    }),
    (_0 = function (s, a, d, h) {
      d !== h && (a.flags |= 4);
    });
  function _l(s, a) {
    if (!Ge)
      switch (s.tailMode) {
        case "hidden":
          a = s.tail;
          for (var d = null; a !== null; )
            a.alternate !== null && (d = a), (a = a.sibling);
          d === null ? (s.tail = null) : (d.sibling = null);
          break;
        case "collapsed":
          d = s.tail;
          for (var h = null; d !== null; )
            d.alternate !== null && (h = d), (d = d.sibling);
          h === null
            ? a || s.tail === null
              ? (s.tail = null)
              : (s.tail.sibling = null)
            : (h.sibling = null);
      }
  }
  function At(s) {
    var a = s.alternate !== null && s.alternate.child === s.child,
      d = 0,
      h = 0;
    if (a)
      for (var g = s.child; g !== null; )
        (d |= g.lanes | g.childLanes),
          (h |= g.subtreeFlags & 14680064),
          (h |= g.flags & 14680064),
          (g.return = s),
          (g = g.sibling);
    else
      for (g = s.child; g !== null; )
        (d |= g.lanes | g.childLanes),
          (h |= g.subtreeFlags),
          (h |= g.flags),
          (g.return = s),
          (g = g.sibling);
    return (s.subtreeFlags |= h), (s.childLanes = d), a;
  }
  function U2(s, a, d) {
    var h = a.pendingProps;
    switch ((np(a), a.tag)) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return At(a), null;
      case 1:
        return Gt(a.type) && bu(), At(a), null;
      case 3:
        return (
          (h = a.stateNode),
          hs(),
          Ue(qt),
          Ue(Tt),
          mp(),
          h.pendingContext &&
            ((h.context = h.pendingContext), (h.pendingContext = null)),
          (s === null || s.child === null) &&
            (Mu(a)
              ? (a.flags |= 4)
              : s === null ||
                (s.memoizedState.isDehydrated && !(a.flags & 256)) ||
                ((a.flags |= 1024), jn !== null && (Up(jn), (jn = null)))),
          Ip(s, a),
          At(a),
          null
        );
      case 5:
        pp(a);
        var g = fi(Pl.current);
        if (((d = a.type), s !== null && a.stateNode != null))
          $0(s, a, d, h, g),
            s.ref !== a.ref && ((a.flags |= 512), (a.flags |= 2097152));
        else {
          if (!h) {
            if (a.stateNode === null) throw Error(n(166));
            return At(a), null;
          }
          if (((s = fi(lr.current)), Mu(a))) {
            (h = a.stateNode), (d = a.type);
            var w = a.memoizedProps;
            switch (((h[sr] = a), (h[Ol] = w), (s = (a.mode & 1) !== 0), d)) {
              case "dialog":
                We("cancel", h), We("close", h);
                break;
              case "iframe":
              case "object":
              case "embed":
                We("load", h);
                break;
              case "video":
              case "audio":
                for (g = 0; g < kl.length; g++) We(kl[g], h);
                break;
              case "source":
                We("error", h);
                break;
              case "img":
              case "image":
              case "link":
                We("error", h), We("load", h);
                break;
              case "details":
                We("toggle", h);
                break;
              case "input":
                Sr(h, w), We("invalid", h);
                break;
              case "select":
                (h._wrapperState = { wasMultiple: !!w.multiple }),
                  We("invalid", h);
                break;
              case "textarea":
                rr(h, w), We("invalid", h);
            }
            Ee(d, w), (g = null);
            for (var k in w)
              if (w.hasOwnProperty(k)) {
                var T = w[k];
                k === "children"
                  ? typeof T == "string"
                    ? h.textContent !== T &&
                      (w.suppressHydrationWarning !== !0 &&
                        vu(h.textContent, T, s),
                      (g = ["children", T]))
                    : typeof T == "number" &&
                      h.textContent !== "" + T &&
                      (w.suppressHydrationWarning !== !0 &&
                        vu(h.textContent, T, s),
                      (g = ["children", "" + T]))
                  : o.hasOwnProperty(k) &&
                    T != null &&
                    k === "onScroll" &&
                    We("scroll", h);
              }
            switch (d) {
              case "input":
                Kt(h), Cr(h, w, !0);
                break;
              case "textarea":
                Kt(h), Zo(h);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof w.onClick == "function" && (h.onclick = wu);
            }
            (h = g), (a.updateQueue = h), h !== null && (a.flags |= 4);
          } else {
            (k = g.nodeType === 9 ? g : g.ownerDocument),
              s === "http://www.w3.org/1999/xhtml" && (s = ei(d)),
              s === "http://www.w3.org/1999/xhtml"
                ? d === "script"
                  ? ((s = k.createElement("div")),
                    (s.innerHTML = "<script></script>"),
                    (s = s.removeChild(s.firstChild)))
                  : typeof h.is == "string"
                  ? (s = k.createElement(d, { is: h.is }))
                  : ((s = k.createElement(d)),
                    d === "select" &&
                      ((k = s),
                      h.multiple
                        ? (k.multiple = !0)
                        : h.size && (k.size = h.size)))
                : (s = k.createElementNS(s, d)),
              (s[sr] = a),
              (s[Ol] = h),
              L0(s, a, !1, !1),
              (a.stateNode = s);
            e: {
              switch (((k = _e(d, h)), d)) {
                case "dialog":
                  We("cancel", s), We("close", s), (g = h);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  We("load", s), (g = h);
                  break;
                case "video":
                case "audio":
                  for (g = 0; g < kl.length; g++) We(kl[g], s);
                  g = h;
                  break;
                case "source":
                  We("error", s), (g = h);
                  break;
                case "img":
                case "image":
                case "link":
                  We("error", s), We("load", s), (g = h);
                  break;
                case "details":
                  We("toggle", s), (g = h);
                  break;
                case "input":
                  Sr(s, h), (g = $n(s, h)), We("invalid", s);
                  break;
                case "option":
                  g = h;
                  break;
                case "select":
                  (s._wrapperState = { wasMultiple: !!h.multiple }),
                    (g = K({}, h, { value: void 0 })),
                    We("invalid", s);
                  break;
                case "textarea":
                  rr(s, h), (g = kr(s, h)), We("invalid", s);
                  break;
                default:
                  g = h;
              }
              Ee(d, g), (T = g);
              for (w in T)
                if (T.hasOwnProperty(w)) {
                  var P = T[w];
                  w === "style"
                    ? W(s, P)
                    : w === "dangerouslySetInnerHTML"
                    ? ((P = P ? P.__html : void 0), P != null && Ja(s, P))
                    : w === "children"
                    ? typeof P == "string"
                      ? (d !== "textarea" || P !== "") && ti(s, P)
                      : typeof P == "number" && ti(s, "" + P)
                    : w !== "suppressContentEditableWarning" &&
                      w !== "suppressHydrationWarning" &&
                      w !== "autoFocus" &&
                      (o.hasOwnProperty(w)
                        ? P != null && w === "onScroll" && We("scroll", s)
                        : P != null && $(s, w, P, k));
                }
              switch (d) {
                case "input":
                  Kt(s), Cr(s, h, !1);
                  break;
                case "textarea":
                  Kt(s), Zo(s);
                  break;
                case "option":
                  h.value != null && s.setAttribute("value", "" + we(h.value));
                  break;
                case "select":
                  (s.multiple = !!h.multiple),
                    (w = h.value),
                    w != null
                      ? _t(s, !!h.multiple, w, !1)
                      : h.defaultValue != null &&
                        _t(s, !!h.multiple, h.defaultValue, !0);
                  break;
                default:
                  typeof g.onClick == "function" && (s.onclick = wu);
              }
              switch (d) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  h = !!h.autoFocus;
                  break e;
                case "img":
                  h = !0;
                  break e;
                default:
                  h = !1;
              }
            }
            h && (a.flags |= 4);
          }
          a.ref !== null && ((a.flags |= 512), (a.flags |= 2097152));
        }
        return At(a), null;
      case 6:
        if (s && a.stateNode != null) _0(s, a, s.memoizedProps, h);
        else {
          if (typeof h != "string" && a.stateNode === null) throw Error(n(166));
          if (((d = fi(Pl.current)), fi(lr.current), Mu(a))) {
            if (
              ((h = a.stateNode),
              (d = a.memoizedProps),
              (h[sr] = a),
              (w = h.nodeValue !== d) && ((s = un), s !== null))
            )
              switch (s.tag) {
                case 3:
                  vu(h.nodeValue, d, (s.mode & 1) !== 0);
                  break;
                case 5:
                  s.memoizedProps.suppressHydrationWarning !== !0 &&
                    vu(h.nodeValue, d, (s.mode & 1) !== 0);
              }
            w && (a.flags |= 4);
          } else
            (h = (d.nodeType === 9 ? d : d.ownerDocument).createTextNode(h)),
              (h[sr] = a),
              (a.stateNode = h);
        }
        return At(a), null;
      case 13:
        if (
          (Ue(Je),
          (h = a.memoizedState),
          s === null ||
            (s.memoizedState !== null && s.memoizedState.dehydrated !== null))
        ) {
          if (Ge && cn !== null && a.mode & 1 && !(a.flags & 128))
            jv(), cs(), (a.flags |= 98560), (w = !1);
          else if (((w = Mu(a)), h !== null && h.dehydrated !== null)) {
            if (s === null) {
              if (!w) throw Error(n(318));
              if (
                ((w = a.memoizedState),
                (w = w !== null ? w.dehydrated : null),
                !w)
              )
                throw Error(n(317));
              w[sr] = a;
            } else
              cs(),
                !(a.flags & 128) && (a.memoizedState = null),
                (a.flags |= 4);
            At(a), (w = !1);
          } else jn !== null && (Up(jn), (jn = null)), (w = !0);
          if (!w) return a.flags & 65536 ? a : null;
        }
        return a.flags & 128
          ? ((a.lanes = d), a)
          : ((h = h !== null),
            h !== (s !== null && s.memoizedState !== null) &&
              h &&
              ((a.child.flags |= 8192),
              a.mode & 1 &&
                (s === null || Je.current & 1 ? ut === 0 && (ut = 3) : Gp())),
            a.updateQueue !== null && (a.flags |= 4),
            At(a),
            null);
      case 4:
        return (
          hs(),
          Ip(s, a),
          s === null && El(a.stateNode.containerInfo),
          At(a),
          null
        );
      case 10:
        return ap(a.type._context), At(a), null;
      case 17:
        return Gt(a.type) && bu(), At(a), null;
      case 19:
        if ((Ue(Je), (w = a.memoizedState), w === null)) return At(a), null;
        if (((h = (a.flags & 128) !== 0), (k = w.rendering), k === null))
          if (h) _l(w, !1);
          else {
            if (ut !== 0 || (s !== null && s.flags & 128))
              for (s = a.child; s !== null; ) {
                if (((k = Pu(s)), k !== null)) {
                  for (
                    a.flags |= 128,
                      _l(w, !1),
                      h = k.updateQueue,
                      h !== null && ((a.updateQueue = h), (a.flags |= 4)),
                      a.subtreeFlags = 0,
                      h = d,
                      d = a.child;
                    d !== null;

                  )
                    (w = d),
                      (s = h),
                      (w.flags &= 14680066),
                      (k = w.alternate),
                      k === null
                        ? ((w.childLanes = 0),
                          (w.lanes = s),
                          (w.child = null),
                          (w.subtreeFlags = 0),
                          (w.memoizedProps = null),
                          (w.memoizedState = null),
                          (w.updateQueue = null),
                          (w.dependencies = null),
                          (w.stateNode = null))
                        : ((w.childLanes = k.childLanes),
                          (w.lanes = k.lanes),
                          (w.child = k.child),
                          (w.subtreeFlags = 0),
                          (w.deletions = null),
                          (w.memoizedProps = k.memoizedProps),
                          (w.memoizedState = k.memoizedState),
                          (w.updateQueue = k.updateQueue),
                          (w.type = k.type),
                          (s = k.dependencies),
                          (w.dependencies =
                            s === null
                              ? null
                              : {
                                  lanes: s.lanes,
                                  firstContext: s.firstContext,
                                })),
                      (d = d.sibling);
                  return Ve(Je, (Je.current & 1) | 2), a.child;
                }
                s = s.sibling;
              }
            w.tail !== null &&
              rt() > vs &&
              ((a.flags |= 128), (h = !0), _l(w, !1), (a.lanes = 4194304));
          }
        else {
          if (!h)
            if (((s = Pu(k)), s !== null)) {
              if (
                ((a.flags |= 128),
                (h = !0),
                (d = s.updateQueue),
                d !== null && ((a.updateQueue = d), (a.flags |= 4)),
                _l(w, !0),
                w.tail === null &&
                  w.tailMode === "hidden" &&
                  !k.alternate &&
                  !Ge)
              )
                return At(a), null;
            } else
              2 * rt() - w.renderingStartTime > vs &&
                d !== 1073741824 &&
                ((a.flags |= 128), (h = !0), _l(w, !1), (a.lanes = 4194304));
          w.isBackwards
            ? ((k.sibling = a.child), (a.child = k))
            : ((d = w.last),
              d !== null ? (d.sibling = k) : (a.child = k),
              (w.last = k));
        }
        return w.tail !== null
          ? ((a = w.tail),
            (w.rendering = a),
            (w.tail = a.sibling),
            (w.renderingStartTime = rt()),
            (a.sibling = null),
            (d = Je.current),
            Ve(Je, h ? (d & 1) | 2 : d & 1),
            a)
          : (At(a), null);
      case 22:
      case 23:
        return (
          qp(),
          (h = a.memoizedState !== null),
          s !== null && (s.memoizedState !== null) !== h && (a.flags |= 8192),
          h && a.mode & 1
            ? dn & 1073741824 &&
              (At(a), a.subtreeFlags & 6 && (a.flags |= 8192))
            : At(a),
          null
        );
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(n(156, a.tag));
  }
  function K2(s, a) {
    switch ((np(a), a.tag)) {
      case 1:
        return (
          Gt(a.type) && bu(),
          (s = a.flags),
          s & 65536 ? ((a.flags = (s & -65537) | 128), a) : null
        );
      case 3:
        return (
          hs(),
          Ue(qt),
          Ue(Tt),
          mp(),
          (s = a.flags),
          s & 65536 && !(s & 128) ? ((a.flags = (s & -65537) | 128), a) : null
        );
      case 5:
        return pp(a), null;
      case 13:
        if (
          (Ue(Je), (s = a.memoizedState), s !== null && s.dehydrated !== null)
        ) {
          if (a.alternate === null) throw Error(n(340));
          cs();
        }
        return (
          (s = a.flags), s & 65536 ? ((a.flags = (s & -65537) | 128), a) : null
        );
      case 19:
        return Ue(Je), null;
      case 4:
        return hs(), null;
      case 10:
        return ap(a.type._context), null;
      case 22:
      case 23:
        return qp(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Bu = !1,
    Rt = !1,
    q2 = typeof WeakSet == "function" ? WeakSet : Set,
    fe = null;
  function gs(s, a) {
    var d = s.ref;
    if (d !== null)
      if (typeof d == "function")
        try {
          d(null);
        } catch (h) {
          Ye(s, a, h);
        }
      else d.current = null;
  }
  function Lp(s, a, d) {
    try {
      d();
    } catch (h) {
      Ye(s, a, h);
    }
  }
  var F0 = !1;
  function G2(s, a) {
    if (((qf = lu), (s = gv()), zf(s))) {
      if ("selectionStart" in s)
        var d = { start: s.selectionStart, end: s.selectionEnd };
      else
        e: {
          d = ((d = s.ownerDocument) && d.defaultView) || window;
          var h = d.getSelection && d.getSelection();
          if (h && h.rangeCount !== 0) {
            d = h.anchorNode;
            var g = h.anchorOffset,
              w = h.focusNode;
            h = h.focusOffset;
            try {
              d.nodeType, w.nodeType;
            } catch {
              d = null;
              break e;
            }
            var k = 0,
              T = -1,
              P = -1,
              j = 0,
              G = 0,
              Y = s,
              q = null;
            t: for (;;) {
              for (
                var ue;
                Y !== d || (g !== 0 && Y.nodeType !== 3) || (T = k + g),
                  Y !== w || (h !== 0 && Y.nodeType !== 3) || (P = k + h),
                  Y.nodeType === 3 && (k += Y.nodeValue.length),
                  (ue = Y.firstChild) !== null;

              )
                (q = Y), (Y = ue);
              for (;;) {
                if (Y === s) break t;
                if (
                  (q === d && ++j === g && (T = k),
                  q === w && ++G === h && (P = k),
                  (ue = Y.nextSibling) !== null)
                )
                  break;
                (Y = q), (q = Y.parentNode);
              }
              Y = ue;
            }
            d = T === -1 || P === -1 ? null : { start: T, end: P };
          } else d = null;
        }
      d = d || { start: 0, end: 0 };
    } else d = null;
    for (
      Gf = { focusedElem: s, selectionRange: d }, lu = !1, fe = a;
      fe !== null;

    )
      if (
        ((a = fe), (s = a.child), (a.subtreeFlags & 1028) !== 0 && s !== null)
      )
        (s.return = a), (fe = s);
      else
        for (; fe !== null; ) {
          a = fe;
          try {
            var pe = a.alternate;
            if (a.flags & 1024)
              switch (a.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (pe !== null) {
                    var ye = pe.memoizedProps,
                      ot = pe.memoizedState,
                      _ = a.stateNode,
                      L = _.getSnapshotBeforeUpdate(
                        a.elementType === a.type ? ye : Bn(a.type, ye),
                        ot
                      );
                    _.__reactInternalSnapshotBeforeUpdate = L;
                  }
                  break;
                case 3:
                  var z = a.stateNode.containerInfo;
                  z.nodeType === 1
                    ? (z.textContent = "")
                    : z.nodeType === 9 &&
                      z.documentElement &&
                      z.removeChild(z.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(n(163));
              }
          } catch (te) {
            Ye(a, a.return, te);
          }
          if (((s = a.sibling), s !== null)) {
            (s.return = a.return), (fe = s);
            break;
          }
          fe = a.return;
        }
    return (pe = F0), (F0 = !1), pe;
  }
  function Fl(s, a, d) {
    var h = a.updateQueue;
    if (((h = h !== null ? h.lastEffect : null), h !== null)) {
      var g = (h = h.next);
      do {
        if ((g.tag & s) === s) {
          var w = g.destroy;
          (g.destroy = void 0), w !== void 0 && Lp(a, d, w);
        }
        g = g.next;
      } while (g !== h);
    }
  }
  function Hu(s, a) {
    if (
      ((a = a.updateQueue), (a = a !== null ? a.lastEffect : null), a !== null)
    ) {
      var d = (a = a.next);
      do {
        if ((d.tag & s) === s) {
          var h = d.create;
          d.destroy = h();
        }
        d = d.next;
      } while (d !== a);
    }
  }
  function $p(s) {
    var a = s.ref;
    if (a !== null) {
      var d = s.stateNode;
      switch (s.tag) {
        case 5:
          s = d;
          break;
        default:
          s = d;
      }
      typeof a == "function" ? a(s) : (a.current = s);
    }
  }
  function z0(s) {
    var a = s.alternate;
    a !== null && ((s.alternate = null), z0(a)),
      (s.child = null),
      (s.deletions = null),
      (s.sibling = null),
      s.tag === 5 &&
        ((a = s.stateNode),
        a !== null &&
          (delete a[sr],
          delete a[Ol],
          delete a[Xf],
          delete a[A2],
          delete a[R2])),
      (s.stateNode = null),
      (s.return = null),
      (s.dependencies = null),
      (s.memoizedProps = null),
      (s.memoizedState = null),
      (s.pendingProps = null),
      (s.stateNode = null),
      (s.updateQueue = null);
  }
  function j0(s) {
    return s.tag === 5 || s.tag === 3 || s.tag === 4;
  }
  function B0(s) {
    e: for (;;) {
      for (; s.sibling === null; ) {
        if (s.return === null || j0(s.return)) return null;
        s = s.return;
      }
      for (
        s.sibling.return = s.return, s = s.sibling;
        s.tag !== 5 && s.tag !== 6 && s.tag !== 18;

      ) {
        if (s.flags & 2 || s.child === null || s.tag === 4) continue e;
        (s.child.return = s), (s = s.child);
      }
      if (!(s.flags & 2)) return s.stateNode;
    }
  }
  function _p(s, a, d) {
    var h = s.tag;
    if (h === 5 || h === 6)
      (s = s.stateNode),
        a
          ? d.nodeType === 8
            ? d.parentNode.insertBefore(s, a)
            : d.insertBefore(s, a)
          : (d.nodeType === 8
              ? ((a = d.parentNode), a.insertBefore(s, d))
              : ((a = d), a.appendChild(s)),
            (d = d._reactRootContainer),
            d != null || a.onclick !== null || (a.onclick = wu));
    else if (h !== 4 && ((s = s.child), s !== null))
      for (_p(s, a, d), s = s.sibling; s !== null; )
        _p(s, a, d), (s = s.sibling);
  }
  function Fp(s, a, d) {
    var h = s.tag;
    if (h === 5 || h === 6)
      (s = s.stateNode), a ? d.insertBefore(s, a) : d.appendChild(s);
    else if (h !== 4 && ((s = s.child), s !== null))
      for (Fp(s, a, d), s = s.sibling; s !== null; )
        Fp(s, a, d), (s = s.sibling);
  }
  var bt = null,
    Hn = !1;
  function co(s, a, d) {
    for (d = d.child; d !== null; ) H0(s, a, d), (d = d.sibling);
  }
  function H0(s, a, d) {
    if (ir && typeof ir.onCommitFiberUnmount == "function")
      try {
        ir.onCommitFiberUnmount(tu, d);
      } catch {}
    switch (d.tag) {
      case 5:
        Rt || gs(d, a);
      case 6:
        var h = bt,
          g = Hn;
        (bt = null),
          co(s, a, d),
          (bt = h),
          (Hn = g),
          bt !== null &&
            (Hn
              ? ((s = bt),
                (d = d.stateNode),
                s.nodeType === 8
                  ? s.parentNode.removeChild(d)
                  : s.removeChild(d))
              : bt.removeChild(d.stateNode));
        break;
      case 18:
        bt !== null &&
          (Hn
            ? ((s = bt),
              (d = d.stateNode),
              s.nodeType === 8
                ? Yf(s.parentNode, d)
                : s.nodeType === 1 && Yf(s, d),
              gl(s))
            : Yf(bt, d.stateNode));
        break;
      case 4:
        (h = bt),
          (g = Hn),
          (bt = d.stateNode.containerInfo),
          (Hn = !0),
          co(s, a, d),
          (bt = h),
          (Hn = g);
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (
          !Rt &&
          ((h = d.updateQueue), h !== null && ((h = h.lastEffect), h !== null))
        ) {
          g = h = h.next;
          do {
            var w = g,
              k = w.destroy;
            (w = w.tag),
              k !== void 0 && (w & 2 || w & 4) && Lp(d, a, k),
              (g = g.next);
          } while (g !== h);
        }
        co(s, a, d);
        break;
      case 1:
        if (
          !Rt &&
          (gs(d, a),
          (h = d.stateNode),
          typeof h.componentWillUnmount == "function")
        )
          try {
            (h.props = d.memoizedProps),
              (h.state = d.memoizedState),
              h.componentWillUnmount();
          } catch (T) {
            Ye(d, a, T);
          }
        co(s, a, d);
        break;
      case 21:
        co(s, a, d);
        break;
      case 22:
        d.mode & 1
          ? ((Rt = (h = Rt) || d.memoizedState !== null), co(s, a, d), (Rt = h))
          : co(s, a, d);
        break;
      default:
        co(s, a, d);
    }
  }
  function V0(s) {
    var a = s.updateQueue;
    if (a !== null) {
      s.updateQueue = null;
      var d = s.stateNode;
      d === null && (d = s.stateNode = new q2()),
        a.forEach(function (h) {
          var g = rO.bind(null, s, h);
          d.has(h) || (d.add(h), h.then(g, g));
        });
    }
  }
  function Vn(s, a) {
    var d = a.deletions;
    if (d !== null)
      for (var h = 0; h < d.length; h++) {
        var g = d[h];
        try {
          var w = s,
            k = a,
            T = k;
          e: for (; T !== null; ) {
            switch (T.tag) {
              case 5:
                (bt = T.stateNode), (Hn = !1);
                break e;
              case 3:
                (bt = T.stateNode.containerInfo), (Hn = !0);
                break e;
              case 4:
                (bt = T.stateNode.containerInfo), (Hn = !0);
                break e;
            }
            T = T.return;
          }
          if (bt === null) throw Error(n(160));
          H0(w, k, g), (bt = null), (Hn = !1);
          var P = g.alternate;
          P !== null && (P.return = null), (g.return = null);
        } catch (j) {
          Ye(g, a, j);
        }
      }
    if (a.subtreeFlags & 12854)
      for (a = a.child; a !== null; ) W0(a, s), (a = a.sibling);
  }
  function W0(s, a) {
    var d = s.alternate,
      h = s.flags;
    switch (s.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if ((Vn(a, s), ur(s), h & 4)) {
          try {
            Fl(3, s, s.return), Hu(3, s);
          } catch (ye) {
            Ye(s, s.return, ye);
          }
          try {
            Fl(5, s, s.return);
          } catch (ye) {
            Ye(s, s.return, ye);
          }
        }
        break;
      case 1:
        Vn(a, s), ur(s), h & 512 && d !== null && gs(d, d.return);
        break;
      case 5:
        if (
          (Vn(a, s),
          ur(s),
          h & 512 && d !== null && gs(d, d.return),
          s.flags & 32)
        ) {
          var g = s.stateNode;
          try {
            ti(g, "");
          } catch (ye) {
            Ye(s, s.return, ye);
          }
        }
        if (h & 4 && ((g = s.stateNode), g != null)) {
          var w = s.memoizedProps,
            k = d !== null ? d.memoizedProps : w,
            T = s.type,
            P = s.updateQueue;
          if (((s.updateQueue = null), P !== null))
            try {
              T === "input" && w.type === "radio" && w.name != null && nr(g, w),
                _e(T, k);
              var j = _e(T, w);
              for (k = 0; k < P.length; k += 2) {
                var G = P[k],
                  Y = P[k + 1];
                G === "style"
                  ? W(g, Y)
                  : G === "dangerouslySetInnerHTML"
                  ? Ja(g, Y)
                  : G === "children"
                  ? ti(g, Y)
                  : $(g, G, Y, j);
              }
              switch (T) {
                case "input":
                  _n(g, w);
                  break;
                case "textarea":
                  Qr(g, w);
                  break;
                case "select":
                  var q = g._wrapperState.wasMultiple;
                  g._wrapperState.wasMultiple = !!w.multiple;
                  var ue = w.value;
                  ue != null
                    ? _t(g, !!w.multiple, ue, !1)
                    : q !== !!w.multiple &&
                      (w.defaultValue != null
                        ? _t(g, !!w.multiple, w.defaultValue, !0)
                        : _t(g, !!w.multiple, w.multiple ? [] : "", !1));
              }
              g[Ol] = w;
            } catch (ye) {
              Ye(s, s.return, ye);
            }
        }
        break;
      case 6:
        if ((Vn(a, s), ur(s), h & 4)) {
          if (s.stateNode === null) throw Error(n(162));
          (g = s.stateNode), (w = s.memoizedProps);
          try {
            g.nodeValue = w;
          } catch (ye) {
            Ye(s, s.return, ye);
          }
        }
        break;
      case 3:
        if (
          (Vn(a, s), ur(s), h & 4 && d !== null && d.memoizedState.isDehydrated)
        )
          try {
            gl(a.containerInfo);
          } catch (ye) {
            Ye(s, s.return, ye);
          }
        break;
      case 4:
        Vn(a, s), ur(s);
        break;
      case 13:
        Vn(a, s),
          ur(s),
          (g = s.child),
          g.flags & 8192 &&
            ((w = g.memoizedState !== null),
            (g.stateNode.isHidden = w),
            !w ||
              (g.alternate !== null && g.alternate.memoizedState !== null) ||
              (Bp = rt())),
          h & 4 && V0(s);
        break;
      case 22:
        if (
          ((G = d !== null && d.memoizedState !== null),
          s.mode & 1 ? ((Rt = (j = Rt) || G), Vn(a, s), (Rt = j)) : Vn(a, s),
          ur(s),
          h & 8192)
        ) {
          if (
            ((j = s.memoizedState !== null),
            (s.stateNode.isHidden = j) && !G && s.mode & 1)
          )
            for (fe = s, G = s.child; G !== null; ) {
              for (Y = fe = G; fe !== null; ) {
                switch (((q = fe), (ue = q.child), q.tag)) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    Fl(4, q, q.return);
                    break;
                  case 1:
                    gs(q, q.return);
                    var pe = q.stateNode;
                    if (typeof pe.componentWillUnmount == "function") {
                      (h = q), (d = q.return);
                      try {
                        (a = h),
                          (pe.props = a.memoizedProps),
                          (pe.state = a.memoizedState),
                          pe.componentWillUnmount();
                      } catch (ye) {
                        Ye(h, d, ye);
                      }
                    }
                    break;
                  case 5:
                    gs(q, q.return);
                    break;
                  case 22:
                    if (q.memoizedState !== null) {
                      q0(Y);
                      continue;
                    }
                }
                ue !== null ? ((ue.return = q), (fe = ue)) : q0(Y);
              }
              G = G.sibling;
            }
          e: for (G = null, Y = s; ; ) {
            if (Y.tag === 5) {
              if (G === null) {
                G = Y;
                try {
                  (g = Y.stateNode),
                    j
                      ? ((w = g.style),
                        typeof w.setProperty == "function"
                          ? w.setProperty("display", "none", "important")
                          : (w.display = "none"))
                      : ((T = Y.stateNode),
                        (P = Y.memoizedProps.style),
                        (k =
                          P != null && P.hasOwnProperty("display")
                            ? P.display
                            : null),
                        (T.style.display = Qa("display", k)));
                } catch (ye) {
                  Ye(s, s.return, ye);
                }
              }
            } else if (Y.tag === 6) {
              if (G === null)
                try {
                  Y.stateNode.nodeValue = j ? "" : Y.memoizedProps;
                } catch (ye) {
                  Ye(s, s.return, ye);
                }
            } else if (
              ((Y.tag !== 22 && Y.tag !== 23) ||
                Y.memoizedState === null ||
                Y === s) &&
              Y.child !== null
            ) {
              (Y.child.return = Y), (Y = Y.child);
              continue;
            }
            if (Y === s) break e;
            for (; Y.sibling === null; ) {
              if (Y.return === null || Y.return === s) break e;
              G === Y && (G = null), (Y = Y.return);
            }
            G === Y && (G = null),
              (Y.sibling.return = Y.return),
              (Y = Y.sibling);
          }
        }
        break;
      case 19:
        Vn(a, s), ur(s), h & 4 && V0(s);
        break;
      case 21:
        break;
      default:
        Vn(a, s), ur(s);
    }
  }
  function ur(s) {
    var a = s.flags;
    if (a & 2) {
      try {
        e: {
          for (var d = s.return; d !== null; ) {
            if (j0(d)) {
              var h = d;
              break e;
            }
            d = d.return;
          }
          throw Error(n(160));
        }
        switch (h.tag) {
          case 5:
            var g = h.stateNode;
            h.flags & 32 && (ti(g, ""), (h.flags &= -33));
            var w = B0(s);
            Fp(s, w, g);
            break;
          case 3:
          case 4:
            var k = h.stateNode.containerInfo,
              T = B0(s);
            _p(s, T, k);
            break;
          default:
            throw Error(n(161));
        }
      } catch (P) {
        Ye(s, s.return, P);
      }
      s.flags &= -3;
    }
    a & 4096 && (s.flags &= -4097);
  }
  function J2(s, a, d) {
    (fe = s), U0(s);
  }
  function U0(s, a, d) {
    for (var h = (s.mode & 1) !== 0; fe !== null; ) {
      var g = fe,
        w = g.child;
      if (g.tag === 22 && h) {
        var k = g.memoizedState !== null || Bu;
        if (!k) {
          var T = g.alternate,
            P = (T !== null && T.memoizedState !== null) || Rt;
          T = Bu;
          var j = Rt;
          if (((Bu = k), (Rt = P) && !j))
            for (fe = g; fe !== null; )
              (k = fe),
                (P = k.child),
                k.tag === 22 && k.memoizedState !== null
                  ? G0(g)
                  : P !== null
                  ? ((P.return = k), (fe = P))
                  : G0(g);
          for (; w !== null; ) (fe = w), U0(w), (w = w.sibling);
          (fe = g), (Bu = T), (Rt = j);
        }
        K0(s);
      } else
        g.subtreeFlags & 8772 && w !== null
          ? ((w.return = g), (fe = w))
          : K0(s);
    }
  }
  function K0(s) {
    for (; fe !== null; ) {
      var a = fe;
      if (a.flags & 8772) {
        var d = a.alternate;
        try {
          if (a.flags & 8772)
            switch (a.tag) {
              case 0:
              case 11:
              case 15:
                Rt || Hu(5, a);
                break;
              case 1:
                var h = a.stateNode;
                if (a.flags & 4 && !Rt)
                  if (d === null) h.componentDidMount();
                  else {
                    var g =
                      a.elementType === a.type
                        ? d.memoizedProps
                        : Bn(a.type, d.memoizedProps);
                    h.componentDidUpdate(
                      g,
                      d.memoizedState,
                      h.__reactInternalSnapshotBeforeUpdate
                    );
                  }
                var w = a.updateQueue;
                w !== null && qv(a, w, h);
                break;
              case 3:
                var k = a.updateQueue;
                if (k !== null) {
                  if (((d = null), a.child !== null))
                    switch (a.child.tag) {
                      case 5:
                        d = a.child.stateNode;
                        break;
                      case 1:
                        d = a.child.stateNode;
                    }
                  qv(a, k, d);
                }
                break;
              case 5:
                var T = a.stateNode;
                if (d === null && a.flags & 4) {
                  d = T;
                  var P = a.memoizedProps;
                  switch (a.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      P.autoFocus && d.focus();
                      break;
                    case "img":
                      P.src && (d.src = P.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (a.memoizedState === null) {
                  var j = a.alternate;
                  if (j !== null) {
                    var G = j.memoizedState;
                    if (G !== null) {
                      var Y = G.dehydrated;
                      Y !== null && gl(Y);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(n(163));
            }
          Rt || (a.flags & 512 && $p(a));
        } catch (q) {
          Ye(a, a.return, q);
        }
      }
      if (a === s) {
        fe = null;
        break;
      }
      if (((d = a.sibling), d !== null)) {
        (d.return = a.return), (fe = d);
        break;
      }
      fe = a.return;
    }
  }
  function q0(s) {
    for (; fe !== null; ) {
      var a = fe;
      if (a === s) {
        fe = null;
        break;
      }
      var d = a.sibling;
      if (d !== null) {
        (d.return = a.return), (fe = d);
        break;
      }
      fe = a.return;
    }
  }
  function G0(s) {
    for (; fe !== null; ) {
      var a = fe;
      try {
        switch (a.tag) {
          case 0:
          case 11:
          case 15:
            var d = a.return;
            try {
              Hu(4, a);
            } catch (P) {
              Ye(a, d, P);
            }
            break;
          case 1:
            var h = a.stateNode;
            if (typeof h.componentDidMount == "function") {
              var g = a.return;
              try {
                h.componentDidMount();
              } catch (P) {
                Ye(a, g, P);
              }
            }
            var w = a.return;
            try {
              $p(a);
            } catch (P) {
              Ye(a, w, P);
            }
            break;
          case 5:
            var k = a.return;
            try {
              $p(a);
            } catch (P) {
              Ye(a, k, P);
            }
        }
      } catch (P) {
        Ye(a, a.return, P);
      }
      if (a === s) {
        fe = null;
        break;
      }
      var T = a.sibling;
      if (T !== null) {
        (T.return = a.return), (fe = T);
        break;
      }
      fe = a.return;
    }
  }
  var Q2 = Math.ceil,
    Vu = M.ReactCurrentDispatcher,
    zp = M.ReactCurrentOwner,
    Sn = M.ReactCurrentBatchConfig,
    Fe = 0,
    mt = null,
    it = null,
    St = 0,
    dn = 0,
    ys = io(0),
    ut = 0,
    zl = null,
    hi = 0,
    Wu = 0,
    jp = 0,
    jl = null,
    Qt = null,
    Bp = 0,
    vs = 1 / 0,
    Lr = null,
    Uu = !1,
    Hp = null,
    fo = null,
    Ku = !1,
    po = null,
    qu = 0,
    Bl = 0,
    Vp = null,
    Gu = -1,
    Ju = 0;
  function zt() {
    return Fe & 6 ? rt() : Gu !== -1 ? Gu : (Gu = rt());
  }
  function ho(s) {
    return s.mode & 1
      ? Fe & 2 && St !== 0
        ? St & -St
        : D2.transition !== null
        ? (Ju === 0 && (Ju = By()), Ju)
        : ((s = je),
          s !== 0 || ((s = window.event), (s = s === void 0 ? 16 : Qy(s.type))),
          s)
      : 1;
  }
  function Wn(s, a, d, h) {
    if (50 < Bl) throw ((Bl = 0), (Vp = null), Error(n(185)));
    dl(s, d, h),
      (!(Fe & 2) || s !== mt) &&
        (s === mt && (!(Fe & 2) && (Wu |= d), ut === 4 && mo(s, St)),
        Yt(s, h),
        d === 1 &&
          Fe === 0 &&
          !(a.mode & 1) &&
          ((vs = rt() + 500), Cu && lo()));
  }
  function Yt(s, a) {
    var d = s.callbackNode;
    DM(s, a);
    var h = ou(s, s === mt ? St : 0);
    if (h === 0)
      d !== null && Fy(d), (s.callbackNode = null), (s.callbackPriority = 0);
    else if (((a = h & -h), s.callbackPriority !== a)) {
      if ((d != null && Fy(d), a === 1))
        s.tag === 0 ? P2(Q0.bind(null, s)) : Lv(Q0.bind(null, s)),
          T2(function () {
            !(Fe & 6) && lo();
          }),
          (d = null);
      else {
        switch (Hy(h)) {
          case 1:
            d = Sf;
            break;
          case 4:
            d = zy;
            break;
          case 16:
            d = eu;
            break;
          case 536870912:
            d = jy;
            break;
          default:
            d = eu;
        }
        d = o1(d, J0.bind(null, s));
      }
      (s.callbackPriority = a), (s.callbackNode = d);
    }
  }
  function J0(s, a) {
    if (((Gu = -1), (Ju = 0), Fe & 6)) throw Error(n(327));
    var d = s.callbackNode;
    if (ws() && s.callbackNode !== d) return null;
    var h = ou(s, s === mt ? St : 0);
    if (h === 0) return null;
    if (h & 30 || h & s.expiredLanes || a) a = Qu(s, h);
    else {
      a = h;
      var g = Fe;
      Fe |= 2;
      var w = X0();
      (mt !== s || St !== a) && ((Lr = null), (vs = rt() + 500), gi(s, a));
      do
        try {
          Z2();
          break;
        } catch (T) {
          Y0(s, T);
        }
      while (!0);
      lp(),
        (Vu.current = w),
        (Fe = g),
        it !== null ? (a = 0) : ((mt = null), (St = 0), (a = ut));
    }
    if (a !== 0) {
      if (
        (a === 2 && ((g = Cf(s)), g !== 0 && ((h = g), (a = Wp(s, g)))),
        a === 1)
      )
        throw ((d = zl), gi(s, 0), mo(s, h), Yt(s, rt()), d);
      if (a === 6) mo(s, h);
      else {
        if (
          ((g = s.current.alternate),
          !(h & 30) &&
            !Y2(g) &&
            ((a = Qu(s, h)),
            a === 2 && ((w = Cf(s)), w !== 0 && ((h = w), (a = Wp(s, w)))),
            a === 1))
        )
          throw ((d = zl), gi(s, 0), mo(s, h), Yt(s, rt()), d);
        switch (((s.finishedWork = g), (s.finishedLanes = h), a)) {
          case 0:
          case 1:
            throw Error(n(345));
          case 2:
            yi(s, Qt, Lr);
            break;
          case 3:
            if (
              (mo(s, h),
              (h & 130023424) === h && ((a = Bp + 500 - rt()), 10 < a))
            ) {
              if (ou(s, 0) !== 0) break;
              if (((g = s.suspendedLanes), (g & h) !== h)) {
                zt(), (s.pingedLanes |= s.suspendedLanes & g);
                break;
              }
              s.timeoutHandle = Qf(yi.bind(null, s, Qt, Lr), a);
              break;
            }
            yi(s, Qt, Lr);
            break;
          case 4:
            if ((mo(s, h), (h & 4194240) === h)) break;
            for (a = s.eventTimes, g = -1; 0 < h; ) {
              var k = 31 - Fn(h);
              (w = 1 << k), (k = a[k]), k > g && (g = k), (h &= ~w);
            }
            if (
              ((h = g),
              (h = rt() - h),
              (h =
                (120 > h
                  ? 120
                  : 480 > h
                  ? 480
                  : 1080 > h
                  ? 1080
                  : 1920 > h
                  ? 1920
                  : 3e3 > h
                  ? 3e3
                  : 4320 > h
                  ? 4320
                  : 1960 * Q2(h / 1960)) - h),
              10 < h)
            ) {
              s.timeoutHandle = Qf(yi.bind(null, s, Qt, Lr), h);
              break;
            }
            yi(s, Qt, Lr);
            break;
          case 5:
            yi(s, Qt, Lr);
            break;
          default:
            throw Error(n(329));
        }
      }
    }
    return Yt(s, rt()), s.callbackNode === d ? J0.bind(null, s) : null;
  }
  function Wp(s, a) {
    var d = jl;
    return (
      s.current.memoizedState.isDehydrated && (gi(s, a).flags |= 256),
      (s = Qu(s, a)),
      s !== 2 && ((a = Qt), (Qt = d), a !== null && Up(a)),
      s
    );
  }
  function Up(s) {
    Qt === null ? (Qt = s) : Qt.push.apply(Qt, s);
  }
  function Y2(s) {
    for (var a = s; ; ) {
      if (a.flags & 16384) {
        var d = a.updateQueue;
        if (d !== null && ((d = d.stores), d !== null))
          for (var h = 0; h < d.length; h++) {
            var g = d[h],
              w = g.getSnapshot;
            g = g.value;
            try {
              if (!zn(w(), g)) return !1;
            } catch {
              return !1;
            }
          }
      }
      if (((d = a.child), a.subtreeFlags & 16384 && d !== null))
        (d.return = a), (a = d);
      else {
        if (a === s) break;
        for (; a.sibling === null; ) {
          if (a.return === null || a.return === s) return !0;
          a = a.return;
        }
        (a.sibling.return = a.return), (a = a.sibling);
      }
    }
    return !0;
  }
  function mo(s, a) {
    for (
      a &= ~jp,
        a &= ~Wu,
        s.suspendedLanes |= a,
        s.pingedLanes &= ~a,
        s = s.expirationTimes;
      0 < a;

    ) {
      var d = 31 - Fn(a),
        h = 1 << d;
      (s[d] = -1), (a &= ~h);
    }
  }
  function Q0(s) {
    if (Fe & 6) throw Error(n(327));
    ws();
    var a = ou(s, 0);
    if (!(a & 1)) return Yt(s, rt()), null;
    var d = Qu(s, a);
    if (s.tag !== 0 && d === 2) {
      var h = Cf(s);
      h !== 0 && ((a = h), (d = Wp(s, h)));
    }
    if (d === 1) throw ((d = zl), gi(s, 0), mo(s, a), Yt(s, rt()), d);
    if (d === 6) throw Error(n(345));
    return (
      (s.finishedWork = s.current.alternate),
      (s.finishedLanes = a),
      yi(s, Qt, Lr),
      Yt(s, rt()),
      null
    );
  }
  function Kp(s, a) {
    var d = Fe;
    Fe |= 1;
    try {
      return s(a);
    } finally {
      (Fe = d), Fe === 0 && ((vs = rt() + 500), Cu && lo());
    }
  }
  function mi(s) {
    po !== null && po.tag === 0 && !(Fe & 6) && ws();
    var a = Fe;
    Fe |= 1;
    var d = Sn.transition,
      h = je;
    try {
      if (((Sn.transition = null), (je = 1), s)) return s();
    } finally {
      (je = h), (Sn.transition = d), (Fe = a), !(Fe & 6) && lo();
    }
  }
  function qp() {
    (dn = ys.current), Ue(ys);
  }
  function gi(s, a) {
    (s.finishedWork = null), (s.finishedLanes = 0);
    var d = s.timeoutHandle;
    if ((d !== -1 && ((s.timeoutHandle = -1), O2(d)), it !== null))
      for (d = it.return; d !== null; ) {
        var h = d;
        switch ((np(h), h.tag)) {
          case 1:
            (h = h.type.childContextTypes), h != null && bu();
            break;
          case 3:
            hs(), Ue(qt), Ue(Tt), mp();
            break;
          case 5:
            pp(h);
            break;
          case 4:
            hs();
            break;
          case 13:
            Ue(Je);
            break;
          case 19:
            Ue(Je);
            break;
          case 10:
            ap(h.type._context);
            break;
          case 22:
          case 23:
            qp();
        }
        d = d.return;
      }
    if (
      ((mt = s),
      (it = s = go(s.current, null)),
      (St = dn = a),
      (ut = 0),
      (zl = null),
      (jp = Wu = hi = 0),
      (Qt = jl = null),
      di !== null)
    ) {
      for (a = 0; a < di.length; a++)
        if (((d = di[a]), (h = d.interleaved), h !== null)) {
          d.interleaved = null;
          var g = h.next,
            w = d.pending;
          if (w !== null) {
            var k = w.next;
            (w.next = g), (h.next = k);
          }
          d.pending = h;
        }
      di = null;
    }
    return s;
  }
  function Y0(s, a) {
    do {
      var d = it;
      try {
        if ((lp(), (Du.current = _u), Iu)) {
          for (var h = Qe.memoizedState; h !== null; ) {
            var g = h.queue;
            g !== null && (g.pending = null), (h = h.next);
          }
          Iu = !1;
        }
        if (
          ((pi = 0),
          (ht = at = Qe = null),
          (Dl = !1),
          (Il = 0),
          (zp.current = null),
          d === null || d.return === null)
        ) {
          (ut = 1), (zl = a), (it = null);
          break;
        }
        e: {
          var w = s,
            k = d.return,
            T = d,
            P = a;
          if (
            ((a = St),
            (T.flags |= 32768),
            P !== null && typeof P == "object" && typeof P.then == "function")
          ) {
            var j = P,
              G = T,
              Y = G.tag;
            if (!(G.mode & 1) && (Y === 0 || Y === 11 || Y === 15)) {
              var q = G.alternate;
              q
                ? ((G.updateQueue = q.updateQueue),
                  (G.memoizedState = q.memoizedState),
                  (G.lanes = q.lanes))
                : ((G.updateQueue = null), (G.memoizedState = null));
            }
            var ue = S0(k);
            if (ue !== null) {
              (ue.flags &= -257),
                C0(ue, k, T, w, a),
                ue.mode & 1 && b0(w, j, a),
                (a = ue),
                (P = j);
              var pe = a.updateQueue;
              if (pe === null) {
                var ye = new Set();
                ye.add(P), (a.updateQueue = ye);
              } else pe.add(P);
              break e;
            } else {
              if (!(a & 1)) {
                b0(w, j, a), Gp();
                break e;
              }
              P = Error(n(426));
            }
          } else if (Ge && T.mode & 1) {
            var ot = S0(k);
            if (ot !== null) {
              !(ot.flags & 65536) && (ot.flags |= 256),
                C0(ot, k, T, w, a),
                ip(ms(P, T));
              break e;
            }
          }
          (w = P = ms(P, T)),
            ut !== 4 && (ut = 2),
            jl === null ? (jl = [w]) : jl.push(w),
            (w = k);
          do {
            switch (w.tag) {
              case 3:
                (w.flags |= 65536), (a &= -a), (w.lanes |= a);
                var _ = w0(w, P, a);
                Kv(w, _);
                break e;
              case 1:
                T = P;
                var L = w.type,
                  z = w.stateNode;
                if (
                  !(w.flags & 128) &&
                  (typeof L.getDerivedStateFromError == "function" ||
                    (z !== null &&
                      typeof z.componentDidCatch == "function" &&
                      (fo === null || !fo.has(z))))
                ) {
                  (w.flags |= 65536), (a &= -a), (w.lanes |= a);
                  var te = x0(w, T, a);
                  Kv(w, te);
                  break e;
                }
            }
            w = w.return;
          } while (w !== null);
        }
        e1(d);
      } catch (ve) {
        (a = ve), it === d && d !== null && (it = d = d.return);
        continue;
      }
      break;
    } while (!0);
  }
  function X0() {
    var s = Vu.current;
    return (Vu.current = _u), s === null ? _u : s;
  }
  function Gp() {
    (ut === 0 || ut === 3 || ut === 2) && (ut = 4),
      mt === null || (!(hi & 268435455) && !(Wu & 268435455)) || mo(mt, St);
  }
  function Qu(s, a) {
    var d = Fe;
    Fe |= 2;
    var h = X0();
    (mt !== s || St !== a) && ((Lr = null), gi(s, a));
    do
      try {
        X2();
        break;
      } catch (g) {
        Y0(s, g);
      }
    while (!0);
    if ((lp(), (Fe = d), (Vu.current = h), it !== null)) throw Error(n(261));
    return (mt = null), (St = 0), ut;
  }
  function X2() {
    for (; it !== null; ) Z0(it);
  }
  function Z2() {
    for (; it !== null && !kM(); ) Z0(it);
  }
  function Z0(s) {
    var a = r1(s.alternate, s, dn);
    (s.memoizedProps = s.pendingProps),
      a === null ? e1(s) : (it = a),
      (zp.current = null);
  }
  function e1(s) {
    var a = s;
    do {
      var d = a.alternate;
      if (((s = a.return), a.flags & 32768)) {
        if (((d = K2(d, a)), d !== null)) {
          (d.flags &= 32767), (it = d);
          return;
        }
        if (s !== null)
          (s.flags |= 32768), (s.subtreeFlags = 0), (s.deletions = null);
        else {
          (ut = 6), (it = null);
          return;
        }
      } else if (((d = U2(d, a, dn)), d !== null)) {
        it = d;
        return;
      }
      if (((a = a.sibling), a !== null)) {
        it = a;
        return;
      }
      it = a = s;
    } while (a !== null);
    ut === 0 && (ut = 5);
  }
  function yi(s, a, d) {
    var h = je,
      g = Sn.transition;
    try {
      (Sn.transition = null), (je = 1), eO(s, a, d, h);
    } finally {
      (Sn.transition = g), (je = h);
    }
    return null;
  }
  function eO(s, a, d, h) {
    do ws();
    while (po !== null);
    if (Fe & 6) throw Error(n(327));
    d = s.finishedWork;
    var g = s.finishedLanes;
    if (d === null) return null;
    if (((s.finishedWork = null), (s.finishedLanes = 0), d === s.current))
      throw Error(n(177));
    (s.callbackNode = null), (s.callbackPriority = 0);
    var w = d.lanes | d.childLanes;
    if (
      (IM(s, w),
      s === mt && ((it = mt = null), (St = 0)),
      (!(d.subtreeFlags & 2064) && !(d.flags & 2064)) ||
        Ku ||
        ((Ku = !0),
        o1(eu, function () {
          return ws(), null;
        })),
      (w = (d.flags & 15990) !== 0),
      d.subtreeFlags & 15990 || w)
    ) {
      (w = Sn.transition), (Sn.transition = null);
      var k = je;
      je = 1;
      var T = Fe;
      (Fe |= 4),
        (zp.current = null),
        G2(s, d),
        W0(d, s),
        x2(Gf),
        (lu = !!qf),
        (Gf = qf = null),
        (s.current = d),
        J2(d),
        EM(),
        (Fe = T),
        (je = k),
        (Sn.transition = w);
    } else s.current = d;
    if (
      (Ku && ((Ku = !1), (po = s), (qu = g)),
      (w = s.pendingLanes),
      w === 0 && (fo = null),
      TM(d.stateNode),
      Yt(s, rt()),
      a !== null)
    )
      for (h = s.onRecoverableError, d = 0; d < a.length; d++)
        (g = a[d]), h(g.value, { componentStack: g.stack, digest: g.digest });
    if (Uu) throw ((Uu = !1), (s = Hp), (Hp = null), s);
    return (
      qu & 1 && s.tag !== 0 && ws(),
      (w = s.pendingLanes),
      w & 1 ? (s === Vp ? Bl++ : ((Bl = 0), (Vp = s))) : (Bl = 0),
      lo(),
      null
    );
  }
  function ws() {
    if (po !== null) {
      var s = Hy(qu),
        a = Sn.transition,
        d = je;
      try {
        if (((Sn.transition = null), (je = 16 > s ? 16 : s), po === null))
          var h = !1;
        else {
          if (((s = po), (po = null), (qu = 0), Fe & 6)) throw Error(n(331));
          var g = Fe;
          for (Fe |= 4, fe = s.current; fe !== null; ) {
            var w = fe,
              k = w.child;
            if (fe.flags & 16) {
              var T = w.deletions;
              if (T !== null) {
                for (var P = 0; P < T.length; P++) {
                  var j = T[P];
                  for (fe = j; fe !== null; ) {
                    var G = fe;
                    switch (G.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Fl(8, G, w);
                    }
                    var Y = G.child;
                    if (Y !== null) (Y.return = G), (fe = Y);
                    else
                      for (; fe !== null; ) {
                        G = fe;
                        var q = G.sibling,
                          ue = G.return;
                        if ((z0(G), G === j)) {
                          fe = null;
                          break;
                        }
                        if (q !== null) {
                          (q.return = ue), (fe = q);
                          break;
                        }
                        fe = ue;
                      }
                  }
                }
                var pe = w.alternate;
                if (pe !== null) {
                  var ye = pe.child;
                  if (ye !== null) {
                    pe.child = null;
                    do {
                      var ot = ye.sibling;
                      (ye.sibling = null), (ye = ot);
                    } while (ye !== null);
                  }
                }
                fe = w;
              }
            }
            if (w.subtreeFlags & 2064 && k !== null) (k.return = w), (fe = k);
            else
              e: for (; fe !== null; ) {
                if (((w = fe), w.flags & 2048))
                  switch (w.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Fl(9, w, w.return);
                  }
                var _ = w.sibling;
                if (_ !== null) {
                  (_.return = w.return), (fe = _);
                  break e;
                }
                fe = w.return;
              }
          }
          var L = s.current;
          for (fe = L; fe !== null; ) {
            k = fe;
            var z = k.child;
            if (k.subtreeFlags & 2064 && z !== null) (z.return = k), (fe = z);
            else
              e: for (k = L; fe !== null; ) {
                if (((T = fe), T.flags & 2048))
                  try {
                    switch (T.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Hu(9, T);
                    }
                  } catch (ve) {
                    Ye(T, T.return, ve);
                  }
                if (T === k) {
                  fe = null;
                  break e;
                }
                var te = T.sibling;
                if (te !== null) {
                  (te.return = T.return), (fe = te);
                  break e;
                }
                fe = T.return;
              }
          }
          if (
            ((Fe = g),
            lo(),
            ir && typeof ir.onPostCommitFiberRoot == "function")
          )
            try {
              ir.onPostCommitFiberRoot(tu, s);
            } catch {}
          h = !0;
        }
        return h;
      } finally {
        (je = d), (Sn.transition = a);
      }
    }
    return !1;
  }
  function t1(s, a, d) {
    (a = ms(d, a)),
      (a = w0(s, a, 1)),
      (s = uo(s, a, 1)),
      (a = zt()),
      s !== null && (dl(s, 1, a), Yt(s, a));
  }
  function Ye(s, a, d) {
    if (s.tag === 3) t1(s, s, d);
    else
      for (; a !== null; ) {
        if (a.tag === 3) {
          t1(a, s, d);
          break;
        } else if (a.tag === 1) {
          var h = a.stateNode;
          if (
            typeof a.type.getDerivedStateFromError == "function" ||
            (typeof h.componentDidCatch == "function" &&
              (fo === null || !fo.has(h)))
          ) {
            (s = ms(d, s)),
              (s = x0(a, s, 1)),
              (a = uo(a, s, 1)),
              (s = zt()),
              a !== null && (dl(a, 1, s), Yt(a, s));
            break;
          }
        }
        a = a.return;
      }
  }
  function tO(s, a, d) {
    var h = s.pingCache;
    h !== null && h.delete(a),
      (a = zt()),
      (s.pingedLanes |= s.suspendedLanes & d),
      mt === s &&
        (St & d) === d &&
        (ut === 4 || (ut === 3 && (St & 130023424) === St && 500 > rt() - Bp)
          ? gi(s, 0)
          : (jp |= d)),
      Yt(s, a);
  }
  function n1(s, a) {
    a === 0 &&
      (s.mode & 1
        ? ((a = ru), (ru <<= 1), !(ru & 130023424) && (ru = 4194304))
        : (a = 1));
    var d = zt();
    (s = Pr(s, a)), s !== null && (dl(s, a, d), Yt(s, d));
  }
  function nO(s) {
    var a = s.memoizedState,
      d = 0;
    a !== null && (d = a.retryLane), n1(s, d);
  }
  function rO(s, a) {
    var d = 0;
    switch (s.tag) {
      case 13:
        var h = s.stateNode,
          g = s.memoizedState;
        g !== null && (d = g.retryLane);
        break;
      case 19:
        h = s.stateNode;
        break;
      default:
        throw Error(n(314));
    }
    h !== null && h.delete(a), n1(s, d);
  }
  var r1;
  r1 = function (s, a, d) {
    if (s !== null)
      if (s.memoizedProps !== a.pendingProps || qt.current) Jt = !0;
      else {
        if (!(s.lanes & d) && !(a.flags & 128)) return (Jt = !1), W2(s, a, d);
        Jt = !!(s.flags & 131072);
      }
    else (Jt = !1), Ge && a.flags & 1048576 && $v(a, Eu, a.index);
    switch (((a.lanes = 0), a.tag)) {
      case 2:
        var h = a.type;
        ju(s, a), (s = a.pendingProps);
        var g = ls(a, Tt.current);
        ps(a, d), (g = vp(null, a, h, s, g, d));
        var w = wp();
        return (
          (a.flags |= 1),
          typeof g == "object" &&
          g !== null &&
          typeof g.render == "function" &&
          g.$$typeof === void 0
            ? ((a.tag = 1),
              (a.memoizedState = null),
              (a.updateQueue = null),
              Gt(h) ? ((w = !0), Su(a)) : (w = !1),
              (a.memoizedState =
                g.state !== null && g.state !== void 0 ? g.state : null),
              dp(a),
              (g.updater = Fu),
              (a.stateNode = g),
              (g._reactInternals = a),
              Ep(a, h, s, d),
              (a = Np(null, a, h, !0, w, d)))
            : ((a.tag = 0), Ge && w && tp(a), Ft(null, a, g, d), (a = a.child)),
          a
        );
      case 16:
        h = a.elementType;
        e: {
          switch (
            (ju(s, a),
            (s = a.pendingProps),
            (g = h._init),
            (h = g(h._payload)),
            (a.type = h),
            (g = a.tag = iO(h)),
            (s = Bn(h, s)),
            g)
          ) {
            case 0:
              a = Tp(null, a, h, s, d);
              break e;
            case 1:
              a = N0(null, a, h, s, d);
              break e;
            case 11:
              a = k0(null, a, h, s, d);
              break e;
            case 14:
              a = E0(null, a, h, Bn(h.type, s), d);
              break e;
          }
          throw Error(n(306, h, ""));
        }
        return a;
      case 0:
        return (
          (h = a.type),
          (g = a.pendingProps),
          (g = a.elementType === h ? g : Bn(h, g)),
          Tp(s, a, h, g, d)
        );
      case 1:
        return (
          (h = a.type),
          (g = a.pendingProps),
          (g = a.elementType === h ? g : Bn(h, g)),
          N0(s, a, h, g, d)
        );
      case 3:
        e: {
          if ((A0(a), s === null)) throw Error(n(387));
          (h = a.pendingProps),
            (w = a.memoizedState),
            (g = w.element),
            Uv(s, a),
            Ru(a, h, null, d);
          var k = a.memoizedState;
          if (((h = k.element), w.isDehydrated))
            if (
              ((w = {
                element: h,
                isDehydrated: !1,
                cache: k.cache,
                pendingSuspenseBoundaries: k.pendingSuspenseBoundaries,
                transitions: k.transitions,
              }),
              (a.updateQueue.baseState = w),
              (a.memoizedState = w),
              a.flags & 256)
            ) {
              (g = ms(Error(n(423)), a)), (a = R0(s, a, h, d, g));
              break e;
            } else if (h !== g) {
              (g = ms(Error(n(424)), a)), (a = R0(s, a, h, d, g));
              break e;
            } else
              for (
                cn = oo(a.stateNode.containerInfo.firstChild),
                  un = a,
                  Ge = !0,
                  jn = null,
                  d = Vv(a, null, h, d),
                  a.child = d;
                d;

              )
                (d.flags = (d.flags & -3) | 4096), (d = d.sibling);
          else {
            if ((cs(), h === g)) {
              a = Ir(s, a, d);
              break e;
            }
            Ft(s, a, h, d);
          }
          a = a.child;
        }
        return a;
      case 5:
        return (
          Gv(a),
          s === null && op(a),
          (h = a.type),
          (g = a.pendingProps),
          (w = s !== null ? s.memoizedProps : null),
          (k = g.children),
          Jf(h, g) ? (k = null) : w !== null && Jf(h, w) && (a.flags |= 32),
          T0(s, a),
          Ft(s, a, k, d),
          a.child
        );
      case 6:
        return s === null && op(a), null;
      case 13:
        return P0(s, a, d);
      case 4:
        return (
          fp(a, a.stateNode.containerInfo),
          (h = a.pendingProps),
          s === null ? (a.child = ds(a, null, h, d)) : Ft(s, a, h, d),
          a.child
        );
      case 11:
        return (
          (h = a.type),
          (g = a.pendingProps),
          (g = a.elementType === h ? g : Bn(h, g)),
          k0(s, a, h, g, d)
        );
      case 7:
        return Ft(s, a, a.pendingProps, d), a.child;
      case 8:
        return Ft(s, a, a.pendingProps.children, d), a.child;
      case 12:
        return Ft(s, a, a.pendingProps.children, d), a.child;
      case 10:
        e: {
          if (
            ((h = a.type._context),
            (g = a.pendingProps),
            (w = a.memoizedProps),
            (k = g.value),
            Ve(Tu, h._currentValue),
            (h._currentValue = k),
            w !== null)
          )
            if (zn(w.value, k)) {
              if (w.children === g.children && !qt.current) {
                a = Ir(s, a, d);
                break e;
              }
            } else
              for (w = a.child, w !== null && (w.return = a); w !== null; ) {
                var T = w.dependencies;
                if (T !== null) {
                  k = w.child;
                  for (var P = T.firstContext; P !== null; ) {
                    if (P.context === h) {
                      if (w.tag === 1) {
                        (P = Dr(-1, d & -d)), (P.tag = 2);
                        var j = w.updateQueue;
                        if (j !== null) {
                          j = j.shared;
                          var G = j.pending;
                          G === null
                            ? (P.next = P)
                            : ((P.next = G.next), (G.next = P)),
                            (j.pending = P);
                        }
                      }
                      (w.lanes |= d),
                        (P = w.alternate),
                        P !== null && (P.lanes |= d),
                        up(w.return, d, a),
                        (T.lanes |= d);
                      break;
                    }
                    P = P.next;
                  }
                } else if (w.tag === 10) k = w.type === a.type ? null : w.child;
                else if (w.tag === 18) {
                  if (((k = w.return), k === null)) throw Error(n(341));
                  (k.lanes |= d),
                    (T = k.alternate),
                    T !== null && (T.lanes |= d),
                    up(k, d, a),
                    (k = w.sibling);
                } else k = w.child;
                if (k !== null) k.return = w;
                else
                  for (k = w; k !== null; ) {
                    if (k === a) {
                      k = null;
                      break;
                    }
                    if (((w = k.sibling), w !== null)) {
                      (w.return = k.return), (k = w);
                      break;
                    }
                    k = k.return;
                  }
                w = k;
              }
          Ft(s, a, g.children, d), (a = a.child);
        }
        return a;
      case 9:
        return (
          (g = a.type),
          (h = a.pendingProps.children),
          ps(a, d),
          (g = xn(g)),
          (h = h(g)),
          (a.flags |= 1),
          Ft(s, a, h, d),
          a.child
        );
      case 14:
        return (
          (h = a.type),
          (g = Bn(h, a.pendingProps)),
          (g = Bn(h.type, g)),
          E0(s, a, h, g, d)
        );
      case 15:
        return M0(s, a, a.type, a.pendingProps, d);
      case 17:
        return (
          (h = a.type),
          (g = a.pendingProps),
          (g = a.elementType === h ? g : Bn(h, g)),
          ju(s, a),
          (a.tag = 1),
          Gt(h) ? ((s = !0), Su(a)) : (s = !1),
          ps(a, d),
          y0(a, h, g),
          Ep(a, h, g, d),
          Np(null, a, h, !0, s, d)
        );
      case 19:
        return I0(s, a, d);
      case 22:
        return O0(s, a, d);
    }
    throw Error(n(156, a.tag));
  };
  function o1(s, a) {
    return _y(s, a);
  }
  function oO(s, a, d, h) {
    (this.tag = s),
      (this.key = d),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.ref = null),
      (this.pendingProps = a),
      (this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null),
      (this.mode = h),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null);
  }
  function Cn(s, a, d, h) {
    return new oO(s, a, d, h);
  }
  function Jp(s) {
    return (s = s.prototype), !(!s || !s.isReactComponent);
  }
  function iO(s) {
    if (typeof s == "function") return Jp(s) ? 1 : 0;
    if (s != null) {
      if (((s = s.$$typeof), s === ee)) return 11;
      if (s === xe) return 14;
    }
    return 2;
  }
  function go(s, a) {
    var d = s.alternate;
    return (
      d === null
        ? ((d = Cn(s.tag, a, s.key, s.mode)),
          (d.elementType = s.elementType),
          (d.type = s.type),
          (d.stateNode = s.stateNode),
          (d.alternate = s),
          (s.alternate = d))
        : ((d.pendingProps = a),
          (d.type = s.type),
          (d.flags = 0),
          (d.subtreeFlags = 0),
          (d.deletions = null)),
      (d.flags = s.flags & 14680064),
      (d.childLanes = s.childLanes),
      (d.lanes = s.lanes),
      (d.child = s.child),
      (d.memoizedProps = s.memoizedProps),
      (d.memoizedState = s.memoizedState),
      (d.updateQueue = s.updateQueue),
      (a = s.dependencies),
      (d.dependencies =
        a === null ? null : { lanes: a.lanes, firstContext: a.firstContext }),
      (d.sibling = s.sibling),
      (d.index = s.index),
      (d.ref = s.ref),
      d
    );
  }
  function Yu(s, a, d, h, g, w) {
    var k = 2;
    if (((h = s), typeof s == "function")) Jp(s) && (k = 1);
    else if (typeof s == "string") k = 5;
    else
      e: switch (s) {
        case F:
          return vi(d.children, g, w, a);
        case H:
          (k = 8), (g |= 8);
          break;
        case U:
          return (
            (s = Cn(12, d, a, g | 2)), (s.elementType = U), (s.lanes = w), s
          );
        case le:
          return (s = Cn(13, d, a, g)), (s.elementType = le), (s.lanes = w), s;
        case de:
          return (s = Cn(19, d, a, g)), (s.elementType = de), (s.lanes = w), s;
        case se:
          return Xu(d, g, w, a);
        default:
          if (typeof s == "object" && s !== null)
            switch (s.$$typeof) {
              case re:
                k = 10;
                break e;
              case ce:
                k = 9;
                break e;
              case ee:
                k = 11;
                break e;
              case xe:
                k = 14;
                break e;
              case oe:
                (k = 16), (h = null);
                break e;
            }
          throw Error(n(130, s == null ? s : typeof s, ""));
      }
    return (
      (a = Cn(k, d, a, g)), (a.elementType = s), (a.type = h), (a.lanes = w), a
    );
  }
  function vi(s, a, d, h) {
    return (s = Cn(7, s, h, a)), (s.lanes = d), s;
  }
  function Xu(s, a, d, h) {
    return (
      (s = Cn(22, s, h, a)),
      (s.elementType = se),
      (s.lanes = d),
      (s.stateNode = { isHidden: !1 }),
      s
    );
  }
  function Qp(s, a, d) {
    return (s = Cn(6, s, null, a)), (s.lanes = d), s;
  }
  function Yp(s, a, d) {
    return (
      (a = Cn(4, s.children !== null ? s.children : [], s.key, a)),
      (a.lanes = d),
      (a.stateNode = {
        containerInfo: s.containerInfo,
        pendingChildren: null,
        implementation: s.implementation,
      }),
      a
    );
  }
  function sO(s, a, d, h, g) {
    (this.tag = a),
      (this.containerInfo = s),
      (this.finishedWork =
        this.pingCache =
        this.current =
        this.pendingChildren =
          null),
      (this.timeoutHandle = -1),
      (this.callbackNode = this.pendingContext = this.context = null),
      (this.callbackPriority = 0),
      (this.eventTimes = kf(0)),
      (this.expirationTimes = kf(-1)),
      (this.entangledLanes =
        this.finishedLanes =
        this.mutableReadLanes =
        this.expiredLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = kf(0)),
      (this.identifierPrefix = h),
      (this.onRecoverableError = g),
      (this.mutableSourceEagerHydrationData = null);
  }
  function Xp(s, a, d, h, g, w, k, T, P) {
    return (
      (s = new sO(s, a, d, T, P)),
      a === 1 ? ((a = 1), w === !0 && (a |= 8)) : (a = 0),
      (w = Cn(3, null, null, a)),
      (s.current = w),
      (w.stateNode = s),
      (w.memoizedState = {
        element: h,
        isDehydrated: d,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null,
      }),
      dp(w),
      s
    );
  }
  function lO(s, a, d) {
    var h =
      3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: R,
      key: h == null ? null : "" + h,
      children: s,
      containerInfo: a,
      implementation: d,
    };
  }
  function i1(s) {
    if (!s) return so;
    s = s._reactInternals;
    e: {
      if (si(s) !== s || s.tag !== 1) throw Error(n(170));
      var a = s;
      do {
        switch (a.tag) {
          case 3:
            a = a.stateNode.context;
            break e;
          case 1:
            if (Gt(a.type)) {
              a = a.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        a = a.return;
      } while (a !== null);
      throw Error(n(171));
    }
    if (s.tag === 1) {
      var d = s.type;
      if (Gt(d)) return Dv(s, d, a);
    }
    return a;
  }
  function s1(s, a, d, h, g, w, k, T, P) {
    return (
      (s = Xp(d, h, !0, s, g, w, k, T, P)),
      (s.context = i1(null)),
      (d = s.current),
      (h = zt()),
      (g = ho(d)),
      (w = Dr(h, g)),
      (w.callback = a ?? null),
      uo(d, w, g),
      (s.current.lanes = g),
      dl(s, g, h),
      Yt(s, h),
      s
    );
  }
  function Zu(s, a, d, h) {
    var g = a.current,
      w = zt(),
      k = ho(g);
    return (
      (d = i1(d)),
      a.context === null ? (a.context = d) : (a.pendingContext = d),
      (a = Dr(w, k)),
      (a.payload = { element: s }),
      (h = h === void 0 ? null : h),
      h !== null && (a.callback = h),
      (s = uo(g, a, k)),
      s !== null && (Wn(s, g, k, w), Au(s, g, k)),
      k
    );
  }
  function ec(s) {
    if (((s = s.current), !s.child)) return null;
    switch (s.child.tag) {
      case 5:
        return s.child.stateNode;
      default:
        return s.child.stateNode;
    }
  }
  function l1(s, a) {
    if (((s = s.memoizedState), s !== null && s.dehydrated !== null)) {
      var d = s.retryLane;
      s.retryLane = d !== 0 && d < a ? d : a;
    }
  }
  function Zp(s, a) {
    l1(s, a), (s = s.alternate) && l1(s, a);
  }
  var a1 =
    typeof reportError == "function"
      ? reportError
      : function (s) {
          console.error(s);
        };
  function eh(s) {
    this._internalRoot = s;
  }
  (tc.prototype.render = eh.prototype.render =
    function (s) {
      var a = this._internalRoot;
      if (a === null) throw Error(n(409));
      Zu(s, a, null, null);
    }),
    (tc.prototype.unmount = eh.prototype.unmount =
      function () {
        var s = this._internalRoot;
        if (s !== null) {
          this._internalRoot = null;
          var a = s.containerInfo;
          mi(function () {
            Zu(null, s, null, null);
          }),
            (a[Tr] = null);
        }
      });
  function tc(s) {
    this._internalRoot = s;
  }
  tc.prototype.unstable_scheduleHydration = function (s) {
    if (s) {
      var a = Uy();
      s = { blockedOn: null, target: s, priority: a };
      for (var d = 0; d < to.length && a !== 0 && a < to[d].priority; d++);
      to.splice(d, 0, s), d === 0 && Gy(s);
    }
  };
  function th(s) {
    return !(!s || (s.nodeType !== 1 && s.nodeType !== 9 && s.nodeType !== 11));
  }
  function nc(s) {
    return !(
      !s ||
      (s.nodeType !== 1 &&
        s.nodeType !== 9 &&
        s.nodeType !== 11 &&
        (s.nodeType !== 8 || s.nodeValue !== " react-mount-point-unstable "))
    );
  }
  function u1() {}
  function aO(s, a, d, h, g) {
    if (g) {
      if (typeof h == "function") {
        var w = h;
        h = function () {
          var j = ec(k);
          w.call(j);
        };
      }
      var k = s1(a, h, s, 0, null, !1, !1, "", u1);
      return (
        (s._reactRootContainer = k),
        (s[Tr] = k.current),
        El(s.nodeType === 8 ? s.parentNode : s),
        mi(),
        k
      );
    }
    for (; (g = s.lastChild); ) s.removeChild(g);
    if (typeof h == "function") {
      var T = h;
      h = function () {
        var j = ec(P);
        T.call(j);
      };
    }
    var P = Xp(s, 0, !1, null, null, !1, !1, "", u1);
    return (
      (s._reactRootContainer = P),
      (s[Tr] = P.current),
      El(s.nodeType === 8 ? s.parentNode : s),
      mi(function () {
        Zu(a, P, d, h);
      }),
      P
    );
  }
  function rc(s, a, d, h, g) {
    var w = d._reactRootContainer;
    if (w) {
      var k = w;
      if (typeof g == "function") {
        var T = g;
        g = function () {
          var P = ec(k);
          T.call(P);
        };
      }
      Zu(a, k, s, g);
    } else k = aO(d, a, s, g, h);
    return ec(k);
  }
  (Vy = function (s) {
    switch (s.tag) {
      case 3:
        var a = s.stateNode;
        if (a.current.memoizedState.isDehydrated) {
          var d = cl(a.pendingLanes);
          d !== 0 &&
            (Ef(a, d | 1), Yt(a, rt()), !(Fe & 6) && ((vs = rt() + 500), lo()));
        }
        break;
      case 13:
        mi(function () {
          var h = Pr(s, 1);
          if (h !== null) {
            var g = zt();
            Wn(h, s, 1, g);
          }
        }),
          Zp(s, 1);
    }
  }),
    (Mf = function (s) {
      if (s.tag === 13) {
        var a = Pr(s, 134217728);
        if (a !== null) {
          var d = zt();
          Wn(a, s, 134217728, d);
        }
        Zp(s, 134217728);
      }
    }),
    (Wy = function (s) {
      if (s.tag === 13) {
        var a = ho(s),
          d = Pr(s, a);
        if (d !== null) {
          var h = zt();
          Wn(d, s, a, h);
        }
        Zp(s, a);
      }
    }),
    (Uy = function () {
      return je;
    }),
    (Ky = function (s, a) {
      var d = je;
      try {
        return (je = s), a();
      } finally {
        je = d;
      }
    }),
    (Ot = function (s, a, d) {
      switch (a) {
        case "input":
          if ((_n(s, d), (a = d.name), d.type === "radio" && a != null)) {
            for (d = s; d.parentNode; ) d = d.parentNode;
            for (
              d = d.querySelectorAll(
                "input[name=" + JSON.stringify("" + a) + '][type="radio"]'
              ),
                a = 0;
              a < d.length;
              a++
            ) {
              var h = d[a];
              if (h !== s && h.form === s.form) {
                var g = xu(h);
                if (!g) throw Error(n(90));
                tr(h), _n(h, g);
              }
            }
          }
          break;
        case "textarea":
          Qr(s, d);
          break;
        case "select":
          (a = d.value), a != null && _t(s, !!d.multiple, a, !1);
      }
    }),
    (Or = Kp),
    (Ya = mi);
  var uO = { usingClientEntryPoint: !1, Events: [Tl, is, xu, Qi, ri, Kp] },
    Hl = {
      findFiberByHostInstance: li,
      bundleType: 0,
      version: "18.3.1",
      rendererPackageName: "react-dom",
    },
    cO = {
      bundleType: Hl.bundleType,
      version: Hl.version,
      rendererPackageName: Hl.rendererPackageName,
      rendererConfig: Hl.rendererConfig,
      overrideHookState: null,
      overrideHookStateDeletePath: null,
      overrideHookStateRenamePath: null,
      overrideProps: null,
      overridePropsDeletePath: null,
      overridePropsRenamePath: null,
      setErrorHandler: null,
      setSuspenseHandler: null,
      scheduleUpdate: null,
      currentDispatcherRef: M.ReactCurrentDispatcher,
      findHostInstanceByFiber: function (s) {
        return (s = Ly(s)), s === null ? null : s.stateNode;
      },
      findFiberByHostInstance: Hl.findFiberByHostInstance,
      findHostInstancesForRefresh: null,
      scheduleRefresh: null,
      scheduleRoot: null,
      setRefreshHandler: null,
      getCurrentFiber: null,
      reconcilerVersion: "18.3.1-next-f1338f8080-20240426",
    };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var oc = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!oc.isDisabled && oc.supportsFiber)
      try {
        (tu = oc.inject(cO)), (ir = oc);
      } catch {}
  }
  return (
    (Xt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = uO),
    (Xt.createPortal = function (s, a) {
      var d =
        2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!th(a)) throw Error(n(200));
      return lO(s, a, null, d);
    }),
    (Xt.createRoot = function (s, a) {
      if (!th(s)) throw Error(n(299));
      var d = !1,
        h = "",
        g = a1;
      return (
        a != null &&
          (a.unstable_strictMode === !0 && (d = !0),
          a.identifierPrefix !== void 0 && (h = a.identifierPrefix),
          a.onRecoverableError !== void 0 && (g = a.onRecoverableError)),
        (a = Xp(s, 1, !1, null, null, d, !1, h, g)),
        (s[Tr] = a.current),
        El(s.nodeType === 8 ? s.parentNode : s),
        new eh(a)
      );
    }),
    (Xt.findDOMNode = function (s) {
      if (s == null) return null;
      if (s.nodeType === 1) return s;
      var a = s._reactInternals;
      if (a === void 0)
        throw typeof s.render == "function"
          ? Error(n(188))
          : ((s = Object.keys(s).join(",")), Error(n(268, s)));
      return (s = Ly(a)), (s = s === null ? null : s.stateNode), s;
    }),
    (Xt.flushSync = function (s) {
      return mi(s);
    }),
    (Xt.hydrate = function (s, a, d) {
      if (!nc(a)) throw Error(n(200));
      return rc(null, s, a, !0, d);
    }),
    (Xt.hydrateRoot = function (s, a, d) {
      if (!th(s)) throw Error(n(405));
      var h = (d != null && d.hydratedSources) || null,
        g = !1,
        w = "",
        k = a1;
      if (
        (d != null &&
          (d.unstable_strictMode === !0 && (g = !0),
          d.identifierPrefix !== void 0 && (w = d.identifierPrefix),
          d.onRecoverableError !== void 0 && (k = d.onRecoverableError)),
        (a = s1(a, null, s, 1, d ?? null, g, !1, w, k)),
        (s[Tr] = a.current),
        El(s),
        h)
      )
        for (s = 0; s < h.length; s++)
          (d = h[s]),
            (g = d._getVersion),
            (g = g(d._source)),
            a.mutableSourceEagerHydrationData == null
              ? (a.mutableSourceEagerHydrationData = [d, g])
              : a.mutableSourceEagerHydrationData.push(d, g);
      return new tc(a);
    }),
    (Xt.render = function (s, a, d) {
      if (!nc(a)) throw Error(n(200));
      return rc(null, s, a, !1, d);
    }),
    (Xt.unmountComponentAtNode = function (s) {
      if (!nc(s)) throw Error(n(40));
      return s._reactRootContainer
        ? (mi(function () {
            rc(null, null, s, !1, function () {
              (s._reactRootContainer = null), (s[Tr] = null);
            });
          }),
          !0)
        : !1;
    }),
    (Xt.unstable_batchedUpdates = Kp),
    (Xt.unstable_renderSubtreeIntoContainer = function (s, a, d, h) {
      if (!nc(d)) throw Error(n(200));
      if (s == null || s._reactInternals === void 0) throw Error(n(38));
      return rc(s, a, d, !1, h);
    }),
    (Xt.version = "18.3.1-next-f1338f8080-20240426"),
    Xt
  );
}
var y1;
function Qx() {
  if (y1) return oh.exports;
  y1 = 1;
  function t() {
    if (
      !(
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
      )
    )
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t);
      } catch (e) {
        console.error(e);
      }
  }
  return t(), (oh.exports = vO()), oh.exports;
}
var v1;
function wO() {
  if (v1) return ic;
  v1 = 1;
  var t = Qx();
  return (ic.createRoot = t.createRoot), (ic.hydrateRoot = t.hydrateRoot), ic;
}
var xO = wO(),
  b = tg();
const Le = Jx(b),
  Yx = fO({ __proto__: null, default: Le }, [b]),
  bO = b.createContext({});
function SO({ children: t }) {
  const [e, n] = b.useState(""),
    r = { exemplo: e, setExemplo: n };
  return O.jsx(bO.Provider, { value: r, children: t });
}
function Ct(t) {
  this.content = t;
}
Ct.prototype = {
  constructor: Ct,
  find: function (t) {
    for (var e = 0; e < this.content.length; e += 2)
      if (this.content[e] === t) return e;
    return -1;
  },
  get: function (t) {
    var e = this.find(t);
    return e == -1 ? void 0 : this.content[e + 1];
  },
  update: function (t, e, n) {
    var r = n && n != t ? this.remove(n) : this,
      o = r.find(t),
      i = r.content.slice();
    return (
      o == -1 ? i.push(n || t, e) : ((i[o + 1] = e), n && (i[o] = n)), new Ct(i)
    );
  },
  remove: function (t) {
    var e = this.find(t);
    if (e == -1) return this;
    var n = this.content.slice();
    return n.splice(e, 2), new Ct(n);
  },
  addToStart: function (t, e) {
    return new Ct([t, e].concat(this.remove(t).content));
  },
  addToEnd: function (t, e) {
    var n = this.remove(t).content.slice();
    return n.push(t, e), new Ct(n);
  },
  addBefore: function (t, e, n) {
    var r = this.remove(e),
      o = r.content.slice(),
      i = r.find(t);
    return o.splice(i == -1 ? o.length : i, 0, e, n), new Ct(o);
  },
  forEach: function (t) {
    for (var e = 0; e < this.content.length; e += 2)
      t(this.content[e], this.content[e + 1]);
  },
  prepend: function (t) {
    return (
      (t = Ct.from(t)),
      t.size ? new Ct(t.content.concat(this.subtract(t).content)) : this
    );
  },
  append: function (t) {
    return (
      (t = Ct.from(t)),
      t.size ? new Ct(this.subtract(t).content.concat(t.content)) : this
    );
  },
  subtract: function (t) {
    var e = this;
    t = Ct.from(t);
    for (var n = 0; n < t.content.length; n += 2) e = e.remove(t.content[n]);
    return e;
  },
  toObject: function () {
    var t = {};
    return (
      this.forEach(function (e, n) {
        t[e] = n;
      }),
      t
    );
  },
  get size() {
    return this.content.length >> 1;
  },
};
Ct.from = function (t) {
  if (t instanceof Ct) return t;
  var e = [];
  if (t) for (var n in t) e.push(n, t[n]);
  return new Ct(e);
};
function Xx(t, e, n) {
  for (let r = 0; ; r++) {
    if (r == t.childCount || r == e.childCount)
      return t.childCount == e.childCount ? null : n;
    let o = t.child(r),
      i = e.child(r);
    if (o == i) {
      n += o.nodeSize;
      continue;
    }
    if (!o.sameMarkup(i)) return n;
    if (o.isText && o.text != i.text) {
      for (let l = 0; o.text[l] == i.text[l]; l++) n++;
      return n;
    }
    if (o.content.size || i.content.size) {
      let l = Xx(o.content, i.content, n + 1);
      if (l != null) return l;
    }
    n += o.nodeSize;
  }
}
function Zx(t, e, n, r) {
  for (let o = t.childCount, i = e.childCount; ; ) {
    if (o == 0 || i == 0) return o == i ? null : { a: n, b: r };
    let l = t.child(--o),
      u = e.child(--i),
      c = l.nodeSize;
    if (l == u) {
      (n -= c), (r -= c);
      continue;
    }
    if (!l.sameMarkup(u)) return { a: n, b: r };
    if (l.isText && l.text != u.text) {
      let f = 0,
        p = Math.min(l.text.length, u.text.length);
      for (
        ;
        f < p && l.text[l.text.length - f - 1] == u.text[u.text.length - f - 1];

      )
        f++, n--, r--;
      return { a: n, b: r };
    }
    if (l.content.size || u.content.size) {
      let f = Zx(l.content, u.content, n - 1, r - 1);
      if (f) return f;
    }
    (n -= c), (r -= c);
  }
}
class J {
  constructor(e, n) {
    if (((this.content = e), (this.size = n || 0), n == null))
      for (let r = 0; r < e.length; r++) this.size += e[r].nodeSize;
  }
  nodesBetween(e, n, r, o = 0, i) {
    for (let l = 0, u = 0; u < n; l++) {
      let c = this.content[l],
        f = u + c.nodeSize;
      if (f > e && r(c, o + u, i || null, l) !== !1 && c.content.size) {
        let p = u + 1;
        c.nodesBetween(
          Math.max(0, e - p),
          Math.min(c.content.size, n - p),
          r,
          o + p
        );
      }
      u = f;
    }
  }
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  textBetween(e, n, r, o) {
    let i = "",
      l = !0;
    return (
      this.nodesBetween(
        e,
        n,
        (u, c) => {
          let f = u.isText
            ? u.text.slice(Math.max(e, c) - c, n - c)
            : u.isLeaf
            ? o
              ? typeof o == "function"
                ? o(u)
                : o
              : u.type.spec.leafText
              ? u.type.spec.leafText(u)
              : ""
            : "";
          u.isBlock &&
            ((u.isLeaf && f) || u.isTextblock) &&
            r &&
            (l ? (l = !1) : (i += r)),
            (i += f);
        },
        0
      ),
      i
    );
  }
  append(e) {
    if (!e.size) return this;
    if (!this.size) return e;
    let n = this.lastChild,
      r = e.firstChild,
      o = this.content.slice(),
      i = 0;
    for (
      n.isText &&
      n.sameMarkup(r) &&
      ((o[o.length - 1] = n.withText(n.text + r.text)), (i = 1));
      i < e.content.length;
      i++
    )
      o.push(e.content[i]);
    return new J(o, this.size + e.size);
  }
  cut(e, n = this.size) {
    if (e == 0 && n == this.size) return this;
    let r = [],
      o = 0;
    if (n > e)
      for (let i = 0, l = 0; l < n; i++) {
        let u = this.content[i],
          c = l + u.nodeSize;
        c > e &&
          ((l < e || c > n) &&
            (u.isText
              ? (u = u.cut(Math.max(0, e - l), Math.min(u.text.length, n - l)))
              : (u = u.cut(
                  Math.max(0, e - l - 1),
                  Math.min(u.content.size, n - l - 1)
                ))),
          r.push(u),
          (o += u.nodeSize)),
          (l = c);
      }
    return new J(r, o);
  }
  cutByIndex(e, n) {
    return e == n
      ? J.empty
      : e == 0 && n == this.content.length
      ? this
      : new J(this.content.slice(e, n));
  }
  replaceChild(e, n) {
    let r = this.content[e];
    if (r == n) return this;
    let o = this.content.slice(),
      i = this.size + n.nodeSize - r.nodeSize;
    return (o[e] = n), new J(o, i);
  }
  addToStart(e) {
    return new J([e].concat(this.content), this.size + e.nodeSize);
  }
  addToEnd(e) {
    return new J(this.content.concat(e), this.size + e.nodeSize);
  }
  eq(e) {
    if (this.content.length != e.content.length) return !1;
    for (let n = 0; n < this.content.length; n++)
      if (!this.content[n].eq(e.content[n])) return !1;
    return !0;
  }
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  get childCount() {
    return this.content.length;
  }
  child(e) {
    let n = this.content[e];
    if (!n) throw new RangeError("Index " + e + " out of range for " + this);
    return n;
  }
  maybeChild(e) {
    return this.content[e] || null;
  }
  forEach(e) {
    for (let n = 0, r = 0; n < this.content.length; n++) {
      let o = this.content[n];
      e(o, r, n), (r += o.nodeSize);
    }
  }
  findDiffStart(e, n = 0) {
    return Xx(this, e, n);
  }
  findDiffEnd(e, n = this.size, r = e.size) {
    return Zx(this, e, n, r);
  }
  findIndex(e, n = -1) {
    if (e == 0) return sc(0, e);
    if (e == this.size) return sc(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let r = 0, o = 0; ; r++) {
      let i = this.child(r),
        l = o + i.nodeSize;
      if (l >= e) return l == e || n > 0 ? sc(r + 1, l) : sc(r, o);
      o = l;
    }
  }
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  toStringInner() {
    return this.content.join(", ");
  }
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  static fromJSON(e, n) {
    if (!n) return J.empty;
    if (!Array.isArray(n))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new J(n.map(e.nodeFromJSON));
  }
  static fromArray(e) {
    if (!e.length) return J.empty;
    let n,
      r = 0;
    for (let o = 0; o < e.length; o++) {
      let i = e[o];
      (r += i.nodeSize),
        o && i.isText && e[o - 1].sameMarkup(i)
          ? (n || (n = e.slice(0, o)),
            (n[n.length - 1] = i.withText(n[n.length - 1].text + i.text)))
          : n && n.push(i);
    }
    return new J(n || e, r);
  }
  static from(e) {
    if (!e) return J.empty;
    if (e instanceof J) return e;
    if (Array.isArray(e)) return this.fromArray(e);
    if (e.attrs) return new J([e], e.nodeSize);
    throw new RangeError(
      "Can not convert " +
        e +
        " to a Fragment" +
        (e.nodesBetween
          ? " (looks like multiple versions of prosemirror-model were loaded)"
          : "")
    );
  }
}
J.empty = new J([], 0);
const lh = { index: 0, offset: 0 };
function sc(t, e) {
  return (lh.index = t), (lh.offset = e), lh;
}
function Fc(t, e) {
  if (t === e) return !0;
  if (!(t && typeof t == "object") || !(e && typeof e == "object")) return !1;
  let n = Array.isArray(t);
  if (Array.isArray(e) != n) return !1;
  if (n) {
    if (t.length != e.length) return !1;
    for (let r = 0; r < t.length; r++) if (!Fc(t[r], e[r])) return !1;
  } else {
    for (let r in t) if (!(r in e) || !Fc(t[r], e[r])) return !1;
    for (let r in e) if (!(r in t)) return !1;
  }
  return !0;
}
let He = class om {
  constructor(e, n) {
    (this.type = e), (this.attrs = n);
  }
  addToSet(e) {
    let n,
      r = !1;
    for (let o = 0; o < e.length; o++) {
      let i = e[o];
      if (this.eq(i)) return e;
      if (this.type.excludes(i.type)) n || (n = e.slice(0, o));
      else {
        if (i.type.excludes(this.type)) return e;
        !r &&
          i.type.rank > this.type.rank &&
          (n || (n = e.slice(0, o)), n.push(this), (r = !0)),
          n && n.push(i);
      }
    }
    return n || (n = e.slice()), r || n.push(this), n;
  }
  removeFromSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n])) return e.slice(0, n).concat(e.slice(n + 1));
    return e;
  }
  isInSet(e) {
    for (let n = 0; n < e.length; n++) if (this.eq(e[n])) return !0;
    return !1;
  }
  eq(e) {
    return this == e || (this.type == e.type && Fc(this.attrs, e.attrs));
  }
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return e;
  }
  static fromJSON(e, n) {
    if (!n) throw new RangeError("Invalid input for Mark.fromJSON");
    let r = e.marks[n.type];
    if (!r)
      throw new RangeError(`There is no mark type ${n.type} in this schema`);
    let o = r.create(n.attrs);
    return r.checkAttrs(o.attrs), o;
  }
  static sameSet(e, n) {
    if (e == n) return !0;
    if (e.length != n.length) return !1;
    for (let r = 0; r < e.length; r++) if (!e[r].eq(n[r])) return !1;
    return !0;
  }
  static setFrom(e) {
    if (!e || (Array.isArray(e) && e.length == 0)) return om.none;
    if (e instanceof om) return [e];
    let n = e.slice();
    return n.sort((r, o) => r.type.rank - o.type.rank), n;
  }
};
He.none = [];
class zc extends Error {}
class ae {
  constructor(e, n, r) {
    (this.content = e), (this.openStart = n), (this.openEnd = r);
  }
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  insertAt(e, n) {
    let r = tb(this.content, e + this.openStart, n);
    return r && new ae(r, this.openStart, this.openEnd);
  }
  removeBetween(e, n) {
    return new ae(
      eb(this.content, e + this.openStart, n + this.openStart),
      this.openStart,
      this.openEnd
    );
  }
  eq(e) {
    return (
      this.content.eq(e.content) &&
      this.openStart == e.openStart &&
      this.openEnd == e.openEnd
    );
  }
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  toJSON() {
    if (!this.content.size) return null;
    let e = { content: this.content.toJSON() };
    return (
      this.openStart > 0 && (e.openStart = this.openStart),
      this.openEnd > 0 && (e.openEnd = this.openEnd),
      e
    );
  }
  static fromJSON(e, n) {
    if (!n) return ae.empty;
    let r = n.openStart || 0,
      o = n.openEnd || 0;
    if (typeof r != "number" || typeof o != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new ae(J.fromJSON(e, n.content), r, o);
  }
  static maxOpen(e, n = !0) {
    let r = 0,
      o = 0;
    for (
      let i = e.firstChild;
      i && !i.isLeaf && (n || !i.type.spec.isolating);
      i = i.firstChild
    )
      r++;
    for (
      let i = e.lastChild;
      i && !i.isLeaf && (n || !i.type.spec.isolating);
      i = i.lastChild
    )
      o++;
    return new ae(e, r, o);
  }
}
ae.empty = new ae(J.empty, 0, 0);
function eb(t, e, n) {
  let { index: r, offset: o } = t.findIndex(e),
    i = t.maybeChild(r),
    { index: l, offset: u } = t.findIndex(n);
  if (o == e || i.isText) {
    if (u != n && !t.child(l).isText)
      throw new RangeError("Removing non-flat range");
    return t.cut(0, e).append(t.cut(n));
  }
  if (r != l) throw new RangeError("Removing non-flat range");
  return t.replaceChild(r, i.copy(eb(i.content, e - o - 1, n - o - 1)));
}
function tb(t, e, n, r) {
  let { index: o, offset: i } = t.findIndex(e),
    l = t.maybeChild(o);
  if (i == e || l.isText) return t.cut(0, e).append(n).append(t.cut(e));
  let u = tb(l.content, e - i - 1, n);
  return u && t.replaceChild(o, l.copy(u));
}
function CO(t, e, n) {
  if (n.openStart > t.depth)
    throw new zc("Inserted content deeper than insertion position");
  if (t.depth - n.openStart != e.depth - n.openEnd)
    throw new zc("Inconsistent open depths");
  return nb(t, e, n, 0);
}
function nb(t, e, n, r) {
  let o = t.index(r),
    i = t.node(r);
  if (o == e.index(r) && r < t.depth - n.openStart) {
    let l = nb(t, e, n, r + 1);
    return i.copy(i.content.replaceChild(o, l));
  } else if (n.content.size)
    if (!n.openStart && !n.openEnd && t.depth == r && e.depth == r) {
      let l = t.parent,
        u = l.content;
      return Ni(
        l,
        u.cut(0, t.parentOffset).append(n.content).append(u.cut(e.parentOffset))
      );
    } else {
      let { start: l, end: u } = kO(n, t);
      return Ni(i, ob(t, l, u, e, r));
    }
  else return Ni(i, jc(t, e, r));
}
function rb(t, e) {
  if (!e.type.compatibleContent(t.type))
    throw new zc("Cannot join " + e.type.name + " onto " + t.type.name);
}
function im(t, e, n) {
  let r = t.node(n);
  return rb(r, e.node(n)), r;
}
function Ti(t, e) {
  let n = e.length - 1;
  n >= 0 && t.isText && t.sameMarkup(e[n])
    ? (e[n] = t.withText(e[n].text + t.text))
    : e.push(t);
}
function ta(t, e, n, r) {
  let o = (e || t).node(n),
    i = 0,
    l = e ? e.index(n) : o.childCount;
  t &&
    ((i = t.index(n)),
    t.depth > n ? i++ : t.textOffset && (Ti(t.nodeAfter, r), i++));
  for (let u = i; u < l; u++) Ti(o.child(u), r);
  e && e.depth == n && e.textOffset && Ti(e.nodeBefore, r);
}
function Ni(t, e) {
  return t.type.checkContent(e), t.copy(e);
}
function ob(t, e, n, r, o) {
  let i = t.depth > o && im(t, e, o + 1),
    l = r.depth > o && im(n, r, o + 1),
    u = [];
  return (
    ta(null, t, o, u),
    i && l && e.index(o) == n.index(o)
      ? (rb(i, l), Ti(Ni(i, ob(t, e, n, r, o + 1)), u))
      : (i && Ti(Ni(i, jc(t, e, o + 1)), u),
        ta(e, n, o, u),
        l && Ti(Ni(l, jc(n, r, o + 1)), u)),
    ta(r, null, o, u),
    new J(u)
  );
}
function jc(t, e, n) {
  let r = [];
  if ((ta(null, t, n, r), t.depth > n)) {
    let o = im(t, e, n + 1);
    Ti(Ni(o, jc(t, e, n + 1)), r);
  }
  return ta(e, null, n, r), new J(r);
}
function kO(t, e) {
  let n = e.depth - t.openStart,
    o = e.node(n).copy(t.content);
  for (let i = n - 1; i >= 0; i--) o = e.node(i).copy(J.from(o));
  return {
    start: o.resolveNoCache(t.openStart + n),
    end: o.resolveNoCache(o.content.size - t.openEnd - n),
  };
}
class ga {
  constructor(e, n, r) {
    (this.pos = e),
      (this.path = n),
      (this.parentOffset = r),
      (this.depth = n.length / 3 - 1);
  }
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e;
  }
  get parent() {
    return this.node(this.depth);
  }
  get doc() {
    return this.node(0);
  }
  node(e) {
    return this.path[this.resolveDepth(e) * 3];
  }
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1];
  }
  indexAfter(e) {
    return (
      (e = this.resolveDepth(e)),
      this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1)
    );
  }
  start(e) {
    return (e = this.resolveDepth(e)), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
  }
  end(e) {
    return (
      (e = this.resolveDepth(e)), this.start(e) + this.node(e).content.size
    );
  }
  before(e) {
    if (((e = this.resolveDepth(e)), !e))
      throw new RangeError("There is no position before the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
  }
  after(e) {
    if (((e = this.resolveDepth(e)), !e))
      throw new RangeError("There is no position after the top-level node");
    return e == this.depth + 1
      ? this.pos
      : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
  }
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  get nodeAfter() {
    let e = this.parent,
      n = this.index(this.depth);
    if (n == e.childCount) return null;
    let r = this.pos - this.path[this.path.length - 1],
      o = e.child(n);
    return r ? e.child(n).cut(r) : o;
  }
  get nodeBefore() {
    let e = this.index(this.depth),
      n = this.pos - this.path[this.path.length - 1];
    return n
      ? this.parent.child(e).cut(0, n)
      : e == 0
      ? null
      : this.parent.child(e - 1);
  }
  posAtIndex(e, n) {
    n = this.resolveDepth(n);
    let r = this.path[n * 3],
      o = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
    for (let i = 0; i < e; i++) o += r.child(i).nodeSize;
    return o;
  }
  marks() {
    let e = this.parent,
      n = this.index();
    if (e.content.size == 0) return He.none;
    if (this.textOffset) return e.child(n).marks;
    let r = e.maybeChild(n - 1),
      o = e.maybeChild(n);
    if (!r) {
      let u = r;
      (r = o), (o = u);
    }
    let i = r.marks;
    for (var l = 0; l < i.length; l++)
      i[l].type.spec.inclusive === !1 &&
        (!o || !i[l].isInSet(o.marks)) &&
        (i = i[l--].removeFromSet(i));
    return i;
  }
  marksAcross(e) {
    let n = this.parent.maybeChild(this.index());
    if (!n || !n.isInline) return null;
    let r = n.marks,
      o = e.parent.maybeChild(e.index());
    for (var i = 0; i < r.length; i++)
      r[i].type.spec.inclusive === !1 &&
        (!o || !r[i].isInSet(o.marks)) &&
        (r = r[i--].removeFromSet(r));
    return r;
  }
  sharedDepth(e) {
    for (let n = this.depth; n > 0; n--)
      if (this.start(n) <= e && this.end(n) >= e) return n;
    return 0;
  }
  blockRange(e = this, n) {
    if (e.pos < this.pos) return e.blockRange(this);
    for (
      let r =
        this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0);
      r >= 0;
      r--
    )
      if (e.pos <= this.end(r) && (!n || n(this.node(r))))
        return new Bc(this, e, r);
    return null;
  }
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset;
  }
  max(e) {
    return e.pos > this.pos ? e : this;
  }
  min(e) {
    return e.pos < this.pos ? e : this;
  }
  toString() {
    let e = "";
    for (let n = 1; n <= this.depth; n++)
      e += (e ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1);
    return e + ":" + this.parentOffset;
  }
  static resolve(e, n) {
    if (!(n >= 0 && n <= e.content.size))
      throw new RangeError("Position " + n + " out of range");
    let r = [],
      o = 0,
      i = n;
    for (let l = e; ; ) {
      let { index: u, offset: c } = l.content.findIndex(i),
        f = i - c;
      if ((r.push(l, u, o + c), !f || ((l = l.child(u)), l.isText))) break;
      (i = f - 1), (o += c + 1);
    }
    return new ga(n, r, i);
  }
  static resolveCached(e, n) {
    let r = w1.get(e);
    if (r)
      for (let i = 0; i < r.elts.length; i++) {
        let l = r.elts[i];
        if (l.pos == n) return l;
      }
    else w1.set(e, (r = new EO()));
    let o = (r.elts[r.i] = ga.resolve(e, n));
    return (r.i = (r.i + 1) % MO), o;
  }
}
class EO {
  constructor() {
    (this.elts = []), (this.i = 0);
  }
}
const MO = 12,
  w1 = new WeakMap();
class Bc {
  constructor(e, n, r) {
    (this.$from = e), (this.$to = n), (this.depth = r);
  }
  get start() {
    return this.$from.before(this.depth + 1);
  }
  get end() {
    return this.$to.after(this.depth + 1);
  }
  get parent() {
    return this.$from.node(this.depth);
  }
  get startIndex() {
    return this.$from.index(this.depth);
  }
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const OO = Object.create(null);
let $o = class sm {
  constructor(e, n, r, o = He.none) {
    (this.type = e),
      (this.attrs = n),
      (this.marks = o),
      (this.content = r || J.empty);
  }
  get children() {
    return this.content.content;
  }
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  get childCount() {
    return this.content.childCount;
  }
  child(e) {
    return this.content.child(e);
  }
  maybeChild(e) {
    return this.content.maybeChild(e);
  }
  forEach(e) {
    this.content.forEach(e);
  }
  nodesBetween(e, n, r, o = 0) {
    this.content.nodesBetween(e, n, r, o, this);
  }
  descendants(e) {
    this.nodesBetween(0, this.content.size, e);
  }
  get textContent() {
    return this.isLeaf && this.type.spec.leafText
      ? this.type.spec.leafText(this)
      : this.textBetween(0, this.content.size, "");
  }
  textBetween(e, n, r, o) {
    return this.content.textBetween(e, n, r, o);
  }
  get firstChild() {
    return this.content.firstChild;
  }
  get lastChild() {
    return this.content.lastChild;
  }
  eq(e) {
    return this == e || (this.sameMarkup(e) && this.content.eq(e.content));
  }
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks);
  }
  hasMarkup(e, n, r) {
    return (
      this.type == e &&
      Fc(this.attrs, n || e.defaultAttrs || OO) &&
      He.sameSet(this.marks, r || He.none)
    );
  }
  copy(e = null) {
    return e == this.content
      ? this
      : new sm(this.type, this.attrs, e, this.marks);
  }
  mark(e) {
    return e == this.marks
      ? this
      : new sm(this.type, this.attrs, this.content, e);
  }
  cut(e, n = this.content.size) {
    return e == 0 && n == this.content.size
      ? this
      : this.copy(this.content.cut(e, n));
  }
  slice(e, n = this.content.size, r = !1) {
    if (e == n) return ae.empty;
    let o = this.resolve(e),
      i = this.resolve(n),
      l = r ? 0 : o.sharedDepth(n),
      u = o.start(l),
      f = o.node(l).content.cut(o.pos - u, i.pos - u);
    return new ae(f, o.depth - l, i.depth - l);
  }
  replace(e, n, r) {
    return CO(this.resolve(e), this.resolve(n), r);
  }
  nodeAt(e) {
    for (let n = this; ; ) {
      let { index: r, offset: o } = n.content.findIndex(e);
      if (((n = n.maybeChild(r)), !n)) return null;
      if (o == e || n.isText) return n;
      e -= o + 1;
    }
  }
  childAfter(e) {
    let { index: n, offset: r } = this.content.findIndex(e);
    return { node: this.content.maybeChild(n), index: n, offset: r };
  }
  childBefore(e) {
    if (e == 0) return { node: null, index: 0, offset: 0 };
    let { index: n, offset: r } = this.content.findIndex(e);
    if (r < e) return { node: this.content.child(n), index: n, offset: r };
    let o = this.content.child(n - 1);
    return { node: o, index: n - 1, offset: r - o.nodeSize };
  }
  resolve(e) {
    return ga.resolveCached(this, e);
  }
  resolveNoCache(e) {
    return ga.resolve(this, e);
  }
  rangeHasMark(e, n, r) {
    let o = !1;
    return (
      n > e &&
        this.nodesBetween(e, n, (i) => (r.isInSet(i.marks) && (o = !0), !o)),
      o
    );
  }
  get isBlock() {
    return this.type.isBlock;
  }
  get isTextblock() {
    return this.type.isTextblock;
  }
  get inlineContent() {
    return this.type.inlineContent;
  }
  get isInline() {
    return this.type.isInline;
  }
  get isText() {
    return this.type.isText;
  }
  get isLeaf() {
    return this.type.isLeaf;
  }
  get isAtom() {
    return this.type.isAtom;
  }
  toString() {
    if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);
    let e = this.type.name;
    return (
      this.content.size && (e += "(" + this.content.toStringInner() + ")"),
      ib(this.marks, e)
    );
  }
  contentMatchAt(e) {
    let n = this.type.contentMatch.matchFragment(this.content, 0, e);
    if (!n)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return n;
  }
  canReplace(e, n, r = J.empty, o = 0, i = r.childCount) {
    let l = this.contentMatchAt(e).matchFragment(r, o, i),
      u = l && l.matchFragment(this.content, n);
    if (!u || !u.validEnd) return !1;
    for (let c = o; c < i; c++)
      if (!this.type.allowsMarks(r.child(c).marks)) return !1;
    return !0;
  }
  canReplaceWith(e, n, r, o) {
    if (o && !this.type.allowsMarks(o)) return !1;
    let i = this.contentMatchAt(e).matchType(r),
      l = i && i.matchFragment(this.content, n);
    return l ? l.validEnd : !1;
  }
  canAppend(e) {
    return e.content.size
      ? this.canReplace(this.childCount, this.childCount, e.content)
      : this.type.compatibleContent(e.type);
  }
  check() {
    this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
    let e = He.none;
    for (let n = 0; n < this.marks.length; n++) {
      let r = this.marks[n];
      r.type.checkAttrs(r.attrs), (e = r.addToSet(e));
    }
    if (!He.sameSet(e, this.marks))
      throw new RangeError(
        `Invalid collection of marks for node ${
          this.type.name
        }: ${this.marks.map((n) => n.type.name)}`
      );
    this.content.forEach((n) => n.check());
  }
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return (
      this.content.size && (e.content = this.content.toJSON()),
      this.marks.length && (e.marks = this.marks.map((n) => n.toJSON())),
      e
    );
  }
  static fromJSON(e, n) {
    if (!n) throw new RangeError("Invalid input for Node.fromJSON");
    let r;
    if (n.marks) {
      if (!Array.isArray(n.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      r = n.marks.map(e.markFromJSON);
    }
    if (n.type == "text") {
      if (typeof n.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return e.text(n.text, r);
    }
    let o = J.fromJSON(e, n.content),
      i = e.nodeType(n.type).create(n.attrs, o, r);
    return i.type.checkAttrs(i.attrs), i;
  }
};
$o.prototype.text = void 0;
class Hc extends $o {
  constructor(e, n, r, o) {
    if ((super(e, n, null, o), !r))
      throw new RangeError("Empty text nodes are not allowed");
    this.text = r;
  }
  toString() {
    return this.type.spec.toDebugString
      ? this.type.spec.toDebugString(this)
      : ib(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(e, n) {
    return this.text.slice(e, n);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(e) {
    return e == this.marks ? this : new Hc(this.type, this.attrs, this.text, e);
  }
  withText(e) {
    return e == this.text ? this : new Hc(this.type, this.attrs, e, this.marks);
  }
  cut(e = 0, n = this.text.length) {
    return e == 0 && n == this.text.length
      ? this
      : this.withText(this.text.slice(e, n));
  }
  eq(e) {
    return this.sameMarkup(e) && this.text == e.text;
  }
  toJSON() {
    let e = super.toJSON();
    return (e.text = this.text), e;
  }
}
function ib(t, e) {
  for (let n = t.length - 1; n >= 0; n--) e = t[n].type.name + "(" + e + ")";
  return e;
}
class Ii {
  constructor(e) {
    (this.validEnd = e), (this.next = []), (this.wrapCache = []);
  }
  static parse(e, n) {
    let r = new TO(e, n);
    if (r.next == null) return Ii.empty;
    let o = sb(r);
    r.next && r.err("Unexpected trailing text");
    let i = LO(IO(o));
    return $O(i, r), i;
  }
  matchType(e) {
    for (let n = 0; n < this.next.length; n++)
      if (this.next[n].type == e) return this.next[n].next;
    return null;
  }
  matchFragment(e, n = 0, r = e.childCount) {
    let o = this;
    for (let i = n; o && i < r; i++) o = o.matchType(e.child(i).type);
    return o;
  }
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  get defaultType() {
    for (let e = 0; e < this.next.length; e++) {
      let { type: n } = this.next[e];
      if (!(n.isText || n.hasRequiredAttrs())) return n;
    }
    return null;
  }
  compatible(e) {
    for (let n = 0; n < this.next.length; n++)
      for (let r = 0; r < e.next.length; r++)
        if (this.next[n].type == e.next[r].type) return !0;
    return !1;
  }
  fillBefore(e, n = !1, r = 0) {
    let o = [this];
    function i(l, u) {
      let c = l.matchFragment(e, r);
      if (c && (!n || c.validEnd))
        return J.from(u.map((f) => f.createAndFill()));
      for (let f = 0; f < l.next.length; f++) {
        let { type: p, next: m } = l.next[f];
        if (!(p.isText || p.hasRequiredAttrs()) && o.indexOf(m) == -1) {
          o.push(m);
          let y = i(m, u.concat(p));
          if (y) return y;
        }
      }
      return null;
    }
    return i(this, []);
  }
  findWrapping(e) {
    for (let r = 0; r < this.wrapCache.length; r += 2)
      if (this.wrapCache[r] == e) return this.wrapCache[r + 1];
    let n = this.computeWrapping(e);
    return this.wrapCache.push(e, n), n;
  }
  computeWrapping(e) {
    let n = Object.create(null),
      r = [{ match: this, type: null, via: null }];
    for (; r.length; ) {
      let o = r.shift(),
        i = o.match;
      if (i.matchType(e)) {
        let l = [];
        for (let u = o; u.type; u = u.via) l.push(u.type);
        return l.reverse();
      }
      for (let l = 0; l < i.next.length; l++) {
        let { type: u, next: c } = i.next[l];
        !u.isLeaf &&
          !u.hasRequiredAttrs() &&
          !(u.name in n) &&
          (!o.type || c.validEnd) &&
          (r.push({ match: u.contentMatch, type: u, via: o }),
          (n[u.name] = !0));
      }
    }
    return null;
  }
  get edgeCount() {
    return this.next.length;
  }
  edge(e) {
    if (e >= this.next.length)
      throw new RangeError(`There's no ${e}th edge in this content match`);
    return this.next[e];
  }
  toString() {
    let e = [];
    function n(r) {
      e.push(r);
      for (let o = 0; o < r.next.length; o++)
        e.indexOf(r.next[o].next) == -1 && n(r.next[o].next);
    }
    return (
      n(this),
      e.map((r, o) => {
        let i = o + (r.validEnd ? "*" : " ") + " ";
        for (let l = 0; l < r.next.length; l++)
          i +=
            (l ? ", " : "") +
            r.next[l].type.name +
            "->" +
            e.indexOf(r.next[l].next);
        return i;
      }).join(`
`)
    );
  }
}
Ii.empty = new Ii(!0);
class TO {
  constructor(e, n) {
    (this.string = e),
      (this.nodeTypes = n),
      (this.inline = null),
      (this.pos = 0),
      (this.tokens = e.split(/\s*(?=\b|\W|$)/)),
      this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(),
      this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(e) {
    return this.next == e && (this.pos++ || !0);
  }
  err(e) {
    throw new SyntaxError(e + " (in content expression '" + this.string + "')");
  }
}
function sb(t) {
  let e = [];
  do e.push(NO(t));
  while (t.eat("|"));
  return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function NO(t) {
  let e = [];
  do e.push(AO(t));
  while (t.next && t.next != ")" && t.next != "|");
  return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function AO(t) {
  let e = DO(t);
  for (;;)
    if (t.eat("+")) e = { type: "plus", expr: e };
    else if (t.eat("*")) e = { type: "star", expr: e };
    else if (t.eat("?")) e = { type: "opt", expr: e };
    else if (t.eat("{")) e = RO(t, e);
    else break;
  return e;
}
function x1(t) {
  /\D/.test(t.next) && t.err("Expected number, got '" + t.next + "'");
  let e = Number(t.next);
  return t.pos++, e;
}
function RO(t, e) {
  let n = x1(t),
    r = n;
  return (
    t.eat(",") && (t.next != "}" ? (r = x1(t)) : (r = -1)),
    t.eat("}") || t.err("Unclosed braced range"),
    { type: "range", min: n, max: r, expr: e }
  );
}
function PO(t, e) {
  let n = t.nodeTypes,
    r = n[e];
  if (r) return [r];
  let o = [];
  for (let i in n) {
    let l = n[i];
    l.isInGroup(e) && o.push(l);
  }
  return o.length == 0 && t.err("No node type or group '" + e + "' found"), o;
}
function DO(t) {
  if (t.eat("(")) {
    let e = sb(t);
    return t.eat(")") || t.err("Missing closing paren"), e;
  } else if (/\W/.test(t.next)) t.err("Unexpected token '" + t.next + "'");
  else {
    let e = PO(t, t.next).map(
      (n) => (
        t.inline == null
          ? (t.inline = n.isInline)
          : t.inline != n.isInline && t.err("Mixing inline and block content"),
        { type: "name", value: n }
      )
    );
    return t.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
}
function IO(t) {
  let e = [[]];
  return o(i(t, 0), n()), e;
  function n() {
    return e.push([]) - 1;
  }
  function r(l, u, c) {
    let f = { term: c, to: u };
    return e[l].push(f), f;
  }
  function o(l, u) {
    l.forEach((c) => (c.to = u));
  }
  function i(l, u) {
    if (l.type == "choice")
      return l.exprs.reduce((c, f) => c.concat(i(f, u)), []);
    if (l.type == "seq")
      for (let c = 0; ; c++) {
        let f = i(l.exprs[c], u);
        if (c == l.exprs.length - 1) return f;
        o(f, (u = n()));
      }
    else if (l.type == "star") {
      let c = n();
      return r(u, c), o(i(l.expr, c), c), [r(c)];
    } else if (l.type == "plus") {
      let c = n();
      return o(i(l.expr, u), c), o(i(l.expr, c), c), [r(c)];
    } else {
      if (l.type == "opt") return [r(u)].concat(i(l.expr, u));
      if (l.type == "range") {
        let c = u;
        for (let f = 0; f < l.min; f++) {
          let p = n();
          o(i(l.expr, c), p), (c = p);
        }
        if (l.max == -1) o(i(l.expr, c), c);
        else
          for (let f = l.min; f < l.max; f++) {
            let p = n();
            r(c, p), o(i(l.expr, c), p), (c = p);
          }
        return [r(c)];
      } else {
        if (l.type == "name") return [r(u, void 0, l.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function lb(t, e) {
  return e - t;
}
function b1(t, e) {
  let n = [];
  return r(e), n.sort(lb);
  function r(o) {
    let i = t[o];
    if (i.length == 1 && !i[0].term) return r(i[0].to);
    n.push(o);
    for (let l = 0; l < i.length; l++) {
      let { term: u, to: c } = i[l];
      !u && n.indexOf(c) == -1 && r(c);
    }
  }
}
function LO(t) {
  let e = Object.create(null);
  return n(b1(t, 0));
  function n(r) {
    let o = [];
    r.forEach((l) => {
      t[l].forEach(({ term: u, to: c }) => {
        if (!u) return;
        let f;
        for (let p = 0; p < o.length; p++) o[p][0] == u && (f = o[p][1]);
        b1(t, c).forEach((p) => {
          f || o.push([u, (f = [])]), f.indexOf(p) == -1 && f.push(p);
        });
      });
    });
    let i = (e[r.join(",")] = new Ii(r.indexOf(t.length - 1) > -1));
    for (let l = 0; l < o.length; l++) {
      let u = o[l][1].sort(lb);
      i.next.push({ type: o[l][0], next: e[u.join(",")] || n(u) });
    }
    return i;
  }
}
function $O(t, e) {
  for (let n = 0, r = [t]; n < r.length; n++) {
    let o = r[n],
      i = !o.validEnd,
      l = [];
    for (let u = 0; u < o.next.length; u++) {
      let { type: c, next: f } = o.next[u];
      l.push(c.name),
        i && !(c.isText || c.hasRequiredAttrs()) && (i = !1),
        r.indexOf(f) == -1 && r.push(f);
    }
    i &&
      e.err(
        "Only non-generatable nodes (" +
          l.join(", ") +
          ") in a required position (see https://prosemirror.net/docs/guide/#generatable)"
      );
  }
}
function ab(t) {
  let e = Object.create(null);
  for (let n in t) {
    let r = t[n];
    if (!r.hasDefault) return null;
    e[n] = r.default;
  }
  return e;
}
function ub(t, e) {
  let n = Object.create(null);
  for (let r in t) {
    let o = e && e[r];
    if (o === void 0) {
      let i = t[r];
      if (i.hasDefault) o = i.default;
      else throw new RangeError("No value supplied for attribute " + r);
    }
    n[r] = o;
  }
  return n;
}
function cb(t, e, n, r) {
  for (let o in e)
    if (!(o in t))
      throw new RangeError(`Unsupported attribute ${o} for ${n} of type ${o}`);
  for (let o in t) {
    let i = t[o];
    i.validate && i.validate(e[o]);
  }
}
function db(t, e) {
  let n = Object.create(null);
  if (e) for (let r in e) n[r] = new FO(t, r, e[r]);
  return n;
}
let S1 = class fb {
  constructor(e, n, r) {
    (this.name = e),
      (this.schema = n),
      (this.spec = r),
      (this.markSet = null),
      (this.groups = r.group ? r.group.split(" ") : []),
      (this.attrs = db(e, r.attrs)),
      (this.defaultAttrs = ab(this.attrs)),
      (this.contentMatch = null),
      (this.inlineContent = null),
      (this.isBlock = !(r.inline || e == "text")),
      (this.isText = e == "text");
  }
  get isInline() {
    return !this.isBlock;
  }
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  get isLeaf() {
    return this.contentMatch == Ii.empty;
  }
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  isInGroup(e) {
    return this.groups.indexOf(e) > -1;
  }
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  hasRequiredAttrs() {
    for (let e in this.attrs) if (this.attrs[e].isRequired) return !0;
    return !1;
  }
  compatibleContent(e) {
    return this == e || this.contentMatch.compatible(e.contentMatch);
  }
  computeAttrs(e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : ub(this.attrs, e);
  }
  create(e = null, n, r) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new $o(this, this.computeAttrs(e), J.from(n), He.setFrom(r));
  }
  createChecked(e = null, n, r) {
    return (
      (n = J.from(n)),
      this.checkContent(n),
      new $o(this, this.computeAttrs(e), n, He.setFrom(r))
    );
  }
  createAndFill(e = null, n, r) {
    if (((e = this.computeAttrs(e)), (n = J.from(n)), n.size)) {
      let l = this.contentMatch.fillBefore(n);
      if (!l) return null;
      n = l.append(n);
    }
    let o = this.contentMatch.matchFragment(n),
      i = o && o.fillBefore(J.empty, !0);
    return i ? new $o(this, e, n.append(i), He.setFrom(r)) : null;
  }
  validContent(e) {
    let n = this.contentMatch.matchFragment(e);
    if (!n || !n.validEnd) return !1;
    for (let r = 0; r < e.childCount; r++)
      if (!this.allowsMarks(e.child(r).marks)) return !1;
    return !0;
  }
  checkContent(e) {
    if (!this.validContent(e))
      throw new RangeError(
        `Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`
      );
  }
  checkAttrs(e) {
    cb(this.attrs, e, "node", this.name);
  }
  allowsMarkType(e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1;
  }
  allowsMarks(e) {
    if (this.markSet == null) return !0;
    for (let n = 0; n < e.length; n++)
      if (!this.allowsMarkType(e[n].type)) return !1;
    return !0;
  }
  allowedMarks(e) {
    if (this.markSet == null) return e;
    let n;
    for (let r = 0; r < e.length; r++)
      this.allowsMarkType(e[r].type)
        ? n && n.push(e[r])
        : n || (n = e.slice(0, r));
    return n ? (n.length ? n : He.none) : e;
  }
  static compile(e, n) {
    let r = Object.create(null);
    e.forEach((i, l) => (r[i] = new fb(i, n, l)));
    let o = n.spec.topNode || "doc";
    if (!r[o])
      throw new RangeError("Schema is missing its top node type ('" + o + "')");
    if (!r.text) throw new RangeError("Every schema needs a 'text' type");
    for (let i in r.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return r;
  }
};
function _O(t, e, n) {
  let r = n.split("|");
  return (o) => {
    let i = o === null ? "null" : typeof o;
    if (r.indexOf(i) < 0)
      throw new RangeError(
        `Expected value of type ${r} for attribute ${e} on type ${t}, got ${i}`
      );
  };
}
class FO {
  constructor(e, n, r) {
    (this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default")),
      (this.default = r.default),
      (this.validate =
        typeof r.validate == "string" ? _O(e, n, r.validate) : r.validate);
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class Fd {
  constructor(e, n, r, o) {
    (this.name = e),
      (this.rank = n),
      (this.schema = r),
      (this.spec = o),
      (this.attrs = db(e, o.attrs)),
      (this.excluded = null);
    let i = ab(this.attrs);
    this.instance = i ? new He(this, i) : null;
  }
  create(e = null) {
    return !e && this.instance
      ? this.instance
      : new He(this, ub(this.attrs, e));
  }
  static compile(e, n) {
    let r = Object.create(null),
      o = 0;
    return e.forEach((i, l) => (r[i] = new Fd(i, o++, n, l))), r;
  }
  removeFromSet(e) {
    for (var n = 0; n < e.length; n++)
      e[n].type == this && ((e = e.slice(0, n).concat(e.slice(n + 1))), n--);
    return e;
  }
  isInSet(e) {
    for (let n = 0; n < e.length; n++) if (e[n].type == this) return e[n];
  }
  checkAttrs(e) {
    cb(this.attrs, e, "mark", this.name);
  }
  excludes(e) {
    return this.excluded.indexOf(e) > -1;
  }
}
class pb {
  constructor(e) {
    (this.linebreakReplacement = null), (this.cached = Object.create(null));
    let n = (this.spec = {});
    for (let o in e) n[o] = e[o];
    (n.nodes = Ct.from(e.nodes)),
      (n.marks = Ct.from(e.marks || {})),
      (this.nodes = S1.compile(this.spec.nodes, this)),
      (this.marks = Fd.compile(this.spec.marks, this));
    let r = Object.create(null);
    for (let o in this.nodes) {
      if (o in this.marks)
        throw new RangeError(o + " can not be both a node and a mark");
      let i = this.nodes[o],
        l = i.spec.content || "",
        u = i.spec.marks;
      if (
        ((i.contentMatch = r[l] || (r[l] = Ii.parse(l, this.nodes))),
        (i.inlineContent = i.contentMatch.inlineContent),
        i.spec.linebreakReplacement)
      ) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!i.isInline || !i.isLeaf)
          throw new RangeError(
            "Linebreak replacement nodes must be inline leaf nodes"
          );
        this.linebreakReplacement = i;
      }
      i.markSet =
        u == "_"
          ? null
          : u
          ? C1(this, u.split(" "))
          : u == "" || !i.inlineContent
          ? []
          : null;
    }
    for (let o in this.marks) {
      let i = this.marks[o],
        l = i.spec.excludes;
      i.excluded = l == null ? [i] : l == "" ? [] : C1(this, l.split(" "));
    }
    (this.nodeFromJSON = this.nodeFromJSON.bind(this)),
      (this.markFromJSON = this.markFromJSON.bind(this)),
      (this.topNodeType = this.nodes[this.spec.topNode || "doc"]),
      (this.cached.wrappings = Object.create(null));
  }
  node(e, n = null, r, o) {
    if (typeof e == "string") e = this.nodeType(e);
    else if (e instanceof S1) {
      if (e.schema != this)
        throw new RangeError(
          "Node type from different schema used (" + e.name + ")"
        );
    } else throw new RangeError("Invalid node type: " + e);
    return e.createChecked(n, r, o);
  }
  text(e, n) {
    let r = this.nodes.text;
    return new Hc(r, r.defaultAttrs, e, He.setFrom(n));
  }
  mark(e, n) {
    return typeof e == "string" && (e = this.marks[e]), e.create(n);
  }
  nodeFromJSON(e) {
    return $o.fromJSON(this, e);
  }
  markFromJSON(e) {
    return He.fromJSON(this, e);
  }
  nodeType(e) {
    let n = this.nodes[e];
    if (!n) throw new RangeError("Unknown node type: " + e);
    return n;
  }
}
function C1(t, e) {
  let n = [];
  for (let r = 0; r < e.length; r++) {
    let o = e[r],
      i = t.marks[o],
      l = i;
    if (i) n.push(i);
    else
      for (let u in t.marks) {
        let c = t.marks[u];
        (o == "_" ||
          (c.spec.group && c.spec.group.split(" ").indexOf(o) > -1)) &&
          n.push((l = c));
      }
    if (!l) throw new SyntaxError("Unknown mark type: '" + e[r] + "'");
  }
  return n;
}
function zO(t) {
  return t.tag != null;
}
function jO(t) {
  return t.style != null;
}
class _o {
  constructor(e, n) {
    (this.schema = e), (this.rules = n), (this.tags = []), (this.styles = []);
    let r = (this.matchedStyles = []);
    n.forEach((o) => {
      if (zO(o)) this.tags.push(o);
      else if (jO(o)) {
        let i = /[^=]*/.exec(o.style)[0];
        r.indexOf(i) < 0 && r.push(i), this.styles.push(o);
      }
    }),
      (this.normalizeLists = !this.tags.some((o) => {
        if (!/^(ul|ol)\b/.test(o.tag) || !o.node) return !1;
        let i = e.nodes[o.node];
        return i.contentMatch.matchType(i);
      }));
  }
  parse(e, n = {}) {
    let r = new E1(this, n, !1);
    return r.addAll(e, He.none, n.from, n.to), r.finish();
  }
  parseSlice(e, n = {}) {
    let r = new E1(this, n, !0);
    return r.addAll(e, He.none, n.from, n.to), ae.maxOpen(r.finish());
  }
  matchTag(e, n, r) {
    for (let o = r ? this.tags.indexOf(r) + 1 : 0; o < this.tags.length; o++) {
      let i = this.tags[o];
      if (
        VO(e, i.tag) &&
        (i.namespace === void 0 || e.namespaceURI == i.namespace) &&
        (!i.context || n.matchesContext(i.context))
      ) {
        if (i.getAttrs) {
          let l = i.getAttrs(e);
          if (l === !1) continue;
          i.attrs = l || void 0;
        }
        return i;
      }
    }
  }
  matchStyle(e, n, r, o) {
    for (
      let i = o ? this.styles.indexOf(o) + 1 : 0;
      i < this.styles.length;
      i++
    ) {
      let l = this.styles[i],
        u = l.style;
      if (
        !(
          u.indexOf(e) != 0 ||
          (l.context && !r.matchesContext(l.context)) ||
          (u.length > e.length &&
            (u.charCodeAt(e.length) != 61 || u.slice(e.length + 1) != n))
        )
      ) {
        if (l.getAttrs) {
          let c = l.getAttrs(n);
          if (c === !1) continue;
          l.attrs = c || void 0;
        }
        return l;
      }
    }
  }
  static schemaRules(e) {
    let n = [];
    function r(o) {
      let i = o.priority == null ? 50 : o.priority,
        l = 0;
      for (; l < n.length; l++) {
        let u = n[l];
        if ((u.priority == null ? 50 : u.priority) < i) break;
      }
      n.splice(l, 0, o);
    }
    for (let o in e.marks) {
      let i = e.marks[o].spec.parseDOM;
      i &&
        i.forEach((l) => {
          r((l = M1(l))), l.mark || l.ignore || l.clearMark || (l.mark = o);
        });
    }
    for (let o in e.nodes) {
      let i = e.nodes[o].spec.parseDOM;
      i &&
        i.forEach((l) => {
          r((l = M1(l))), l.node || l.ignore || l.mark || (l.node = o);
        });
    }
    return n;
  }
  static fromSchema(e) {
    return (
      e.cached.domParser || (e.cached.domParser = new _o(e, _o.schemaRules(e)))
    );
  }
}
const hb = {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    canvas: !0,
    dd: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    figcaption: !0,
    figure: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    li: !0,
    noscript: !0,
    ol: !0,
    output: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    tfoot: !0,
    ul: !0,
  },
  BO = { head: !0, noscript: !0, object: !0, script: !0, style: !0, title: !0 },
  mb = { ol: !0, ul: !0 },
  ya = 1,
  lm = 2,
  Nc = 4;
function k1(t, e, n) {
  return e != null
    ? (e ? ya : 0) | (e === "full" ? lm : 0)
    : t && t.whitespace == "pre"
    ? ya | lm
    : n & -5;
}
class lc {
  constructor(e, n, r, o, i, l) {
    (this.type = e),
      (this.attrs = n),
      (this.marks = r),
      (this.solid = o),
      (this.options = l),
      (this.content = []),
      (this.activeMarks = He.none),
      (this.match = i || (l & Nc ? null : e.contentMatch));
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type) return [];
      let n = this.type.contentMatch.fillBefore(J.from(e));
      if (n) this.match = this.type.contentMatch.matchFragment(n);
      else {
        let r = this.type.contentMatch,
          o;
        return (o = r.findWrapping(e.type)) ? ((this.match = r), o) : null;
      }
    }
    return this.match.findWrapping(e.type);
  }
  finish(e) {
    if (!(this.options & ya)) {
      let r = this.content[this.content.length - 1],
        o;
      if (r && r.isText && (o = /[ \t\r\n\u000c]+$/.exec(r.text))) {
        let i = r;
        r.text.length == o[0].length
          ? this.content.pop()
          : (this.content[this.content.length - 1] = i.withText(
              i.text.slice(0, i.text.length - o[0].length)
            ));
      }
    }
    let n = J.from(this.content);
    return (
      !e && this.match && (n = n.append(this.match.fillBefore(J.empty, !0))),
      this.type ? this.type.create(this.attrs, n, this.marks) : n
    );
  }
  inlineContext(e) {
    return this.type
      ? this.type.inlineContent
      : this.content.length
      ? this.content[0].isInline
      : e.parentNode && !hb.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
  }
}
class E1 {
  constructor(e, n, r) {
    (this.parser = e),
      (this.options = n),
      (this.isOpen = r),
      (this.open = 0),
      (this.localPreserveWS = !1);
    let o = n.topNode,
      i,
      l = k1(null, n.preserveWhitespace, 0) | (r ? Nc : 0);
    o
      ? (i = new lc(
          o.type,
          o.attrs,
          He.none,
          !0,
          n.topMatch || o.type.contentMatch,
          l
        ))
      : r
      ? (i = new lc(null, null, He.none, !0, null, l))
      : (i = new lc(e.schema.topNodeType, null, He.none, !0, null, l)),
      (this.nodes = [i]),
      (this.find = n.findPositions),
      (this.needsBlock = !1);
  }
  get top() {
    return this.nodes[this.open];
  }
  addDOM(e, n) {
    e.nodeType == 3
      ? this.addTextNode(e, n)
      : e.nodeType == 1 && this.addElement(e, n);
  }
  addTextNode(e, n) {
    let r = e.nodeValue,
      o = this.top,
      i =
        o.options & lm ? "full" : this.localPreserveWS || (o.options & ya) > 0;
    if (i === "full" || o.inlineContext(e) || /[^ \t\r\n\u000c]/.test(r)) {
      if (i)
        i !== "full"
          ? (r = r.replace(/\r?\n|\r/g, " "))
          : (r = r.replace(
              /\r\n?/g,
              `
`
            ));
      else if (
        ((r = r.replace(/[ \t\r\n\u000c]+/g, " ")),
        /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1)
      ) {
        let l = o.content[o.content.length - 1],
          u = e.previousSibling;
        (!l ||
          (u && u.nodeName == "BR") ||
          (l.isText && /[ \t\r\n\u000c]$/.test(l.text))) &&
          (r = r.slice(1));
      }
      r && this.insertNode(this.parser.schema.text(r), n), this.findInText(e);
    } else this.findInside(e);
  }
  addElement(e, n, r) {
    let o = this.localPreserveWS,
      i = this.top;
    (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) &&
      (this.localPreserveWS = !0);
    let l = e.nodeName.toLowerCase(),
      u;
    mb.hasOwnProperty(l) && this.parser.normalizeLists && HO(e);
    let c =
      (this.options.ruleFromNode && this.options.ruleFromNode(e)) ||
      (u = this.parser.matchTag(e, this, r));
    e: if (c ? c.ignore : BO.hasOwnProperty(l))
      this.findInside(e), this.ignoreFallback(e, n);
    else if (!c || c.skip || c.closeParent) {
      c && c.closeParent
        ? (this.open = Math.max(0, this.open - 1))
        : c && c.skip.nodeType && (e = c.skip);
      let f,
        p = this.needsBlock;
      if (hb.hasOwnProperty(l))
        i.content.length &&
          i.content[0].isInline &&
          this.open &&
          (this.open--, (i = this.top)),
          (f = !0),
          i.type || (this.needsBlock = !0);
      else if (!e.firstChild) {
        this.leafFallback(e, n);
        break e;
      }
      let m = c && c.skip ? n : this.readStyles(e, n);
      m && this.addAll(e, m), f && this.sync(i), (this.needsBlock = p);
    } else {
      let f = this.readStyles(e, n);
      f && this.addElementByRule(e, c, f, c.consuming === !1 ? u : void 0);
    }
    this.localPreserveWS = o;
  }
  leafFallback(e, n) {
    e.nodeName == "BR" &&
      this.top.type &&
      this.top.type.inlineContent &&
      this.addTextNode(
        e.ownerDocument.createTextNode(`
`),
        n
      );
  }
  ignoreFallback(e, n) {
    e.nodeName == "BR" &&
      (!this.top.type || !this.top.type.inlineContent) &&
      this.findPlace(this.parser.schema.text("-"), n);
  }
  readStyles(e, n) {
    let r = e.style;
    if (r && r.length)
      for (let o = 0; o < this.parser.matchedStyles.length; o++) {
        let i = this.parser.matchedStyles[o],
          l = r.getPropertyValue(i);
        if (l)
          for (let u = void 0; ; ) {
            let c = this.parser.matchStyle(i, l, this, u);
            if (!c) break;
            if (c.ignore) return null;
            if (
              (c.clearMark
                ? (n = n.filter((f) => !c.clearMark(f)))
                : (n = n.concat(
                    this.parser.schema.marks[c.mark].create(c.attrs)
                  )),
              c.consuming === !1)
            )
              u = c;
            else break;
          }
      }
    return n;
  }
  addElementByRule(e, n, r, o) {
    let i, l;
    if (n.node)
      if (((l = this.parser.schema.nodes[n.node]), l.isLeaf))
        this.insertNode(l.create(n.attrs), r) || this.leafFallback(e, r);
      else {
        let c = this.enter(l, n.attrs || null, r, n.preserveWhitespace);
        c && ((i = !0), (r = c));
      }
    else {
      let c = this.parser.schema.marks[n.mark];
      r = r.concat(c.create(n.attrs));
    }
    let u = this.top;
    if (l && l.isLeaf) this.findInside(e);
    else if (o) this.addElement(e, r, o);
    else if (n.getContent)
      this.findInside(e),
        n
          .getContent(e, this.parser.schema)
          .forEach((c) => this.insertNode(c, r));
    else {
      let c = e;
      typeof n.contentElement == "string"
        ? (c = e.querySelector(n.contentElement))
        : typeof n.contentElement == "function"
        ? (c = n.contentElement(e))
        : n.contentElement && (c = n.contentElement),
        this.findAround(e, c, !0),
        this.addAll(c, r),
        this.findAround(e, c, !1);
    }
    i && this.sync(u) && this.open--;
  }
  addAll(e, n, r, o) {
    let i = r || 0;
    for (
      let l = r ? e.childNodes[r] : e.firstChild,
        u = o == null ? null : e.childNodes[o];
      l != u;
      l = l.nextSibling, ++i
    )
      this.findAtPoint(e, i), this.addDOM(l, n);
    this.findAtPoint(e, i);
  }
  findPlace(e, n) {
    let r, o;
    for (let i = this.open; i >= 0; i--) {
      let l = this.nodes[i],
        u = l.findWrapping(e);
      if (
        (u && (!r || r.length > u.length) && ((r = u), (o = l), !u.length)) ||
        l.solid
      )
        break;
    }
    if (!r) return null;
    this.sync(o);
    for (let i = 0; i < r.length; i++) n = this.enterInner(r[i], null, n, !1);
    return n;
  }
  insertNode(e, n) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let o = this.textblockFromContext();
      o && (n = this.enterInner(o, null, n));
    }
    let r = this.findPlace(e, n);
    if (r) {
      this.closeExtra();
      let o = this.top;
      o.match && (o.match = o.match.matchType(e.type));
      let i = He.none;
      for (let l of r.concat(e.marks))
        (o.type ? o.type.allowsMarkType(l.type) : O1(l.type, e.type)) &&
          (i = l.addToSet(i));
      return o.content.push(e.mark(i)), !0;
    }
    return !1;
  }
  enter(e, n, r, o) {
    let i = this.findPlace(e.create(n), r);
    return i && (i = this.enterInner(e, n, r, !0, o)), i;
  }
  enterInner(e, n, r, o = !1, i) {
    this.closeExtra();
    let l = this.top;
    l.match = l.match && l.match.matchType(e);
    let u = k1(e, i, l.options);
    l.options & Nc && l.content.length == 0 && (u |= Nc);
    let c = He.none;
    return (
      (r = r.filter((f) =>
        (l.type ? l.type.allowsMarkType(f.type) : O1(f.type, e))
          ? ((c = f.addToSet(c)), !1)
          : !0
      )),
      this.nodes.push(new lc(e, n, c, o, null, u)),
      this.open++,
      r
    );
  }
  closeExtra(e = !1) {
    let n = this.nodes.length - 1;
    if (n > this.open) {
      for (; n > this.open; n--)
        this.nodes[n - 1].content.push(this.nodes[n].finish(e));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return (
      (this.open = 0),
      this.closeExtra(this.isOpen),
      this.nodes[0].finish(!!(this.isOpen || this.options.topOpen))
    );
  }
  sync(e) {
    for (let n = this.open; n >= 0; n--) {
      if (this.nodes[n] == e) return (this.open = n), !0;
      this.localPreserveWS && (this.nodes[n].options |= ya);
    }
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let e = 0;
    for (let n = this.open; n >= 0; n--) {
      let r = this.nodes[n].content;
      for (let o = r.length - 1; o >= 0; o--) e += r[o].nodeSize;
      n && e++;
    }
    return e;
  }
  findAtPoint(e, n) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].node == e &&
          this.find[r].offset == n &&
          (this.find[r].pos = this.currentPos);
  }
  findInside(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].pos == null &&
          e.nodeType == 1 &&
          e.contains(this.find[n].node) &&
          (this.find[n].pos = this.currentPos);
  }
  findAround(e, n, r) {
    if (e != n && this.find)
      for (let o = 0; o < this.find.length; o++)
        this.find[o].pos == null &&
          e.nodeType == 1 &&
          e.contains(this.find[o].node) &&
          n.compareDocumentPosition(this.find[o].node) & (r ? 2 : 4) &&
          (this.find[o].pos = this.currentPos);
  }
  findInText(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].node == e &&
          (this.find[n].pos =
            this.currentPos - (e.nodeValue.length - this.find[n].offset));
  }
  matchesContext(e) {
    if (e.indexOf("|") > -1)
      return e.split(/\s*\|\s*/).some(this.matchesContext, this);
    let n = e.split("/"),
      r = this.options.context,
      o = !this.isOpen && (!r || r.parent.type == this.nodes[0].type),
      i = -(r ? r.depth + 1 : 0) + (o ? 0 : 1),
      l = (u, c) => {
        for (; u >= 0; u--) {
          let f = n[u];
          if (f == "") {
            if (u == n.length - 1 || u == 0) continue;
            for (; c >= i; c--) if (l(u - 1, c)) return !0;
            return !1;
          } else {
            let p =
              c > 0 || (c == 0 && o)
                ? this.nodes[c].type
                : r && c >= i
                ? r.node(c - i).type
                : null;
            if (!p || (p.name != f && !p.isInGroup(f))) return !1;
            c--;
          }
        }
        return !0;
      };
    return l(n.length - 1, this.open);
  }
  textblockFromContext() {
    let e = this.options.context;
    if (e)
      for (let n = e.depth; n >= 0; n--) {
        let r = e.node(n).contentMatchAt(e.indexAfter(n)).defaultType;
        if (r && r.isTextblock && r.defaultAttrs) return r;
      }
    for (let n in this.parser.schema.nodes) {
      let r = this.parser.schema.nodes[n];
      if (r.isTextblock && r.defaultAttrs) return r;
    }
  }
}
function HO(t) {
  for (let e = t.firstChild, n = null; e; e = e.nextSibling) {
    let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
    r && mb.hasOwnProperty(r) && n
      ? (n.appendChild(e), (e = n))
      : r == "li"
      ? (n = e)
      : r && (n = null);
  }
}
function VO(t, e) {
  return (
    t.matches ||
    t.msMatchesSelector ||
    t.webkitMatchesSelector ||
    t.mozMatchesSelector
  ).call(t, e);
}
function M1(t) {
  let e = {};
  for (let n in t) e[n] = t[n];
  return e;
}
function O1(t, e) {
  let n = e.schema.nodes;
  for (let r in n) {
    let o = n[r];
    if (!o.allowsMarkType(t)) continue;
    let i = [],
      l = (u) => {
        i.push(u);
        for (let c = 0; c < u.edgeCount; c++) {
          let { type: f, next: p } = u.edge(c);
          if (f == e || (i.indexOf(p) < 0 && l(p))) return !0;
        }
      };
    if (l(o.contentMatch)) return !0;
  }
}
class Wi {
  constructor(e, n) {
    (this.nodes = e), (this.marks = n);
  }
  serializeFragment(e, n = {}, r) {
    r || (r = ah(n).createDocumentFragment());
    let o = r,
      i = [];
    return (
      e.forEach((l) => {
        if (i.length || l.marks.length) {
          let u = 0,
            c = 0;
          for (; u < i.length && c < l.marks.length; ) {
            let f = l.marks[c];
            if (!this.marks[f.type.name]) {
              c++;
              continue;
            }
            if (!f.eq(i[u][0]) || f.type.spec.spanning === !1) break;
            u++, c++;
          }
          for (; u < i.length; ) o = i.pop()[1];
          for (; c < l.marks.length; ) {
            let f = l.marks[c++],
              p = this.serializeMark(f, l.isInline, n);
            p &&
              (i.push([f, o]),
              o.appendChild(p.dom),
              (o = p.contentDOM || p.dom));
          }
        }
        o.appendChild(this.serializeNodeInner(l, n));
      }),
      r
    );
  }
  serializeNodeInner(e, n) {
    let { dom: r, contentDOM: o } = Ac(
      ah(n),
      this.nodes[e.type.name](e),
      null,
      e.attrs
    );
    if (o) {
      if (e.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(e.content, n, o);
    }
    return r;
  }
  serializeNode(e, n = {}) {
    let r = this.serializeNodeInner(e, n);
    for (let o = e.marks.length - 1; o >= 0; o--) {
      let i = this.serializeMark(e.marks[o], e.isInline, n);
      i && ((i.contentDOM || i.dom).appendChild(r), (r = i.dom));
    }
    return r;
  }
  serializeMark(e, n, r = {}) {
    let o = this.marks[e.type.name];
    return o && Ac(ah(r), o(e, n), null, e.attrs);
  }
  static renderSpec(e, n, r = null, o) {
    return Ac(e, n, r, o);
  }
  static fromSchema(e) {
    return (
      e.cached.domSerializer ||
      (e.cached.domSerializer = new Wi(
        this.nodesFromSchema(e),
        this.marksFromSchema(e)
      ))
    );
  }
  static nodesFromSchema(e) {
    let n = T1(e.nodes);
    return n.text || (n.text = (r) => r.text), n;
  }
  static marksFromSchema(e) {
    return T1(e.marks);
  }
}
function T1(t) {
  let e = {};
  for (let n in t) {
    let r = t[n].spec.toDOM;
    r && (e[n] = r);
  }
  return e;
}
function ah(t) {
  return t.document || window.document;
}
const N1 = new WeakMap();
function WO(t) {
  let e = N1.get(t);
  return e === void 0 && N1.set(t, (e = UO(t))), e;
}
function UO(t) {
  let e = null;
  function n(r) {
    if (r && typeof r == "object")
      if (Array.isArray(r))
        if (typeof r[0] == "string") e || (e = []), e.push(r);
        else for (let o = 0; o < r.length; o++) n(r[o]);
      else for (let o in r) n(r[o]);
  }
  return n(t), e;
}
function Ac(t, e, n, r) {
  if (typeof e == "string") return { dom: t.createTextNode(e) };
  if (e.nodeType != null) return { dom: e };
  if (e.dom && e.dom.nodeType != null) return e;
  let o = e[0],
    i;
  if (typeof o != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (r && (i = WO(r)) && i.indexOf(e) > -1)
    throw new RangeError(
      "Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack."
    );
  let l = o.indexOf(" ");
  l > 0 && ((n = o.slice(0, l)), (o = o.slice(l + 1)));
  let u,
    c = n ? t.createElementNS(n, o) : t.createElement(o),
    f = e[1],
    p = 1;
  if (f && typeof f == "object" && f.nodeType == null && !Array.isArray(f)) {
    p = 2;
    for (let m in f)
      if (f[m] != null) {
        let y = m.indexOf(" ");
        y > 0
          ? c.setAttributeNS(m.slice(0, y), m.slice(y + 1), f[m])
          : c.setAttribute(m, f[m]);
      }
  }
  for (let m = p; m < e.length; m++) {
    let y = e[m];
    if (y === 0) {
      if (m < e.length - 1 || m > p)
        throw new RangeError(
          "Content hole must be the only child of its parent node"
        );
      return { dom: c, contentDOM: c };
    } else {
      let { dom: v, contentDOM: x } = Ac(t, y, n, r);
      if ((c.appendChild(v), x)) {
        if (u) throw new RangeError("Multiple content holes");
        u = x;
      }
    }
  }
  return { dom: c, contentDOM: u };
}
const gb = 65535,
  yb = Math.pow(2, 16);
function KO(t, e) {
  return t + e * yb;
}
function A1(t) {
  return t & gb;
}
function qO(t) {
  return (t - (t & gb)) / yb;
}
const vb = 1,
  wb = 2,
  Rc = 4,
  xb = 8;
class am {
  constructor(e, n, r) {
    (this.pos = e), (this.delInfo = n), (this.recover = r);
  }
  get deleted() {
    return (this.delInfo & xb) > 0;
  }
  get deletedBefore() {
    return (this.delInfo & (vb | Rc)) > 0;
  }
  get deletedAfter() {
    return (this.delInfo & (wb | Rc)) > 0;
  }
  get deletedAcross() {
    return (this.delInfo & Rc) > 0;
  }
}
class mn {
  constructor(e, n = !1) {
    if (((this.ranges = e), (this.inverted = n), !e.length && mn.empty))
      return mn.empty;
  }
  recover(e) {
    let n = 0,
      r = A1(e);
    if (!this.inverted)
      for (let o = 0; o < r; o++)
        n += this.ranges[o * 3 + 2] - this.ranges[o * 3 + 1];
    return this.ranges[r * 3] + n + qO(e);
  }
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  map(e, n = 1) {
    return this._map(e, n, !0);
  }
  _map(e, n, r) {
    let o = 0,
      i = this.inverted ? 2 : 1,
      l = this.inverted ? 1 : 2;
    for (let u = 0; u < this.ranges.length; u += 3) {
      let c = this.ranges[u] - (this.inverted ? o : 0);
      if (c > e) break;
      let f = this.ranges[u + i],
        p = this.ranges[u + l],
        m = c + f;
      if (e <= m) {
        let y = f ? (e == c ? -1 : e == m ? 1 : n) : n,
          v = c + o + (y < 0 ? 0 : p);
        if (r) return v;
        let x = e == (n < 0 ? c : m) ? null : KO(u / 3, e - c),
          S = e == c ? wb : e == m ? vb : Rc;
        return (n < 0 ? e != c : e != m) && (S |= xb), new am(v, S, x);
      }
      o += p - f;
    }
    return r ? e + o : new am(e + o, 0, null);
  }
  touches(e, n) {
    let r = 0,
      o = A1(n),
      i = this.inverted ? 2 : 1,
      l = this.inverted ? 1 : 2;
    for (let u = 0; u < this.ranges.length; u += 3) {
      let c = this.ranges[u] - (this.inverted ? r : 0);
      if (c > e) break;
      let f = this.ranges[u + i],
        p = c + f;
      if (e <= p && u == o * 3) return !0;
      r += this.ranges[u + l] - f;
    }
    return !1;
  }
  forEach(e) {
    let n = this.inverted ? 2 : 1,
      r = this.inverted ? 1 : 2;
    for (let o = 0, i = 0; o < this.ranges.length; o += 3) {
      let l = this.ranges[o],
        u = l - (this.inverted ? i : 0),
        c = l + (this.inverted ? 0 : i),
        f = this.ranges[o + n],
        p = this.ranges[o + r];
      e(u, u + f, c, c + p), (i += p - f);
    }
  }
  invert() {
    return new mn(this.ranges, !this.inverted);
  }
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  static offset(e) {
    return e == 0 ? mn.empty : new mn(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
}
mn.empty = new mn([]);
class va {
  constructor(e, n, r = 0, o = e ? e.length : 0) {
    (this.mirror = n),
      (this.from = r),
      (this.to = o),
      (this._maps = e || []),
      (this.ownData = !(e || n));
  }
  get maps() {
    return this._maps;
  }
  slice(e = 0, n = this.maps.length) {
    return new va(this._maps, this.mirror, e, n);
  }
  appendMap(e, n) {
    this.ownData ||
      ((this._maps = this._maps.slice()),
      (this.mirror = this.mirror && this.mirror.slice()),
      (this.ownData = !0)),
      (this.to = this._maps.push(e)),
      n != null && this.setMirror(this._maps.length - 1, n);
  }
  appendMapping(e) {
    for (let n = 0, r = this._maps.length; n < e._maps.length; n++) {
      let o = e.getMirror(n);
      this.appendMap(e._maps[n], o != null && o < n ? r + o : void 0);
    }
  }
  getMirror(e) {
    if (this.mirror) {
      for (let n = 0; n < this.mirror.length; n++)
        if (this.mirror[n] == e) return this.mirror[n + (n % 2 ? -1 : 1)];
    }
  }
  setMirror(e, n) {
    this.mirror || (this.mirror = []), this.mirror.push(e, n);
  }
  appendMappingInverted(e) {
    for (
      let n = e.maps.length - 1, r = this._maps.length + e._maps.length;
      n >= 0;
      n--
    ) {
      let o = e.getMirror(n);
      this.appendMap(
        e._maps[n].invert(),
        o != null && o > n ? r - o - 1 : void 0
      );
    }
  }
  invert() {
    let e = new va();
    return e.appendMappingInverted(this), e;
  }
  map(e, n = 1) {
    if (this.mirror) return this._map(e, n, !0);
    for (let r = this.from; r < this.to; r++) e = this._maps[r].map(e, n);
    return e;
  }
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  _map(e, n, r) {
    let o = 0;
    for (let i = this.from; i < this.to; i++) {
      let l = this._maps[i],
        u = l.mapResult(e, n);
      if (u.recover != null) {
        let c = this.getMirror(i);
        if (c != null && c > i && c < this.to) {
          (i = c), (e = this._maps[c].recover(u.recover));
          continue;
        }
      }
      (o |= u.delInfo), (e = u.pos);
    }
    return r ? e : new am(e, o, null);
  }
}
const uh = Object.create(null);
class Lt {
  getMap() {
    return mn.empty;
  }
  merge(e) {
    return null;
  }
  static fromJSON(e, n) {
    if (!n || !n.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let r = uh[n.stepType];
    if (!r) throw new RangeError(`No step type ${n.stepType} defined`);
    return r.fromJSON(e, n);
  }
  static jsonID(e, n) {
    if (e in uh) throw new RangeError("Duplicate use of step JSON ID " + e);
    return (uh[e] = n), (n.prototype.jsonID = e), n;
  }
}
class st {
  constructor(e, n) {
    (this.doc = e), (this.failed = n);
  }
  static ok(e) {
    return new st(e, null);
  }
  static fail(e) {
    return new st(null, e);
  }
  static fromReplace(e, n, r, o) {
    try {
      return st.ok(e.replace(n, r, o));
    } catch (i) {
      if (i instanceof zc) return st.fail(i.message);
      throw i;
    }
  }
}
function ng(t, e, n) {
  let r = [];
  for (let o = 0; o < t.childCount; o++) {
    let i = t.child(o);
    i.content.size && (i = i.copy(ng(i.content, e, i))),
      i.isInline && (i = e(i, n, o)),
      r.push(i);
  }
  return J.fromArray(r);
}
class Po extends Lt {
  constructor(e, n, r) {
    super(), (this.from = e), (this.to = n), (this.mark = r);
  }
  apply(e) {
    let n = e.slice(this.from, this.to),
      r = e.resolve(this.from),
      o = r.node(r.sharedDepth(this.to)),
      i = new ae(
        ng(
          n.content,
          (l, u) =>
            !l.isAtom || !u.type.allowsMarkType(this.mark.type)
              ? l
              : l.mark(this.mark.addToSet(l.marks)),
          o
        ),
        n.openStart,
        n.openEnd
      );
    return st.fromReplace(e, this.from, this.to, i);
  }
  invert() {
    return new pr(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1),
      r = e.mapResult(this.to, -1);
    return (n.deleted && r.deleted) || n.pos >= r.pos
      ? null
      : new Po(n.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof Po &&
      e.mark.eq(this.mark) &&
      this.from <= e.to &&
      this.to >= e.from
      ? new Po(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark)
      : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to,
    };
  }
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new Po(n.from, n.to, e.markFromJSON(n.mark));
  }
}
Lt.jsonID("addMark", Po);
class pr extends Lt {
  constructor(e, n, r) {
    super(), (this.from = e), (this.to = n), (this.mark = r);
  }
  apply(e) {
    let n = e.slice(this.from, this.to),
      r = new ae(
        ng(n.content, (o) => o.mark(this.mark.removeFromSet(o.marks)), e),
        n.openStart,
        n.openEnd
      );
    return st.fromReplace(e, this.from, this.to, r);
  }
  invert() {
    return new Po(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1),
      r = e.mapResult(this.to, -1);
    return (n.deleted && r.deleted) || n.pos >= r.pos
      ? null
      : new pr(n.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof pr &&
      e.mark.eq(this.mark) &&
      this.from <= e.to &&
      this.to >= e.from
      ? new pr(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark)
      : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to,
    };
  }
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new pr(n.from, n.to, e.markFromJSON(n.mark));
  }
}
Lt.jsonID("removeMark", pr);
class Do extends Lt {
  constructor(e, n) {
    super(), (this.pos = e), (this.mark = n);
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n) return st.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
    return st.fromReplace(
      e,
      this.pos,
      this.pos + 1,
      new ae(J.from(r), 0, n.isLeaf ? 0 : 1)
    );
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    if (n) {
      let r = this.mark.addToSet(n.marks);
      if (r.length == n.marks.length) {
        for (let o = 0; o < n.marks.length; o++)
          if (!n.marks[o].isInSet(r)) return new Do(this.pos, n.marks[o]);
        return new Do(this.pos, this.mark);
      }
    }
    return new Hs(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new Do(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new Do(n.pos, e.markFromJSON(n.mark));
  }
}
Lt.jsonID("addNodeMark", Do);
class Hs extends Lt {
  constructor(e, n) {
    super(), (this.pos = e), (this.mark = n);
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n) return st.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
    return st.fromReplace(
      e,
      this.pos,
      this.pos + 1,
      new ae(J.from(r), 0, n.isLeaf ? 0 : 1)
    );
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    return !n || !this.mark.isInSet(n.marks)
      ? this
      : new Do(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new Hs(n.pos, this.mark);
  }
  toJSON() {
    return {
      stepType: "removeNodeMark",
      pos: this.pos,
      mark: this.mark.toJSON(),
    };
  }
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new Hs(n.pos, e.markFromJSON(n.mark));
  }
}
Lt.jsonID("removeNodeMark", Hs);
class yt extends Lt {
  constructor(e, n, r, o = !1) {
    super(),
      (this.from = e),
      (this.to = n),
      (this.slice = r),
      (this.structure = o);
  }
  apply(e) {
    return this.structure && um(e, this.from, this.to)
      ? st.fail("Structure replace would overwrite content")
      : st.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new mn([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new yt(
      this.from,
      this.from + this.slice.size,
      e.slice(this.from, this.to)
    );
  }
  map(e) {
    let n = e.mapResult(this.from, 1),
      r = e.mapResult(this.to, -1);
    return n.deletedAcross && r.deletedAcross
      ? null
      : new yt(n.pos, Math.max(n.pos, r.pos), this.slice);
  }
  merge(e) {
    if (!(e instanceof yt) || e.structure || this.structure) return null;
    if (
      this.from + this.slice.size == e.from &&
      !this.slice.openEnd &&
      !e.slice.openStart
    ) {
      let n =
        this.slice.size + e.slice.size == 0
          ? ae.empty
          : new ae(
              this.slice.content.append(e.slice.content),
              this.slice.openStart,
              e.slice.openEnd
            );
      return new yt(this.from, this.to + (e.to - e.from), n, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let n =
        this.slice.size + e.slice.size == 0
          ? ae.empty
          : new ae(
              e.slice.content.append(this.slice.content),
              e.slice.openStart,
              this.slice.openEnd
            );
      return new yt(e.from, this.to, n, this.structure);
    } else return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return (
      this.slice.size && (e.slice = this.slice.toJSON()),
      this.structure && (e.structure = !0),
      e
    );
  }
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new yt(n.from, n.to, ae.fromJSON(e, n.slice), !!n.structure);
  }
}
Lt.jsonID("replace", yt);
class vt extends Lt {
  constructor(e, n, r, o, i, l, u = !1) {
    super(),
      (this.from = e),
      (this.to = n),
      (this.gapFrom = r),
      (this.gapTo = o),
      (this.slice = i),
      (this.insert = l),
      (this.structure = u);
  }
  apply(e) {
    if (
      this.structure &&
      (um(e, this.from, this.gapFrom) || um(e, this.gapTo, this.to))
    )
      return st.fail("Structure gap-replace would overwrite content");
    let n = e.slice(this.gapFrom, this.gapTo);
    if (n.openStart || n.openEnd) return st.fail("Gap is not a flat range");
    let r = this.slice.insertAt(this.insert, n.content);
    return r
      ? st.fromReplace(e, this.from, this.to, r)
      : st.fail("Content does not fit in gap");
  }
  getMap() {
    return new mn([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert,
    ]);
  }
  invert(e) {
    let n = this.gapTo - this.gapFrom;
    return new vt(
      this.from,
      this.from + this.slice.size + n,
      this.from + this.insert,
      this.from + this.insert + n,
      e
        .slice(this.from, this.to)
        .removeBetween(this.gapFrom - this.from, this.gapTo - this.from),
      this.gapFrom - this.from,
      this.structure
    );
  }
  map(e) {
    let n = e.mapResult(this.from, 1),
      r = e.mapResult(this.to, -1),
      o = this.from == this.gapFrom ? n.pos : e.map(this.gapFrom, -1),
      i = this.to == this.gapTo ? r.pos : e.map(this.gapTo, 1);
    return (n.deletedAcross && r.deletedAcross) || o < n.pos || i > r.pos
      ? null
      : new vt(n.pos, r.pos, o, i, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert,
    };
    return (
      this.slice.size && (e.slice = this.slice.toJSON()),
      this.structure && (e.structure = !0),
      e
    );
  }
  static fromJSON(e, n) {
    if (
      typeof n.from != "number" ||
      typeof n.to != "number" ||
      typeof n.gapFrom != "number" ||
      typeof n.gapTo != "number" ||
      typeof n.insert != "number"
    )
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new vt(
      n.from,
      n.to,
      n.gapFrom,
      n.gapTo,
      ae.fromJSON(e, n.slice),
      n.insert,
      !!n.structure
    );
  }
}
Lt.jsonID("replaceAround", vt);
function um(t, e, n) {
  let r = t.resolve(e),
    o = n - e,
    i = r.depth;
  for (; o > 0 && i > 0 && r.indexAfter(i) == r.node(i).childCount; ) i--, o--;
  if (o > 0) {
    let l = r.node(i).maybeChild(r.indexAfter(i));
    for (; o > 0; ) {
      if (!l || l.isLeaf) return !0;
      (l = l.firstChild), o--;
    }
  }
  return !1;
}
function GO(t, e, n, r) {
  let o = [],
    i = [],
    l,
    u;
  t.doc.nodesBetween(e, n, (c, f, p) => {
    if (!c.isInline) return;
    let m = c.marks;
    if (!r.isInSet(m) && p.type.allowsMarkType(r.type)) {
      let y = Math.max(f, e),
        v = Math.min(f + c.nodeSize, n),
        x = r.addToSet(m);
      for (let S = 0; S < m.length; S++)
        m[S].isInSet(x) ||
          (l && l.to == y && l.mark.eq(m[S])
            ? (l.to = v)
            : o.push((l = new pr(y, v, m[S]))));
      u && u.to == y ? (u.to = v) : i.push((u = new Po(y, v, r)));
    }
  }),
    o.forEach((c) => t.step(c)),
    i.forEach((c) => t.step(c));
}
function JO(t, e, n, r) {
  let o = [],
    i = 0;
  t.doc.nodesBetween(e, n, (l, u) => {
    if (!l.isInline) return;
    i++;
    let c = null;
    if (r instanceof Fd) {
      let f = l.marks,
        p;
      for (; (p = r.isInSet(f)); )
        (c || (c = [])).push(p), (f = p.removeFromSet(f));
    } else r ? r.isInSet(l.marks) && (c = [r]) : (c = l.marks);
    if (c && c.length) {
      let f = Math.min(u + l.nodeSize, n);
      for (let p = 0; p < c.length; p++) {
        let m = c[p],
          y;
        for (let v = 0; v < o.length; v++) {
          let x = o[v];
          x.step == i - 1 && m.eq(o[v].style) && (y = x);
        }
        y
          ? ((y.to = f), (y.step = i))
          : o.push({ style: m, from: Math.max(u, e), to: f, step: i });
      }
    }
  }),
    o.forEach((l) => t.step(new pr(l.from, l.to, l.style)));
}
function rg(t, e, n, r = n.contentMatch, o = !0) {
  let i = t.doc.nodeAt(e),
    l = [],
    u = e + 1;
  for (let c = 0; c < i.childCount; c++) {
    let f = i.child(c),
      p = u + f.nodeSize,
      m = r.matchType(f.type);
    if (!m) l.push(new yt(u, p, ae.empty));
    else {
      r = m;
      for (let y = 0; y < f.marks.length; y++)
        n.allowsMarkType(f.marks[y].type) || t.step(new pr(u, p, f.marks[y]));
      if (o && f.isText && n.whitespace != "pre") {
        let y,
          v = /\r?\n|\r/g,
          x;
        for (; (y = v.exec(f.text)); )
          x ||
            (x = new ae(
              J.from(n.schema.text(" ", n.allowedMarks(f.marks))),
              0,
              0
            )),
            l.push(new yt(u + y.index, u + y.index + y[0].length, x));
      }
    }
    u = p;
  }
  if (!r.validEnd) {
    let c = r.fillBefore(J.empty, !0);
    t.replace(u, u, new ae(c, 0, 0));
  }
  for (let c = l.length - 1; c >= 0; c--) t.step(l[c]);
}
function QO(t, e, n) {
  return (
    (e == 0 || t.canReplace(e, t.childCount)) &&
    (n == t.childCount || t.canReplace(0, n))
  );
}
function tl(t) {
  let n = t.parent.content.cutByIndex(t.startIndex, t.endIndex);
  for (let r = t.depth; ; --r) {
    let o = t.$from.node(r),
      i = t.$from.index(r),
      l = t.$to.indexAfter(r);
    if (r < t.depth && o.canReplace(i, l, n)) return r;
    if (r == 0 || o.type.spec.isolating || !QO(o, i, l)) break;
  }
  return null;
}
function YO(t, e, n) {
  let { $from: r, $to: o, depth: i } = e,
    l = r.before(i + 1),
    u = o.after(i + 1),
    c = l,
    f = u,
    p = J.empty,
    m = 0;
  for (let x = i, S = !1; x > n; x--)
    S || r.index(x) > 0
      ? ((S = !0), (p = J.from(r.node(x).copy(p))), m++)
      : c--;
  let y = J.empty,
    v = 0;
  for (let x = i, S = !1; x > n; x--)
    S || o.after(x + 1) < o.end(x)
      ? ((S = !0), (y = J.from(o.node(x).copy(y))), v++)
      : f++;
  t.step(new vt(c, f, l, u, new ae(p.append(y), m, v), p.size - m, !0));
}
function og(t, e, n = null, r = t) {
  let o = XO(t, e),
    i = o && ZO(r, e);
  return i ? o.map(R1).concat({ type: e, attrs: n }).concat(i.map(R1)) : null;
}
function R1(t) {
  return { type: t, attrs: null };
}
function XO(t, e) {
  let { parent: n, startIndex: r, endIndex: o } = t,
    i = n.contentMatchAt(r).findWrapping(e);
  if (!i) return null;
  let l = i.length ? i[0] : e;
  return n.canReplaceWith(r, o, l) ? i : null;
}
function ZO(t, e) {
  let { parent: n, startIndex: r, endIndex: o } = t,
    i = n.child(r),
    l = e.contentMatch.findWrapping(i.type);
  if (!l) return null;
  let c = (l.length ? l[l.length - 1] : e).contentMatch;
  for (let f = r; c && f < o; f++) c = c.matchType(n.child(f).type);
  return !c || !c.validEnd ? null : l;
}
function eT(t, e, n) {
  let r = J.empty;
  for (let l = n.length - 1; l >= 0; l--) {
    if (r.size) {
      let u = n[l].type.contentMatch.matchFragment(r);
      if (!u || !u.validEnd)
        throw new RangeError(
          "Wrapper type given to Transform.wrap does not form valid content of its parent wrapper"
        );
    }
    r = J.from(n[l].type.create(n[l].attrs, r));
  }
  let o = e.start,
    i = e.end;
  t.step(new vt(o, i, o, i, new ae(r, 0, 0), n.length, !0));
}
function tT(t, e, n, r, o) {
  if (!r.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let i = t.steps.length;
  t.doc.nodesBetween(e, n, (l, u) => {
    let c = typeof o == "function" ? o(l) : o;
    if (
      l.isTextblock &&
      !l.hasMarkup(r, c) &&
      nT(t.doc, t.mapping.slice(i).map(u), r)
    ) {
      let f = null;
      if (r.schema.linebreakReplacement) {
        let v = r.whitespace == "pre",
          x = !!r.contentMatch.matchType(r.schema.linebreakReplacement);
        v && !x ? (f = !1) : !v && x && (f = !0);
      }
      f === !1 && Sb(t, l, u, i),
        rg(t, t.mapping.slice(i).map(u, 1), r, void 0, f === null);
      let p = t.mapping.slice(i),
        m = p.map(u, 1),
        y = p.map(u + l.nodeSize, 1);
      return (
        t.step(
          new vt(
            m,
            y,
            m + 1,
            y - 1,
            new ae(J.from(r.create(c, null, l.marks)), 0, 0),
            1,
            !0
          )
        ),
        f === !0 && bb(t, l, u, i),
        !1
      );
    }
  });
}
function bb(t, e, n, r) {
  e.forEach((o, i) => {
    if (o.isText) {
      let l,
        u = /\r?\n|\r/g;
      for (; (l = u.exec(o.text)); ) {
        let c = t.mapping.slice(r).map(n + 1 + i + l.index);
        t.replaceWith(c, c + 1, e.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function Sb(t, e, n, r) {
  e.forEach((o, i) => {
    if (o.type == o.type.schema.linebreakReplacement) {
      let l = t.mapping.slice(r).map(n + 1 + i);
      t.replaceWith(
        l,
        l + 1,
        e.type.schema.text(`
`)
      );
    }
  });
}
function nT(t, e, n) {
  let r = t.resolve(e),
    o = r.index();
  return r.parent.canReplaceWith(o, o + 1, n);
}
function rT(t, e, n, r, o) {
  let i = t.doc.nodeAt(e);
  if (!i) throw new RangeError("No node at given position");
  n || (n = i.type);
  let l = n.create(r, null, o || i.marks);
  if (i.isLeaf) return t.replaceWith(e, e + i.nodeSize, l);
  if (!n.validContent(i.content))
    throw new RangeError("Invalid content for node type " + n.name);
  t.step(
    new vt(
      e,
      e + i.nodeSize,
      e + 1,
      e + i.nodeSize - 1,
      new ae(J.from(l), 0, 0),
      1,
      !0
    )
  );
}
function Ls(t, e, n = 1, r) {
  let o = t.resolve(e),
    i = o.depth - n,
    l = (r && r[r.length - 1]) || o.parent;
  if (
    i < 0 ||
    o.parent.type.spec.isolating ||
    !o.parent.canReplace(o.index(), o.parent.childCount) ||
    !l.type.validContent(
      o.parent.content.cutByIndex(o.index(), o.parent.childCount)
    )
  )
    return !1;
  for (let f = o.depth - 1, p = n - 2; f > i; f--, p--) {
    let m = o.node(f),
      y = o.index(f);
    if (m.type.spec.isolating) return !1;
    let v = m.content.cutByIndex(y, m.childCount),
      x = r && r[p + 1];
    x && (v = v.replaceChild(0, x.type.create(x.attrs)));
    let S = (r && r[p]) || m;
    if (!m.canReplace(y + 1, m.childCount) || !S.type.validContent(v))
      return !1;
  }
  let u = o.indexAfter(i),
    c = r && r[0];
  return o.node(i).canReplaceWith(u, u, c ? c.type : o.node(i + 1).type);
}
function oT(t, e, n = 1, r) {
  let o = t.doc.resolve(e),
    i = J.empty,
    l = J.empty;
  for (let u = o.depth, c = o.depth - n, f = n - 1; u > c; u--, f--) {
    i = J.from(o.node(u).copy(i));
    let p = r && r[f];
    l = J.from(p ? p.type.create(p.attrs, l) : o.node(u).copy(l));
  }
  t.step(new yt(e, e, new ae(i.append(l), n, n), !0));
}
function Ko(t, e) {
  let n = t.resolve(e),
    r = n.index();
  return Cb(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1);
}
function iT(t, e) {
  e.content.size || t.type.compatibleContent(e.type);
  let n = t.contentMatchAt(t.childCount),
    { linebreakReplacement: r } = t.type.schema;
  for (let o = 0; o < e.childCount; o++) {
    let i = e.child(o),
      l = i.type == r ? t.type.schema.nodes.text : i.type;
    if (((n = n.matchType(l)), !n || !t.type.allowsMarks(i.marks))) return !1;
  }
  return n.validEnd;
}
function Cb(t, e) {
  return !!(t && e && !t.isLeaf && iT(t, e));
}
function zd(t, e, n = -1) {
  let r = t.resolve(e);
  for (let o = r.depth; ; o--) {
    let i,
      l,
      u = r.index(o);
    if (
      (o == r.depth
        ? ((i = r.nodeBefore), (l = r.nodeAfter))
        : n > 0
        ? ((i = r.node(o + 1)), u++, (l = r.node(o).maybeChild(u)))
        : ((i = r.node(o).maybeChild(u - 1)), (l = r.node(o + 1))),
      i && !i.isTextblock && Cb(i, l) && r.node(o).canReplace(u, u + 1))
    )
      return e;
    if (o == 0) break;
    e = n < 0 ? r.before(o) : r.after(o);
  }
}
function sT(t, e, n) {
  let r = null,
    { linebreakReplacement: o } = t.doc.type.schema,
    i = t.doc.resolve(e - n),
    l = i.node().type;
  if (o && l.inlineContent) {
    let p = l.whitespace == "pre",
      m = !!l.contentMatch.matchType(o);
    p && !m ? (r = !1) : !p && m && (r = !0);
  }
  let u = t.steps.length;
  if (r === !1) {
    let p = t.doc.resolve(e + n);
    Sb(t, p.node(), p.before(), u);
  }
  l.inlineContent &&
    rg(t, e + n - 1, l, i.node().contentMatchAt(i.index()), r == null);
  let c = t.mapping.slice(u),
    f = c.map(e - n);
  if ((t.step(new yt(f, c.map(e + n, -1), ae.empty, !0)), r === !0)) {
    let p = t.doc.resolve(f);
    bb(t, p.node(), p.before(), t.steps.length);
  }
  return t;
}
function lT(t, e, n) {
  let r = t.resolve(e);
  if (r.parent.canReplaceWith(r.index(), r.index(), n)) return e;
  if (r.parentOffset == 0)
    for (let o = r.depth - 1; o >= 0; o--) {
      let i = r.index(o);
      if (r.node(o).canReplaceWith(i, i, n)) return r.before(o + 1);
      if (i > 0) return null;
    }
  if (r.parentOffset == r.parent.content.size)
    for (let o = r.depth - 1; o >= 0; o--) {
      let i = r.indexAfter(o);
      if (r.node(o).canReplaceWith(i, i, n)) return r.after(o + 1);
      if (i < r.node(o).childCount) return null;
    }
  return null;
}
function kb(t, e, n) {
  let r = t.resolve(e);
  if (!n.content.size) return e;
  let o = n.content;
  for (let i = 0; i < n.openStart; i++) o = o.firstChild.content;
  for (let i = 1; i <= (n.openStart == 0 && n.size ? 2 : 1); i++)
    for (let l = r.depth; l >= 0; l--) {
      let u =
          l == r.depth
            ? 0
            : r.pos <= (r.start(l + 1) + r.end(l + 1)) / 2
            ? -1
            : 1,
        c = r.index(l) + (u > 0 ? 1 : 0),
        f = r.node(l),
        p = !1;
      if (i == 1) p = f.canReplace(c, c, o);
      else {
        let m = f.contentMatchAt(c).findWrapping(o.firstChild.type);
        p = m && f.canReplaceWith(c, c, m[0]);
      }
      if (p) return u == 0 ? r.pos : u < 0 ? r.before(l + 1) : r.after(l + 1);
    }
  return null;
}
function jd(t, e, n = e, r = ae.empty) {
  if (e == n && !r.size) return null;
  let o = t.resolve(e),
    i = t.resolve(n);
  return Eb(o, i, r) ? new yt(e, n, r) : new aT(o, i, r).fit();
}
function Eb(t, e, n) {
  return (
    !n.openStart &&
    !n.openEnd &&
    t.start() == e.start() &&
    t.parent.canReplace(t.index(), e.index(), n.content)
  );
}
class aT {
  constructor(e, n, r) {
    (this.$from = e),
      (this.$to = n),
      (this.unplaced = r),
      (this.frontier = []),
      (this.placed = J.empty);
    for (let o = 0; o <= e.depth; o++) {
      let i = e.node(o);
      this.frontier.push({
        type: i.type,
        match: i.contentMatchAt(e.indexAfter(o)),
      });
    }
    for (let o = e.depth; o > 0; o--)
      this.placed = J.from(e.node(o).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let f = this.findFittable();
      f ? this.placeNodes(f) : this.openMore() || this.dropNode();
    }
    let e = this.mustMoveInline(),
      n = this.placed.size - this.depth - this.$from.depth,
      r = this.$from,
      o = this.close(e < 0 ? this.$to : r.doc.resolve(e));
    if (!o) return null;
    let i = this.placed,
      l = r.depth,
      u = o.depth;
    for (; l && u && i.childCount == 1; ) (i = i.firstChild.content), l--, u--;
    let c = new ae(i, l, u);
    return e > -1
      ? new vt(r.pos, e, this.$to.pos, this.$to.end(), c, n)
      : c.size || r.pos != this.$to.pos
      ? new yt(r.pos, o.pos, c)
      : null;
  }
  findFittable() {
    let e = this.unplaced.openStart;
    for (
      let n = this.unplaced.content, r = 0, o = this.unplaced.openEnd;
      r < e;
      r++
    ) {
      let i = n.firstChild;
      if ((n.childCount > 1 && (o = 0), i.type.spec.isolating && o <= r)) {
        e = r;
        break;
      }
      n = i.content;
    }
    for (let n = 1; n <= 2; n++)
      for (let r = n == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
        let o,
          i = null;
        r
          ? ((i = ch(this.unplaced.content, r - 1).firstChild), (o = i.content))
          : (o = this.unplaced.content);
        let l = o.firstChild;
        for (let u = this.depth; u >= 0; u--) {
          let { type: c, match: f } = this.frontier[u],
            p,
            m = null;
          if (
            n == 1 &&
            (l
              ? f.matchType(l.type) || (m = f.fillBefore(J.from(l), !1))
              : i && c.compatibleContent(i.type))
          )
            return { sliceDepth: r, frontierDepth: u, parent: i, inject: m };
          if (n == 2 && l && (p = f.findWrapping(l.type)))
            return { sliceDepth: r, frontierDepth: u, parent: i, wrap: p };
          if (i && f.matchType(i.type)) break;
        }
      }
  }
  openMore() {
    let { content: e, openStart: n, openEnd: r } = this.unplaced,
      o = ch(e, n);
    return !o.childCount || o.firstChild.isLeaf
      ? !1
      : ((this.unplaced = new ae(
          e,
          n + 1,
          Math.max(r, o.size + n >= e.size - r ? n + 1 : 0)
        )),
        !0);
  }
  dropNode() {
    let { content: e, openStart: n, openEnd: r } = this.unplaced,
      o = ch(e, n);
    if (o.childCount <= 1 && n > 0) {
      let i = e.size - n <= n + o.size;
      this.unplaced = new ae(Ql(e, n - 1, 1), n - 1, i ? n - 1 : r);
    } else this.unplaced = new ae(Ql(e, n, 1), n, r);
  }
  placeNodes({
    sliceDepth: e,
    frontierDepth: n,
    parent: r,
    inject: o,
    wrap: i,
  }) {
    for (; this.depth > n; ) this.closeFrontierNode();
    if (i) for (let S = 0; S < i.length; S++) this.openFrontierNode(i[S]);
    let l = this.unplaced,
      u = r ? r.content : l.content,
      c = l.openStart - e,
      f = 0,
      p = [],
      { match: m, type: y } = this.frontier[n];
    if (o) {
      for (let S = 0; S < o.childCount; S++) p.push(o.child(S));
      m = m.matchFragment(o);
    }
    let v = u.size + e - (l.content.size - l.openEnd);
    for (; f < u.childCount; ) {
      let S = u.child(f),
        C = m.matchType(S.type);
      if (!C) break;
      f++,
        (f > 1 || c == 0 || S.content.size) &&
          ((m = C),
          p.push(
            Mb(
              S.mark(y.allowedMarks(S.marks)),
              f == 1 ? c : 0,
              f == u.childCount ? v : -1
            )
          ));
    }
    let x = f == u.childCount;
    x || (v = -1),
      (this.placed = Yl(this.placed, n, J.from(p))),
      (this.frontier[n].match = m),
      x &&
        v < 0 &&
        r &&
        r.type == this.frontier[this.depth].type &&
        this.frontier.length > 1 &&
        this.closeFrontierNode();
    for (let S = 0, C = u; S < v; S++) {
      let E = C.lastChild;
      this.frontier.push({
        type: E.type,
        match: E.contentMatchAt(E.childCount),
      }),
        (C = E.content);
    }
    this.unplaced = x
      ? e == 0
        ? ae.empty
        : new ae(Ql(l.content, e - 1, 1), e - 1, v < 0 ? l.openEnd : e - 1)
      : new ae(Ql(l.content, e, f), l.openStart, l.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock) return -1;
    let e = this.frontier[this.depth],
      n;
    if (
      !e.type.isTextblock ||
      !dh(this.$to, this.$to.depth, e.type, e.match, !1) ||
      (this.$to.depth == this.depth &&
        (n = this.findCloseLevel(this.$to)) &&
        n.depth == this.depth)
    )
      return -1;
    let { depth: r } = this.$to,
      o = this.$to.after(r);
    for (; r > 1 && o == this.$to.end(--r); ) ++o;
    return o;
  }
  findCloseLevel(e) {
    e: for (let n = Math.min(this.depth, e.depth); n >= 0; n--) {
      let { match: r, type: o } = this.frontier[n],
        i = n < e.depth && e.end(n + 1) == e.pos + (e.depth - (n + 1)),
        l = dh(e, n, o, r, i);
      if (l) {
        for (let u = n - 1; u >= 0; u--) {
          let { match: c, type: f } = this.frontier[u],
            p = dh(e, u, f, c, !0);
          if (!p || p.childCount) continue e;
        }
        return {
          depth: n,
          fit: l,
          move: i ? e.doc.resolve(e.after(n + 1)) : e,
        };
      }
    }
  }
  close(e) {
    let n = this.findCloseLevel(e);
    if (!n) return null;
    for (; this.depth > n.depth; ) this.closeFrontierNode();
    n.fit.childCount && (this.placed = Yl(this.placed, n.depth, n.fit)),
      (e = n.move);
    for (let r = n.depth + 1; r <= e.depth; r++) {
      let o = e.node(r),
        i = o.type.contentMatch.fillBefore(o.content, !0, e.index(r));
      this.openFrontierNode(o.type, o.attrs, i);
    }
    return e;
  }
  openFrontierNode(e, n = null, r) {
    let o = this.frontier[this.depth];
    (o.match = o.match.matchType(e)),
      (this.placed = Yl(this.placed, this.depth, J.from(e.create(n, r)))),
      this.frontier.push({ type: e, match: e.contentMatch });
  }
  closeFrontierNode() {
    let n = this.frontier.pop().match.fillBefore(J.empty, !0);
    n.childCount && (this.placed = Yl(this.placed, this.frontier.length, n));
  }
}
function Ql(t, e, n) {
  return e == 0
    ? t.cutByIndex(n, t.childCount)
    : t.replaceChild(0, t.firstChild.copy(Ql(t.firstChild.content, e - 1, n)));
}
function Yl(t, e, n) {
  return e == 0
    ? t.append(n)
    : t.replaceChild(
        t.childCount - 1,
        t.lastChild.copy(Yl(t.lastChild.content, e - 1, n))
      );
}
function ch(t, e) {
  for (let n = 0; n < e; n++) t = t.firstChild.content;
  return t;
}
function Mb(t, e, n) {
  if (e <= 0) return t;
  let r = t.content;
  return (
    e > 1 &&
      (r = r.replaceChild(
        0,
        Mb(r.firstChild, e - 1, r.childCount == 1 ? n - 1 : 0)
      )),
    e > 0 &&
      ((r = t.type.contentMatch.fillBefore(r).append(r)),
      n <= 0 &&
        (r = r.append(
          t.type.contentMatch.matchFragment(r).fillBefore(J.empty, !0)
        ))),
    t.copy(r)
  );
}
function dh(t, e, n, r, o) {
  let i = t.node(e),
    l = o ? t.indexAfter(e) : t.index(e);
  if (l == i.childCount && !n.compatibleContent(i.type)) return null;
  let u = r.fillBefore(i.content, !0, l);
  return u && !uT(n, i.content, l) ? u : null;
}
function uT(t, e, n) {
  for (let r = n; r < e.childCount; r++)
    if (!t.allowsMarks(e.child(r).marks)) return !0;
  return !1;
}
function cT(t) {
  return t.spec.defining || t.spec.definingForContent;
}
function dT(t, e, n, r) {
  if (!r.size) return t.deleteRange(e, n);
  let o = t.doc.resolve(e),
    i = t.doc.resolve(n);
  if (Eb(o, i, r)) return t.step(new yt(e, n, r));
  let l = Tb(o, t.doc.resolve(n));
  l[l.length - 1] == 0 && l.pop();
  let u = -(o.depth + 1);
  l.unshift(u);
  for (let y = o.depth, v = o.pos - 1; y > 0; y--, v--) {
    let x = o.node(y).type.spec;
    if (x.defining || x.definingAsContext || x.isolating) break;
    l.indexOf(y) > -1 ? (u = y) : o.before(y) == v && l.splice(1, 0, -y);
  }
  let c = l.indexOf(u),
    f = [],
    p = r.openStart;
  for (let y = r.content, v = 0; ; v++) {
    let x = y.firstChild;
    if ((f.push(x), v == r.openStart)) break;
    y = x.content;
  }
  for (let y = p - 1; y >= 0; y--) {
    let v = f[y],
      x = cT(v.type);
    if (x && !v.sameMarkup(o.node(Math.abs(u) - 1))) p = y;
    else if (x || !v.type.isTextblock) break;
  }
  for (let y = r.openStart; y >= 0; y--) {
    let v = (y + p + 1) % (r.openStart + 1),
      x = f[v];
    if (x)
      for (let S = 0; S < l.length; S++) {
        let C = l[(S + c) % l.length],
          E = !0;
        C < 0 && ((E = !1), (C = -C));
        let N = o.node(C - 1),
          $ = o.index(C - 1);
        if (N.canReplaceWith($, $, x.type, x.marks))
          return t.replace(
            o.before(C),
            E ? i.after(C) : n,
            new ae(Ob(r.content, 0, r.openStart, v), v, r.openEnd)
          );
      }
  }
  let m = t.steps.length;
  for (
    let y = l.length - 1;
    y >= 0 && (t.replace(e, n, r), !(t.steps.length > m));
    y--
  ) {
    let v = l[y];
    v < 0 || ((e = o.before(v)), (n = i.after(v)));
  }
}
function Ob(t, e, n, r, o) {
  if (e < n) {
    let i = t.firstChild;
    t = t.replaceChild(0, i.copy(Ob(i.content, e + 1, n, r, i)));
  }
  if (e > r) {
    let i = o.contentMatchAt(0),
      l = i.fillBefore(t).append(t);
    t = l.append(i.matchFragment(l).fillBefore(J.empty, !0));
  }
  return t;
}
function fT(t, e, n, r) {
  if (!r.isInline && e == n && t.doc.resolve(e).parent.content.size) {
    let o = lT(t.doc, e, r.type);
    o != null && (e = n = o);
  }
  t.replaceRange(e, n, new ae(J.from(r), 0, 0));
}
function pT(t, e, n) {
  let r = t.doc.resolve(e),
    o = t.doc.resolve(n),
    i = Tb(r, o);
  for (let l = 0; l < i.length; l++) {
    let u = i[l],
      c = l == i.length - 1;
    if ((c && u == 0) || r.node(u).type.contentMatch.validEnd)
      return t.delete(r.start(u), o.end(u));
    if (
      u > 0 &&
      (c || r.node(u - 1).canReplace(r.index(u - 1), o.indexAfter(u - 1)))
    )
      return t.delete(r.before(u), o.after(u));
  }
  for (let l = 1; l <= r.depth && l <= o.depth; l++)
    if (
      e - r.start(l) == r.depth - l &&
      n > r.end(l) &&
      o.end(l) - n != o.depth - l &&
      r.start(l - 1) == o.start(l - 1) &&
      r.node(l - 1).canReplace(r.index(l - 1), o.index(l - 1))
    )
      return t.delete(r.before(l), n);
  t.delete(e, n);
}
function Tb(t, e) {
  let n = [],
    r = Math.min(t.depth, e.depth);
  for (let o = r; o >= 0; o--) {
    let i = t.start(o);
    if (
      i < t.pos - (t.depth - o) ||
      e.end(o) > e.pos + (e.depth - o) ||
      t.node(o).type.spec.isolating ||
      e.node(o).type.spec.isolating
    )
      break;
    (i == e.start(o) ||
      (o == t.depth &&
        o == e.depth &&
        t.parent.inlineContent &&
        e.parent.inlineContent &&
        o &&
        e.start(o - 1) == i - 1)) &&
      n.push(o);
  }
  return n;
}
class $s extends Lt {
  constructor(e, n, r) {
    super(), (this.pos = e), (this.attr = n), (this.value = r);
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n) return st.fail("No node at attribute step's position");
    let r = Object.create(null);
    for (let i in n.attrs) r[i] = n.attrs[i];
    r[this.attr] = this.value;
    let o = n.type.create(r, null, n.marks);
    return st.fromReplace(
      e,
      this.pos,
      this.pos + 1,
      new ae(J.from(o), 0, n.isLeaf ? 0 : 1)
    );
  }
  getMap() {
    return mn.empty;
  }
  invert(e) {
    return new $s(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new $s(n.pos, this.attr, this.value);
  }
  toJSON() {
    return {
      stepType: "attr",
      pos: this.pos,
      attr: this.attr,
      value: this.value,
    };
  }
  static fromJSON(e, n) {
    if (typeof n.pos != "number" || typeof n.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new $s(n.pos, n.attr, n.value);
  }
}
Lt.jsonID("attr", $s);
class wa extends Lt {
  constructor(e, n) {
    super(), (this.attr = e), (this.value = n);
  }
  apply(e) {
    let n = Object.create(null);
    for (let o in e.attrs) n[o] = e.attrs[o];
    n[this.attr] = this.value;
    let r = e.type.create(n, e.content, e.marks);
    return st.ok(r);
  }
  getMap() {
    return mn.empty;
  }
  invert(e) {
    return new wa(this.attr, e.attrs[this.attr]);
  }
  map(e) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new wa(n.attr, n.value);
  }
}
Lt.jsonID("docAttr", wa);
let Vs = class extends Error {};
Vs = function t(e) {
  let n = Error.call(this, e);
  return (n.__proto__ = t.prototype), n;
};
Vs.prototype = Object.create(Error.prototype);
Vs.prototype.constructor = Vs;
Vs.prototype.name = "TransformError";
class Nb {
  constructor(e) {
    (this.doc = e),
      (this.steps = []),
      (this.docs = []),
      (this.mapping = new va());
  }
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  step(e) {
    let n = this.maybeStep(e);
    if (n.failed) throw new Vs(n.failed);
    return this;
  }
  maybeStep(e) {
    let n = e.apply(this.doc);
    return n.failed || this.addStep(e, n.doc), n;
  }
  get docChanged() {
    return this.steps.length > 0;
  }
  addStep(e, n) {
    this.docs.push(this.doc),
      this.steps.push(e),
      this.mapping.appendMap(e.getMap()),
      (this.doc = n);
  }
  replace(e, n = e, r = ae.empty) {
    let o = jd(this.doc, e, n, r);
    return o && this.step(o), this;
  }
  replaceWith(e, n, r) {
    return this.replace(e, n, new ae(J.from(r), 0, 0));
  }
  delete(e, n) {
    return this.replace(e, n, ae.empty);
  }
  insert(e, n) {
    return this.replaceWith(e, e, n);
  }
  replaceRange(e, n, r) {
    return dT(this, e, n, r), this;
  }
  replaceRangeWith(e, n, r) {
    return fT(this, e, n, r), this;
  }
  deleteRange(e, n) {
    return pT(this, e, n), this;
  }
  lift(e, n) {
    return YO(this, e, n), this;
  }
  join(e, n = 1) {
    return sT(this, e, n), this;
  }
  wrap(e, n) {
    return eT(this, e, n), this;
  }
  setBlockType(e, n = e, r, o = null) {
    return tT(this, e, n, r, o), this;
  }
  setNodeMarkup(e, n, r = null, o) {
    return rT(this, e, n, r, o), this;
  }
  setNodeAttribute(e, n, r) {
    return this.step(new $s(e, n, r)), this;
  }
  setDocAttribute(e, n) {
    return this.step(new wa(e, n)), this;
  }
  addNodeMark(e, n) {
    return this.step(new Do(e, n)), this;
  }
  removeNodeMark(e, n) {
    if (!(n instanceof He)) {
      let r = this.doc.nodeAt(e);
      if (!r) throw new RangeError("No node at position " + e);
      if (((n = n.isInSet(r.marks)), !n)) return this;
    }
    return this.step(new Hs(e, n)), this;
  }
  split(e, n = 1, r) {
    return oT(this, e, n, r), this;
  }
  addMark(e, n, r) {
    return GO(this, e, n, r), this;
  }
  removeMark(e, n, r) {
    return JO(this, e, n, r), this;
  }
  clearIncompatible(e, n, r) {
    return rg(this, e, n, r), this;
  }
}
const fh = Object.create(null);
class Ae {
  constructor(e, n, r) {
    (this.$anchor = e),
      (this.$head = n),
      (this.ranges = r || [new hT(e.min(n), e.max(n))]);
  }
  get anchor() {
    return this.$anchor.pos;
  }
  get head() {
    return this.$head.pos;
  }
  get from() {
    return this.$from.pos;
  }
  get to() {
    return this.$to.pos;
  }
  get $from() {
    return this.ranges[0].$from;
  }
  get $to() {
    return this.ranges[0].$to;
  }
  get empty() {
    let e = this.ranges;
    for (let n = 0; n < e.length; n++)
      if (e[n].$from.pos != e[n].$to.pos) return !1;
    return !0;
  }
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  replace(e, n = ae.empty) {
    let r = n.content.lastChild,
      o = null;
    for (let u = 0; u < n.openEnd; u++) (o = r), (r = r.lastChild);
    let i = e.steps.length,
      l = this.ranges;
    for (let u = 0; u < l.length; u++) {
      let { $from: c, $to: f } = l[u],
        p = e.mapping.slice(i);
      e.replaceRange(p.map(c.pos), p.map(f.pos), u ? ae.empty : n),
        u == 0 && I1(e, i, (r ? r.isInline : o && o.isTextblock) ? -1 : 1);
    }
  }
  replaceWith(e, n) {
    let r = e.steps.length,
      o = this.ranges;
    for (let i = 0; i < o.length; i++) {
      let { $from: l, $to: u } = o[i],
        c = e.mapping.slice(r),
        f = c.map(l.pos),
        p = c.map(u.pos);
      i
        ? e.deleteRange(f, p)
        : (e.replaceRangeWith(f, p, n), I1(e, r, n.isInline ? -1 : 1));
    }
  }
  static findFrom(e, n, r = !1) {
    let o = e.parent.inlineContent
      ? new Te(e)
      : Ts(e.node(0), e.parent, e.pos, e.index(), n, r);
    if (o) return o;
    for (let i = e.depth - 1; i >= 0; i--) {
      let l =
        n < 0
          ? Ts(e.node(0), e.node(i), e.before(i + 1), e.index(i), n, r)
          : Ts(e.node(0), e.node(i), e.after(i + 1), e.index(i) + 1, n, r);
      if (l) return l;
    }
    return null;
  }
  static near(e, n = 1) {
    return this.findFrom(e, n) || this.findFrom(e, -n) || new Nn(e.node(0));
  }
  static atStart(e) {
    return Ts(e, e, 0, 0, 1) || new Nn(e);
  }
  static atEnd(e) {
    return Ts(e, e, e.content.size, e.childCount, -1) || new Nn(e);
  }
  static fromJSON(e, n) {
    if (!n || !n.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let r = fh[n.type];
    if (!r) throw new RangeError(`No selection type ${n.type} defined`);
    return r.fromJSON(e, n);
  }
  static jsonID(e, n) {
    if (e in fh)
      throw new RangeError("Duplicate use of selection JSON ID " + e);
    return (fh[e] = n), (n.prototype.jsonID = e), n;
  }
  getBookmark() {
    return Te.between(this.$anchor, this.$head).getBookmark();
  }
}
Ae.prototype.visible = !0;
class hT {
  constructor(e, n) {
    (this.$from = e), (this.$to = n);
  }
}
let P1 = !1;
function D1(t) {
  !P1 &&
    !t.parent.inlineContent &&
    ((P1 = !0),
    console.warn(
      "TextSelection endpoint not pointing into a node with inline content (" +
        t.parent.type.name +
        ")"
    ));
}
class Te extends Ae {
  constructor(e, n = e) {
    D1(e), D1(n), super(e, n);
  }
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(e, n) {
    let r = e.resolve(n.map(this.head));
    if (!r.parent.inlineContent) return Ae.near(r);
    let o = e.resolve(n.map(this.anchor));
    return new Te(o.parent.inlineContent ? o : r, r);
  }
  replace(e, n = ae.empty) {
    if ((super.replace(e, n), n == ae.empty)) {
      let r = this.$from.marksAcross(this.$to);
      r && e.ensureMarks(r);
    }
  }
  eq(e) {
    return e instanceof Te && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new Bd(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  static fromJSON(e, n) {
    if (typeof n.anchor != "number" || typeof n.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new Te(e.resolve(n.anchor), e.resolve(n.head));
  }
  static create(e, n, r = n) {
    let o = e.resolve(n);
    return new this(o, r == n ? o : e.resolve(r));
  }
  static between(e, n, r) {
    let o = e.pos - n.pos;
    if (((!r || o) && (r = o >= 0 ? 1 : -1), !n.parent.inlineContent)) {
      let i = Ae.findFrom(n, r, !0) || Ae.findFrom(n, -r, !0);
      if (i) n = i.$head;
      else return Ae.near(n, r);
    }
    return (
      e.parent.inlineContent ||
        (o == 0
          ? (e = n)
          : ((e = (Ae.findFrom(e, -r, !0) || Ae.findFrom(e, r, !0)).$anchor),
            e.pos < n.pos != o < 0 && (e = n))),
      new Te(e, n)
    );
  }
}
Ae.jsonID("text", Te);
class Bd {
  constructor(e, n) {
    (this.anchor = e), (this.head = n);
  }
  map(e) {
    return new Bd(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return Te.between(e.resolve(this.anchor), e.resolve(this.head));
  }
}
class ke extends Ae {
  constructor(e) {
    let n = e.nodeAfter,
      r = e.node(0).resolve(e.pos + n.nodeSize);
    super(e, r), (this.node = n);
  }
  map(e, n) {
    let { deleted: r, pos: o } = n.mapResult(this.anchor),
      i = e.resolve(o);
    return r ? Ae.near(i) : new ke(i);
  }
  content() {
    return new ae(J.from(this.node), 0, 0);
  }
  eq(e) {
    return e instanceof ke && e.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new ig(this.anchor);
  }
  static fromJSON(e, n) {
    if (typeof n.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new ke(e.resolve(n.anchor));
  }
  static create(e, n) {
    return new ke(e.resolve(n));
  }
  static isSelectable(e) {
    return !e.isText && e.type.spec.selectable !== !1;
  }
}
ke.prototype.visible = !1;
Ae.jsonID("node", ke);
class ig {
  constructor(e) {
    this.anchor = e;
  }
  map(e) {
    let { deleted: n, pos: r } = e.mapResult(this.anchor);
    return n ? new Bd(r, r) : new ig(r);
  }
  resolve(e) {
    let n = e.resolve(this.anchor),
      r = n.nodeAfter;
    return r && ke.isSelectable(r) ? new ke(n) : Ae.near(n);
  }
}
class Nn extends Ae {
  constructor(e) {
    super(e.resolve(0), e.resolve(e.content.size));
  }
  replace(e, n = ae.empty) {
    if (n == ae.empty) {
      e.delete(0, e.doc.content.size);
      let r = Ae.atStart(e.doc);
      r.eq(e.selection) || e.setSelection(r);
    } else super.replace(e, n);
  }
  toJSON() {
    return { type: "all" };
  }
  static fromJSON(e) {
    return new Nn(e);
  }
  map(e) {
    return new Nn(e);
  }
  eq(e) {
    return e instanceof Nn;
  }
  getBookmark() {
    return mT;
  }
}
Ae.jsonID("all", Nn);
const mT = {
  map() {
    return this;
  },
  resolve(t) {
    return new Nn(t);
  },
};
function Ts(t, e, n, r, o, i = !1) {
  if (e.inlineContent) return Te.create(t, n);
  for (let l = r - (o > 0 ? 0 : 1); o > 0 ? l < e.childCount : l >= 0; l += o) {
    let u = e.child(l);
    if (u.isAtom) {
      if (!i && ke.isSelectable(u))
        return ke.create(t, n - (o < 0 ? u.nodeSize : 0));
    } else {
      let c = Ts(t, u, n + o, o < 0 ? u.childCount : 0, o, i);
      if (c) return c;
    }
    n += u.nodeSize * o;
  }
  return null;
}
function I1(t, e, n) {
  let r = t.steps.length - 1;
  if (r < e) return;
  let o = t.steps[r];
  if (!(o instanceof yt || o instanceof vt)) return;
  let i = t.mapping.maps[r],
    l;
  i.forEach((u, c, f, p) => {
    l == null && (l = p);
  }),
    t.setSelection(Ae.near(t.doc.resolve(l), n));
}
const L1 = 1,
  $1 = 2,
  _1 = 4;
class gT extends Nb {
  constructor(e) {
    super(e.doc),
      (this.curSelectionFor = 0),
      (this.updated = 0),
      (this.meta = Object.create(null)),
      (this.time = Date.now()),
      (this.curSelection = e.selection),
      (this.storedMarks = e.storedMarks);
  }
  get selection() {
    return (
      this.curSelectionFor < this.steps.length &&
        ((this.curSelection = this.curSelection.map(
          this.doc,
          this.mapping.slice(this.curSelectionFor)
        )),
        (this.curSelectionFor = this.steps.length)),
      this.curSelection
    );
  }
  setSelection(e) {
    if (e.$from.doc != this.doc)
      throw new RangeError(
        "Selection passed to setSelection must point at the current document"
      );
    return (
      (this.curSelection = e),
      (this.curSelectionFor = this.steps.length),
      (this.updated = (this.updated | L1) & -3),
      (this.storedMarks = null),
      this
    );
  }
  get selectionSet() {
    return (this.updated & L1) > 0;
  }
  setStoredMarks(e) {
    return (this.storedMarks = e), (this.updated |= $1), this;
  }
  ensureMarks(e) {
    return (
      He.sameSet(this.storedMarks || this.selection.$from.marks(), e) ||
        this.setStoredMarks(e),
      this
    );
  }
  addStoredMark(e) {
    return this.ensureMarks(
      e.addToSet(this.storedMarks || this.selection.$head.marks())
    );
  }
  removeStoredMark(e) {
    return this.ensureMarks(
      e.removeFromSet(this.storedMarks || this.selection.$head.marks())
    );
  }
  get storedMarksSet() {
    return (this.updated & $1) > 0;
  }
  addStep(e, n) {
    super.addStep(e, n),
      (this.updated = this.updated & -3),
      (this.storedMarks = null);
  }
  setTime(e) {
    return (this.time = e), this;
  }
  replaceSelection(e) {
    return this.selection.replace(this, e), this;
  }
  replaceSelectionWith(e, n = !0) {
    let r = this.selection;
    return (
      n &&
        (e = e.mark(
          this.storedMarks ||
            (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || He.none)
        )),
      r.replaceWith(this, e),
      this
    );
  }
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  insertText(e, n, r) {
    let o = this.doc.type.schema;
    if (n == null)
      return e
        ? this.replaceSelectionWith(o.text(e), !0)
        : this.deleteSelection();
    {
      if ((r == null && (r = n), (r = r ?? n), !e))
        return this.deleteRange(n, r);
      let i = this.storedMarks;
      if (!i) {
        let l = this.doc.resolve(n);
        i = r == n ? l.marks() : l.marksAcross(this.doc.resolve(r));
      }
      return (
        this.replaceRangeWith(n, r, o.text(e, i)),
        this.selection.empty || this.setSelection(Ae.near(this.selection.$to)),
        this
      );
    }
  }
  setMeta(e, n) {
    return (this.meta[typeof e == "string" ? e : e.key] = n), this;
  }
  getMeta(e) {
    return this.meta[typeof e == "string" ? e : e.key];
  }
  get isGeneric() {
    for (let e in this.meta) return !1;
    return !0;
  }
  scrollIntoView() {
    return (this.updated |= _1), this;
  }
  get scrolledIntoView() {
    return (this.updated & _1) > 0;
  }
}
function F1(t, e) {
  return !e || !t ? t : t.bind(e);
}
class Xl {
  constructor(e, n, r) {
    (this.name = e), (this.init = F1(n.init, r)), (this.apply = F1(n.apply, r));
  }
}
const yT = [
  new Xl("doc", {
    init(t) {
      return t.doc || t.schema.topNodeType.createAndFill();
    },
    apply(t) {
      return t.doc;
    },
  }),
  new Xl("selection", {
    init(t, e) {
      return t.selection || Ae.atStart(e.doc);
    },
    apply(t) {
      return t.selection;
    },
  }),
  new Xl("storedMarks", {
    init(t) {
      return t.storedMarks || null;
    },
    apply(t, e, n, r) {
      return r.selection.$cursor ? t.storedMarks : null;
    },
  }),
  new Xl("scrollToSelection", {
    init() {
      return 0;
    },
    apply(t, e) {
      return t.scrolledIntoView ? e + 1 : e;
    },
  }),
];
class ph {
  constructor(e, n) {
    (this.schema = e),
      (this.plugins = []),
      (this.pluginsByKey = Object.create(null)),
      (this.fields = yT.slice()),
      n &&
        n.forEach((r) => {
          if (this.pluginsByKey[r.key])
            throw new RangeError(
              "Adding different instances of a keyed plugin (" + r.key + ")"
            );
          this.plugins.push(r),
            (this.pluginsByKey[r.key] = r),
            r.spec.state && this.fields.push(new Xl(r.key, r.spec.state, r));
        });
  }
}
class Ds {
  constructor(e) {
    this.config = e;
  }
  get schema() {
    return this.config.schema;
  }
  get plugins() {
    return this.config.plugins;
  }
  apply(e) {
    return this.applyTransaction(e).state;
  }
  filterTransaction(e, n = -1) {
    for (let r = 0; r < this.config.plugins.length; r++)
      if (r != n) {
        let o = this.config.plugins[r];
        if (
          o.spec.filterTransaction &&
          !o.spec.filterTransaction.call(o, e, this)
        )
          return !1;
      }
    return !0;
  }
  applyTransaction(e) {
    if (!this.filterTransaction(e)) return { state: this, transactions: [] };
    let n = [e],
      r = this.applyInner(e),
      o = null;
    for (;;) {
      let i = !1;
      for (let l = 0; l < this.config.plugins.length; l++) {
        let u = this.config.plugins[l];
        if (u.spec.appendTransaction) {
          let c = o ? o[l].n : 0,
            f = o ? o[l].state : this,
            p =
              c < n.length &&
              u.spec.appendTransaction.call(u, c ? n.slice(c) : n, f, r);
          if (p && r.filterTransaction(p, l)) {
            if ((p.setMeta("appendedTransaction", e), !o)) {
              o = [];
              for (let m = 0; m < this.config.plugins.length; m++)
                o.push(
                  m < l ? { state: r, n: n.length } : { state: this, n: 0 }
                );
            }
            n.push(p), (r = r.applyInner(p)), (i = !0);
          }
          o && (o[l] = { state: r, n: n.length });
        }
      }
      if (!i) return { state: r, transactions: n };
    }
  }
  applyInner(e) {
    if (!e.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let n = new Ds(this.config),
      r = this.config.fields;
    for (let o = 0; o < r.length; o++) {
      let i = r[o];
      n[i.name] = i.apply(e, this[i.name], this, n);
    }
    return n;
  }
  get tr() {
    return new gT(this);
  }
  static create(e) {
    let n = new ph(e.doc ? e.doc.type.schema : e.schema, e.plugins),
      r = new Ds(n);
    for (let o = 0; o < n.fields.length; o++)
      r[n.fields[o].name] = n.fields[o].init(e, r);
    return r;
  }
  reconfigure(e) {
    let n = new ph(this.schema, e.plugins),
      r = n.fields,
      o = new Ds(n);
    for (let i = 0; i < r.length; i++) {
      let l = r[i].name;
      o[l] = this.hasOwnProperty(l) ? this[l] : r[i].init(e, o);
    }
    return o;
  }
  toJSON(e) {
    let n = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (
      (this.storedMarks &&
        (n.storedMarks = this.storedMarks.map((r) => r.toJSON())),
      e && typeof e == "object")
    )
      for (let r in e) {
        if (r == "doc" || r == "selection")
          throw new RangeError(
            "The JSON fields `doc` and `selection` are reserved"
          );
        let o = e[r],
          i = o.spec.state;
        i && i.toJSON && (n[r] = i.toJSON.call(o, this[o.key]));
      }
    return n;
  }
  static fromJSON(e, n, r) {
    if (!n) throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!e.schema)
      throw new RangeError("Required config field 'schema' missing");
    let o = new ph(e.schema, e.plugins),
      i = new Ds(o);
    return (
      o.fields.forEach((l) => {
        if (l.name == "doc") i.doc = $o.fromJSON(e.schema, n.doc);
        else if (l.name == "selection")
          i.selection = Ae.fromJSON(i.doc, n.selection);
        else if (l.name == "storedMarks")
          n.storedMarks &&
            (i.storedMarks = n.storedMarks.map(e.schema.markFromJSON));
        else {
          if (r)
            for (let u in r) {
              let c = r[u],
                f = c.spec.state;
              if (
                c.key == l.name &&
                f &&
                f.fromJSON &&
                Object.prototype.hasOwnProperty.call(n, u)
              ) {
                i[l.name] = f.fromJSON.call(c, e, n[u], i);
                return;
              }
            }
          i[l.name] = l.init(e, i);
        }
      }),
      i
    );
  }
}
function Ab(t, e, n) {
  for (let r in t) {
    let o = t[r];
    o instanceof Function
      ? (o = o.bind(e))
      : r == "handleDOMEvents" && (o = Ab(o, e, {})),
      (n[r] = o);
  }
  return n;
}
class pt {
  constructor(e) {
    (this.spec = e),
      (this.props = {}),
      e.props && Ab(e.props, this, this.props),
      (this.key = e.key ? e.key.key : Rb("plugin"));
  }
  getState(e) {
    return e[this.key];
  }
}
const hh = Object.create(null);
function Rb(t) {
  return t in hh ? t + "$" + ++hh[t] : ((hh[t] = 0), t + "$");
}
class Wt {
  constructor(e = "key") {
    this.key = Rb(e);
  }
  get(e) {
    return e.config.pluginsByKey[this.key];
  }
  getState(e) {
    return e[this.key];
  }
}
const kt = function (t) {
    for (var e = 0; ; e++) if (((t = t.previousSibling), !t)) return e;
  },
  Ws = function (t) {
    let e = t.assignedSlot || t.parentNode;
    return e && e.nodeType == 11 ? e.host : e;
  };
let cm = null;
const Hr = function (t, e, n) {
    let r = cm || (cm = document.createRange());
    return r.setEnd(t, n ?? t.nodeValue.length), r.setStart(t, e || 0), r;
  },
  vT = function () {
    cm = null;
  },
  Li = function (t, e, n, r) {
    return n && (z1(t, e, n, r, -1) || z1(t, e, n, r, 1));
  },
  wT = /^(img|br|input|textarea|hr)$/i;
function z1(t, e, n, r, o) {
  for (;;) {
    if (t == n && e == r) return !0;
    if (e == (o < 0 ? 0 : On(t))) {
      let i = t.parentNode;
      if (
        !i ||
        i.nodeType != 1 ||
        La(t) ||
        wT.test(t.nodeName) ||
        t.contentEditable == "false"
      )
        return !1;
      (e = kt(t) + (o < 0 ? 0 : 1)), (t = i);
    } else if (t.nodeType == 1) {
      if (
        ((t = t.childNodes[e + (o < 0 ? -1 : 0)]), t.contentEditable == "false")
      )
        return !1;
      e = o < 0 ? On(t) : 0;
    } else return !1;
  }
}
function On(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function xT(t, e) {
  for (;;) {
    if (t.nodeType == 3 && e) return t;
    if (t.nodeType == 1 && e > 0) {
      if (t.contentEditable == "false") return null;
      (t = t.childNodes[e - 1]), (e = On(t));
    } else if (t.parentNode && !La(t)) (e = kt(t)), (t = t.parentNode);
    else return null;
  }
}
function bT(t, e) {
  for (;;) {
    if (t.nodeType == 3 && e < t.nodeValue.length) return t;
    if (t.nodeType == 1 && e < t.childNodes.length) {
      if (t.contentEditable == "false") return null;
      (t = t.childNodes[e]), (e = 0);
    } else if (t.parentNode && !La(t)) (e = kt(t) + 1), (t = t.parentNode);
    else return null;
  }
}
function ST(t, e, n) {
  for (let r = e == 0, o = e == On(t); r || o; ) {
    if (t == n) return !0;
    let i = kt(t);
    if (((t = t.parentNode), !t)) return !1;
    (r = r && i == 0), (o = o && i == On(t));
  }
}
function La(t) {
  let e;
  for (let n = t; n && !(e = n.pmViewDesc); n = n.parentNode);
  return e && e.node && e.node.isBlock && (e.dom == t || e.contentDOM == t);
}
const Hd = function (t) {
  return (
    t.focusNode && Li(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset)
  );
};
function bi(t, e) {
  let n = document.createEvent("Event");
  return (
    n.initEvent("keydown", !0, !0), (n.keyCode = t), (n.key = n.code = e), n
  );
}
function CT(t) {
  let e = t.activeElement;
  for (; e && e.shadowRoot; ) e = e.shadowRoot.activeElement;
  return e;
}
function kT(t, e, n) {
  if (t.caretPositionFromPoint)
    try {
      let r = t.caretPositionFromPoint(e, n);
      if (r)
        return {
          node: r.offsetNode,
          offset: Math.min(On(r.offsetNode), r.offset),
        };
    } catch {}
  if (t.caretRangeFromPoint) {
    let r = t.caretRangeFromPoint(e, n);
    if (r)
      return {
        node: r.startContainer,
        offset: Math.min(On(r.startContainer), r.startOffset),
      };
  }
}
const gr = typeof navigator < "u" ? navigator : null,
  j1 = typeof document < "u" ? document : null,
  qo = (gr && gr.userAgent) || "",
  dm = /Edge\/(\d+)/.exec(qo),
  Pb = /MSIE \d/.exec(qo),
  fm = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(qo),
  tn = !!(Pb || fm || dm),
  Fo = Pb ? document.documentMode : fm ? +fm[1] : dm ? +dm[1] : 0,
  qn = !tn && /gecko\/(\d+)/i.test(qo);
qn && +(/Firefox\/(\d+)/.exec(qo) || [0, 0])[1];
const pm = !tn && /Chrome\/(\d+)/.exec(qo),
  It = !!pm,
  Db = pm ? +pm[1] : 0,
  jt = !tn && !!gr && /Apple Computer/.test(gr.vendor),
  Us = jt && (/Mobile\/\w+/.test(qo) || (!!gr && gr.maxTouchPoints > 2)),
  Mn = Us || (gr ? /Mac/.test(gr.platform) : !1),
  ET = gr ? /Win/.test(gr.platform) : !1,
  Vr = /Android \d/.test(qo),
  $a = !!j1 && "webkitFontSmoothing" in j1.documentElement.style,
  MT = $a
    ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1]
    : 0;
function OT(t) {
  let e = t.defaultView && t.defaultView.visualViewport;
  return e
    ? { left: 0, right: e.width, top: 0, bottom: e.height }
    : {
        left: 0,
        right: t.documentElement.clientWidth,
        top: 0,
        bottom: t.documentElement.clientHeight,
      };
}
function $r(t, e) {
  return typeof t == "number" ? t : t[e];
}
function TT(t) {
  let e = t.getBoundingClientRect(),
    n = e.width / t.offsetWidth || 1,
    r = e.height / t.offsetHeight || 1;
  return {
    left: e.left,
    right: e.left + t.clientWidth * n,
    top: e.top,
    bottom: e.top + t.clientHeight * r,
  };
}
function B1(t, e, n) {
  let r = t.someProp("scrollThreshold") || 0,
    o = t.someProp("scrollMargin") || 5,
    i = t.dom.ownerDocument;
  for (let l = n || t.dom; l; ) {
    if (l.nodeType != 1) {
      l = Ws(l);
      continue;
    }
    let u = l,
      c = u == i.body,
      f = c ? OT(i) : TT(u),
      p = 0,
      m = 0;
    if (
      (e.top < f.top + $r(r, "top")
        ? (m = -(f.top - e.top + $r(o, "top")))
        : e.bottom > f.bottom - $r(r, "bottom") &&
          (m =
            e.bottom - e.top > f.bottom - f.top
              ? e.top + $r(o, "top") - f.top
              : e.bottom - f.bottom + $r(o, "bottom")),
      e.left < f.left + $r(r, "left")
        ? (p = -(f.left - e.left + $r(o, "left")))
        : e.right > f.right - $r(r, "right") &&
          (p = e.right - f.right + $r(o, "right")),
      p || m)
    )
      if (c) i.defaultView.scrollBy(p, m);
      else {
        let v = u.scrollLeft,
          x = u.scrollTop;
        m && (u.scrollTop += m), p && (u.scrollLeft += p);
        let S = u.scrollLeft - v,
          C = u.scrollTop - x;
        e = {
          left: e.left - S,
          top: e.top - C,
          right: e.right - S,
          bottom: e.bottom - C,
        };
      }
    let y = c ? "fixed" : getComputedStyle(l).position;
    if (/^(fixed|sticky)$/.test(y)) break;
    l = y == "absolute" ? l.offsetParent : Ws(l);
  }
}
function NT(t) {
  let e = t.dom.getBoundingClientRect(),
    n = Math.max(0, e.top),
    r,
    o;
  for (
    let i = (e.left + e.right) / 2, l = n + 1;
    l < Math.min(innerHeight, e.bottom);
    l += 5
  ) {
    let u = t.root.elementFromPoint(i, l);
    if (!u || u == t.dom || !t.dom.contains(u)) continue;
    let c = u.getBoundingClientRect();
    if (c.top >= n - 20) {
      (r = u), (o = c.top);
      break;
    }
  }
  return { refDOM: r, refTop: o, stack: Ib(t.dom) };
}
function Ib(t) {
  let e = [],
    n = t.ownerDocument;
  for (
    let r = t;
    r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), t != n);
    r = Ws(r)
  );
  return e;
}
function AT({ refDOM: t, refTop: e, stack: n }) {
  let r = t ? t.getBoundingClientRect().top : 0;
  Lb(n, r == 0 ? 0 : r - e);
}
function Lb(t, e) {
  for (let n = 0; n < t.length; n++) {
    let { dom: r, top: o, left: i } = t[n];
    r.scrollTop != o + e && (r.scrollTop = o + e),
      r.scrollLeft != i && (r.scrollLeft = i);
  }
}
let xs = null;
function RT(t) {
  if (t.setActive) return t.setActive();
  if (xs) return t.focus(xs);
  let e = Ib(t);
  t.focus(
    xs == null
      ? {
          get preventScroll() {
            return (xs = { preventScroll: !0 }), !0;
          },
        }
      : void 0
  ),
    xs || ((xs = !1), Lb(e, 0));
}
function $b(t, e) {
  let n,
    r = 2e8,
    o,
    i = 0,
    l = e.top,
    u = e.top,
    c,
    f;
  for (let p = t.firstChild, m = 0; p; p = p.nextSibling, m++) {
    let y;
    if (p.nodeType == 1) y = p.getClientRects();
    else if (p.nodeType == 3) y = Hr(p).getClientRects();
    else continue;
    for (let v = 0; v < y.length; v++) {
      let x = y[v];
      if (x.top <= l && x.bottom >= u) {
        (l = Math.max(x.bottom, l)), (u = Math.min(x.top, u));
        let S =
          x.left > e.left
            ? x.left - e.left
            : x.right < e.left
            ? e.left - x.right
            : 0;
        if (S < r) {
          (n = p),
            (r = S),
            (o =
              S && n.nodeType == 3
                ? { left: x.right < e.left ? x.right : x.left, top: e.top }
                : e),
            p.nodeType == 1 &&
              S &&
              (i = m + (e.left >= (x.left + x.right) / 2 ? 1 : 0));
          continue;
        }
      } else
        x.top > e.top &&
          !c &&
          x.left <= e.left &&
          x.right >= e.left &&
          ((c = p),
          (f = {
            left: Math.max(x.left, Math.min(x.right, e.left)),
            top: x.top,
          }));
      !n &&
        ((e.left >= x.right && e.top >= x.top) ||
          (e.left >= x.left && e.top >= x.bottom)) &&
        (i = m + 1);
    }
  }
  return (
    !n && c && ((n = c), (o = f), (r = 0)),
    n && n.nodeType == 3
      ? PT(n, o)
      : !n || (r && n.nodeType == 1)
      ? { node: t, offset: i }
      : $b(n, o)
  );
}
function PT(t, e) {
  let n = t.nodeValue.length,
    r = document.createRange();
  for (let o = 0; o < n; o++) {
    r.setEnd(t, o + 1), r.setStart(t, o);
    let i = So(r, 1);
    if (i.top != i.bottom && sg(e, i))
      return {
        node: t,
        offset: o + (e.left >= (i.left + i.right) / 2 ? 1 : 0),
      };
  }
  return { node: t, offset: 0 };
}
function sg(t, e) {
  return (
    t.left >= e.left - 1 &&
    t.left <= e.right + 1 &&
    t.top >= e.top - 1 &&
    t.top <= e.bottom + 1
  );
}
function DT(t, e) {
  let n = t.parentNode;
  return n &&
    /^li$/i.test(n.nodeName) &&
    e.left < t.getBoundingClientRect().left
    ? n
    : t;
}
function IT(t, e, n) {
  let { node: r, offset: o } = $b(e, n),
    i = -1;
  if (r.nodeType == 1 && !r.firstChild) {
    let l = r.getBoundingClientRect();
    i = l.left != l.right && n.left > (l.left + l.right) / 2 ? 1 : -1;
  }
  return t.docView.posFromDOM(r, o, i);
}
function LT(t, e, n, r) {
  let o = -1;
  for (let i = e, l = !1; i != t.dom; ) {
    let u = t.docView.nearestDesc(i, !0),
      c;
    if (!u) return null;
    if (
      u.dom.nodeType == 1 &&
      ((u.node.isBlock && u.parent) || !u.contentDOM) &&
      ((c = u.dom.getBoundingClientRect()).width || c.height) &&
      (u.node.isBlock &&
        u.parent &&
        ((!l && c.left > r.left) || c.top > r.top
          ? (o = u.posBefore)
          : ((!l && c.right < r.left) || c.bottom < r.top) && (o = u.posAfter),
        (l = !0)),
      !u.contentDOM && o < 0 && !u.node.isText)
    )
      return (
        u.node.isBlock
          ? r.top < (c.top + c.bottom) / 2
          : r.left < (c.left + c.right) / 2
      )
        ? u.posBefore
        : u.posAfter;
    i = u.dom.parentNode;
  }
  return o > -1 ? o : t.docView.posFromDOM(e, n, -1);
}
function _b(t, e, n) {
  let r = t.childNodes.length;
  if (r && n.top < n.bottom)
    for (
      let o = Math.max(
          0,
          Math.min(
            r - 1,
            Math.floor((r * (e.top - n.top)) / (n.bottom - n.top)) - 2
          )
        ),
        i = o;
      ;

    ) {
      let l = t.childNodes[i];
      if (l.nodeType == 1) {
        let u = l.getClientRects();
        for (let c = 0; c < u.length; c++) {
          let f = u[c];
          if (sg(e, f)) return _b(l, e, f);
        }
      }
      if ((i = (i + 1) % r) == o) break;
    }
  return t;
}
function $T(t, e) {
  let n = t.dom.ownerDocument,
    r,
    o = 0,
    i = kT(n, e.left, e.top);
  i && ({ node: r, offset: o } = i);
  let l = (t.root.elementFromPoint ? t.root : n).elementFromPoint(
      e.left,
      e.top
    ),
    u;
  if (!l || !t.dom.contains(l.nodeType != 1 ? l.parentNode : l)) {
    let f = t.dom.getBoundingClientRect();
    if (!sg(e, f) || ((l = _b(t.dom, e, f)), !l)) return null;
  }
  if (jt) for (let f = l; r && f; f = Ws(f)) f.draggable && (r = void 0);
  if (((l = DT(l, e)), r)) {
    if (
      qn &&
      r.nodeType == 1 &&
      ((o = Math.min(o, r.childNodes.length)), o < r.childNodes.length)
    ) {
      let p = r.childNodes[o],
        m;
      p.nodeName == "IMG" &&
        (m = p.getBoundingClientRect()).right <= e.left &&
        m.bottom > e.top &&
        o++;
    }
    let f;
    $a &&
      o &&
      r.nodeType == 1 &&
      (f = r.childNodes[o - 1]).nodeType == 1 &&
      f.contentEditable == "false" &&
      f.getBoundingClientRect().top >= e.top &&
      o--,
      r == t.dom &&
      o == r.childNodes.length - 1 &&
      r.lastChild.nodeType == 1 &&
      e.top > r.lastChild.getBoundingClientRect().bottom
        ? (u = t.state.doc.content.size)
        : (o == 0 || r.nodeType != 1 || r.childNodes[o - 1].nodeName != "BR") &&
          (u = LT(t, r, o, e));
  }
  u == null && (u = IT(t, l, e));
  let c = t.docView.nearestDesc(l, !0);
  return { pos: u, inside: c ? c.posAtStart - c.border : -1 };
}
function H1(t) {
  return t.top < t.bottom || t.left < t.right;
}
function So(t, e) {
  let n = t.getClientRects();
  if (n.length) {
    let r = n[e < 0 ? 0 : n.length - 1];
    if (H1(r)) return r;
  }
  return Array.prototype.find.call(n, H1) || t.getBoundingClientRect();
}
const _T = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function Fb(t, e, n) {
  let { node: r, offset: o, atom: i } = t.docView.domFromPos(e, n < 0 ? -1 : 1),
    l = $a || qn;
  if (r.nodeType == 3)
    if (l && (_T.test(r.nodeValue) || (n < 0 ? !o : o == r.nodeValue.length))) {
      let c = So(Hr(r, o, o), n);
      if (qn && o && /\s/.test(r.nodeValue[o - 1]) && o < r.nodeValue.length) {
        let f = So(Hr(r, o - 1, o - 1), -1);
        if (f.top == c.top) {
          let p = So(Hr(r, o, o + 1), -1);
          if (p.top != c.top) return Wl(p, p.left < f.left);
        }
      }
      return c;
    } else {
      let c = o,
        f = o,
        p = n < 0 ? 1 : -1;
      return (
        n < 0 && !o
          ? (f++, (p = -1))
          : n >= 0 && o == r.nodeValue.length
          ? (c--, (p = 1))
          : n < 0
          ? c--
          : f++,
        Wl(So(Hr(r, c, f), p), p < 0)
      );
    }
  if (!t.state.doc.resolve(e - (i || 0)).parent.inlineContent) {
    if (i == null && o && (n < 0 || o == On(r))) {
      let c = r.childNodes[o - 1];
      if (c.nodeType == 1) return mh(c.getBoundingClientRect(), !1);
    }
    if (i == null && o < On(r)) {
      let c = r.childNodes[o];
      if (c.nodeType == 1) return mh(c.getBoundingClientRect(), !0);
    }
    return mh(r.getBoundingClientRect(), n >= 0);
  }
  if (i == null && o && (n < 0 || o == On(r))) {
    let c = r.childNodes[o - 1],
      f =
        c.nodeType == 3
          ? Hr(c, On(c) - (l ? 0 : 1))
          : c.nodeType == 1 && (c.nodeName != "BR" || !c.nextSibling)
          ? c
          : null;
    if (f) return Wl(So(f, 1), !1);
  }
  if (i == null && o < On(r)) {
    let c = r.childNodes[o];
    for (; c.pmViewDesc && c.pmViewDesc.ignoreForCoords; ) c = c.nextSibling;
    let f = c
      ? c.nodeType == 3
        ? Hr(c, 0, l ? 0 : 1)
        : c.nodeType == 1
        ? c
        : null
      : null;
    if (f) return Wl(So(f, -1), !0);
  }
  return Wl(So(r.nodeType == 3 ? Hr(r) : r, -n), n >= 0);
}
function Wl(t, e) {
  if (t.width == 0) return t;
  let n = e ? t.left : t.right;
  return { top: t.top, bottom: t.bottom, left: n, right: n };
}
function mh(t, e) {
  if (t.height == 0) return t;
  let n = e ? t.top : t.bottom;
  return { top: n, bottom: n, left: t.left, right: t.right };
}
function zb(t, e, n) {
  let r = t.state,
    o = t.root.activeElement;
  r != e && t.updateState(e), o != t.dom && t.focus();
  try {
    return n();
  } finally {
    r != e && t.updateState(r), o != t.dom && o && o.focus();
  }
}
function FT(t, e, n) {
  let r = e.selection,
    o = n == "up" ? r.$from : r.$to;
  return zb(t, e, () => {
    let { node: i } = t.docView.domFromPos(o.pos, n == "up" ? -1 : 1);
    for (;;) {
      let u = t.docView.nearestDesc(i, !0);
      if (!u) break;
      if (u.node.isBlock) {
        i = u.contentDOM || u.dom;
        break;
      }
      i = u.dom.parentNode;
    }
    let l = Fb(t, o.pos, 1);
    for (let u = i.firstChild; u; u = u.nextSibling) {
      let c;
      if (u.nodeType == 1) c = u.getClientRects();
      else if (u.nodeType == 3)
        c = Hr(u, 0, u.nodeValue.length).getClientRects();
      else continue;
      for (let f = 0; f < c.length; f++) {
        let p = c[f];
        if (
          p.bottom > p.top + 1 &&
          (n == "up"
            ? l.top - p.top > (p.bottom - l.top) * 2
            : p.bottom - l.bottom > (l.bottom - p.top) * 2)
        )
          return !1;
      }
    }
    return !0;
  });
}
const zT = /[\u0590-\u08ac]/;
function jT(t, e, n) {
  let { $head: r } = e.selection;
  if (!r.parent.isTextblock) return !1;
  let o = r.parentOffset,
    i = !o,
    l = o == r.parent.content.size,
    u = t.domSelection();
  return u
    ? !zT.test(r.parent.textContent) || !u.modify
      ? n == "left" || n == "backward"
        ? i
        : l
      : zb(t, e, () => {
          let {
              focusNode: c,
              focusOffset: f,
              anchorNode: p,
              anchorOffset: m,
            } = t.domSelectionRange(),
            y = u.caretBidiLevel;
          u.modify("move", n, "character");
          let v = r.depth ? t.docView.domAfterPos(r.before()) : t.dom,
            { focusNode: x, focusOffset: S } = t.domSelectionRange(),
            C =
              (x && !v.contains(x.nodeType == 1 ? x : x.parentNode)) ||
              (c == x && f == S);
          try {
            u.collapse(p, m),
              c && (c != p || f != m) && u.extend && u.extend(c, f);
          } catch {}
          return y != null && (u.caretBidiLevel = y), C;
        })
    : r.pos == r.start() || r.pos == r.end();
}
let V1 = null,
  W1 = null,
  U1 = !1;
function BT(t, e, n) {
  return V1 == e && W1 == n
    ? U1
    : ((V1 = e),
      (W1 = n),
      (U1 = n == "up" || n == "down" ? FT(t, e, n) : jT(t, e, n)));
}
const An = 0,
  K1 = 1,
  ki = 2,
  yr = 3;
class _a {
  constructor(e, n, r, o) {
    (this.parent = e),
      (this.children = n),
      (this.dom = r),
      (this.contentDOM = o),
      (this.dirty = An),
      (r.pmViewDesc = this);
  }
  matchesWidget(e) {
    return !1;
  }
  matchesMark(e) {
    return !1;
  }
  matchesNode(e, n, r) {
    return !1;
  }
  matchesHack(e) {
    return !1;
  }
  parseRule() {
    return null;
  }
  stopEvent(e) {
    return !1;
  }
  get size() {
    let e = 0;
    for (let n = 0; n < this.children.length; n++) e += this.children[n].size;
    return e;
  }
  get border() {
    return 0;
  }
  destroy() {
    (this.parent = void 0),
      this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let e = 0; e < this.children.length; e++) this.children[e].destroy();
  }
  posBeforeChild(e) {
    for (let n = 0, r = this.posAtStart; ; n++) {
      let o = this.children[n];
      if (o == e) return r;
      r += o.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(e, n, r) {
    if (
      this.contentDOM &&
      this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode)
    )
      if (r < 0) {
        let i, l;
        if (e == this.contentDOM) i = e.childNodes[n - 1];
        else {
          for (; e.parentNode != this.contentDOM; ) e = e.parentNode;
          i = e.previousSibling;
        }
        for (; i && !((l = i.pmViewDesc) && l.parent == this); )
          i = i.previousSibling;
        return i ? this.posBeforeChild(l) + l.size : this.posAtStart;
      } else {
        let i, l;
        if (e == this.contentDOM) i = e.childNodes[n];
        else {
          for (; e.parentNode != this.contentDOM; ) e = e.parentNode;
          i = e.nextSibling;
        }
        for (; i && !((l = i.pmViewDesc) && l.parent == this); )
          i = i.nextSibling;
        return i ? this.posBeforeChild(l) : this.posAtEnd;
      }
    let o;
    if (e == this.dom && this.contentDOM) o = n > kt(this.contentDOM);
    else if (
      this.contentDOM &&
      this.contentDOM != this.dom &&
      this.dom.contains(this.contentDOM)
    )
      o = e.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (n == 0)
        for (let i = e; ; i = i.parentNode) {
          if (i == this.dom) {
            o = !1;
            break;
          }
          if (i.previousSibling) break;
        }
      if (o == null && n == e.childNodes.length)
        for (let i = e; ; i = i.parentNode) {
          if (i == this.dom) {
            o = !0;
            break;
          }
          if (i.nextSibling) break;
        }
    }
    return o ?? r > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(e, n = !1) {
    for (let r = !0, o = e; o; o = o.parentNode) {
      let i = this.getDesc(o),
        l;
      if (i && (!n || i.node))
        if (
          r &&
          (l = i.nodeDOM) &&
          !(l.nodeType == 1
            ? l.contains(e.nodeType == 1 ? e : e.parentNode)
            : l == e)
        )
          r = !1;
        else return i;
    }
  }
  getDesc(e) {
    let n = e.pmViewDesc;
    for (let r = n; r; r = r.parent) if (r == this) return n;
  }
  posFromDOM(e, n, r) {
    for (let o = e; o; o = o.parentNode) {
      let i = this.getDesc(o);
      if (i) return i.localPosFromDOM(e, n, r);
    }
    return -1;
  }
  descAt(e) {
    for (let n = 0, r = 0; n < this.children.length; n++) {
      let o = this.children[n],
        i = r + o.size;
      if (r == e && i != r) {
        for (; !o.border && o.children.length; )
          for (let l = 0; l < o.children.length; l++) {
            let u = o.children[l];
            if (u.size) {
              o = u;
              break;
            }
          }
        return o;
      }
      if (e < i) return o.descAt(e - r - o.border);
      r = i;
    }
  }
  domFromPos(e, n) {
    if (!this.contentDOM) return { node: this.dom, offset: 0, atom: e + 1 };
    let r = 0,
      o = 0;
    for (let i = 0; r < this.children.length; r++) {
      let l = this.children[r],
        u = i + l.size;
      if (u > e || l instanceof Bb) {
        o = e - i;
        break;
      }
      i = u;
    }
    if (o) return this.children[r].domFromPos(o - this.children[r].border, n);
    for (
      let i;
      r && !(i = this.children[r - 1]).size && i instanceof jb && i.side >= 0;
      r--
    );
    if (n <= 0) {
      let i,
        l = !0;
      for (
        ;
        (i = r ? this.children[r - 1] : null),
          !(!i || i.dom.parentNode == this.contentDOM);
        r--, l = !1
      );
      return i && n && l && !i.border && !i.domAtom
        ? i.domFromPos(i.size, n)
        : { node: this.contentDOM, offset: i ? kt(i.dom) + 1 : 0 };
    } else {
      let i,
        l = !0;
      for (
        ;
        (i = r < this.children.length ? this.children[r] : null),
          !(!i || i.dom.parentNode == this.contentDOM);
        r++, l = !1
      );
      return i && l && !i.border && !i.domAtom
        ? i.domFromPos(0, n)
        : {
            node: this.contentDOM,
            offset: i ? kt(i.dom) : this.contentDOM.childNodes.length,
          };
    }
  }
  parseRange(e, n, r = 0) {
    if (this.children.length == 0)
      return {
        node: this.contentDOM,
        from: e,
        to: n,
        fromOffset: 0,
        toOffset: this.contentDOM.childNodes.length,
      };
    let o = -1,
      i = -1;
    for (let l = r, u = 0; ; u++) {
      let c = this.children[u],
        f = l + c.size;
      if (o == -1 && e <= f) {
        let p = l + c.border;
        if (
          e >= p &&
          n <= f - c.border &&
          c.node &&
          c.contentDOM &&
          this.contentDOM.contains(c.contentDOM)
        )
          return c.parseRange(e, n, p);
        e = l;
        for (let m = u; m > 0; m--) {
          let y = this.children[m - 1];
          if (
            y.size &&
            y.dom.parentNode == this.contentDOM &&
            !y.emptyChildAt(1)
          ) {
            o = kt(y.dom) + 1;
            break;
          }
          e -= y.size;
        }
        o == -1 && (o = 0);
      }
      if (o > -1 && (f > n || u == this.children.length - 1)) {
        n = f;
        for (let p = u + 1; p < this.children.length; p++) {
          let m = this.children[p];
          if (
            m.size &&
            m.dom.parentNode == this.contentDOM &&
            !m.emptyChildAt(-1)
          ) {
            i = kt(m.dom);
            break;
          }
          n += m.size;
        }
        i == -1 && (i = this.contentDOM.childNodes.length);
        break;
      }
      l = f;
    }
    return {
      node: this.contentDOM,
      from: e,
      to: n,
      fromOffset: o,
      toOffset: i,
    };
  }
  emptyChildAt(e) {
    if (this.border || !this.contentDOM || !this.children.length) return !1;
    let n = this.children[e < 0 ? 0 : this.children.length - 1];
    return n.size == 0 || n.emptyChildAt(e);
  }
  domAfterPos(e) {
    let { node: n, offset: r } = this.domFromPos(e, 0);
    if (n.nodeType != 1 || r == n.childNodes.length)
      throw new RangeError("No node after pos " + e);
    return n.childNodes[r];
  }
  setSelection(e, n, r, o = !1) {
    let i = Math.min(e, n),
      l = Math.max(e, n);
    for (let v = 0, x = 0; v < this.children.length; v++) {
      let S = this.children[v],
        C = x + S.size;
      if (i > x && l < C)
        return S.setSelection(e - x - S.border, n - x - S.border, r, o);
      x = C;
    }
    let u = this.domFromPos(e, e ? -1 : 1),
      c = n == e ? u : this.domFromPos(n, n ? -1 : 1),
      f = r.root.getSelection(),
      p = r.domSelectionRange(),
      m = !1;
    if ((qn || jt) && e == n) {
      let { node: v, offset: x } = u;
      if (v.nodeType == 3) {
        if (
          ((m = !!(
            x &&
            v.nodeValue[x - 1] ==
              `
`
          )),
          m && x == v.nodeValue.length)
        )
          for (let S = v, C; S; S = S.parentNode) {
            if ((C = S.nextSibling)) {
              C.nodeName == "BR" &&
                (u = c = { node: C.parentNode, offset: kt(C) + 1 });
              break;
            }
            let E = S.pmViewDesc;
            if (E && E.node && E.node.isBlock) break;
          }
      } else {
        let S = v.childNodes[x - 1];
        m = S && (S.nodeName == "BR" || S.contentEditable == "false");
      }
    }
    if (
      qn &&
      p.focusNode &&
      p.focusNode != c.node &&
      p.focusNode.nodeType == 1
    ) {
      let v = p.focusNode.childNodes[p.focusOffset];
      v && v.contentEditable == "false" && (o = !0);
    }
    if (
      !(o || (m && jt)) &&
      Li(u.node, u.offset, p.anchorNode, p.anchorOffset) &&
      Li(c.node, c.offset, p.focusNode, p.focusOffset)
    )
      return;
    let y = !1;
    if ((f.extend || e == n) && !m) {
      f.collapse(u.node, u.offset);
      try {
        e != n && f.extend(c.node, c.offset), (y = !0);
      } catch {}
    }
    if (!y) {
      if (e > n) {
        let x = u;
        (u = c), (c = x);
      }
      let v = document.createRange();
      v.setEnd(c.node, c.offset),
        v.setStart(u.node, u.offset),
        f.removeAllRanges(),
        f.addRange(v);
    }
  }
  ignoreMutation(e) {
    return !this.contentDOM && e.type != "selection";
  }
  get contentLost() {
    return (
      this.contentDOM &&
      this.contentDOM != this.dom &&
      !this.dom.contains(this.contentDOM)
    );
  }
  markDirty(e, n) {
    for (let r = 0, o = 0; o < this.children.length; o++) {
      let i = this.children[o],
        l = r + i.size;
      if (r == l ? e <= l && n >= r : e < l && n > r) {
        let u = r + i.border,
          c = l - i.border;
        if (e >= u && n <= c) {
          (this.dirty = e == r || n == l ? ki : K1),
            e == u &&
            n == c &&
            (i.contentLost || i.dom.parentNode != this.contentDOM)
              ? (i.dirty = yr)
              : i.markDirty(e - u, n - u);
          return;
        } else
          i.dirty =
            i.dom == i.contentDOM &&
            i.dom.parentNode == this.contentDOM &&
            !i.children.length
              ? ki
              : yr;
      }
      r = l;
    }
    this.dirty = ki;
  }
  markParentsDirty() {
    let e = 1;
    for (let n = this.parent; n; n = n.parent, e++) {
      let r = e == 1 ? ki : K1;
      n.dirty < r && (n.dirty = r);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
  isText(e) {
    return !1;
  }
}
class jb extends _a {
  constructor(e, n, r, o) {
    let i,
      l = n.type.toDOM;
    if (
      (typeof l == "function" &&
        (l = l(r, () => {
          if (!i) return o;
          if (i.parent) return i.parent.posBeforeChild(i);
        })),
      !n.type.spec.raw)
    ) {
      if (l.nodeType != 1) {
        let u = document.createElement("span");
        u.appendChild(l), (l = u);
      }
      (l.contentEditable = "false"), l.classList.add("ProseMirror-widget");
    }
    super(e, [], l, null), (this.widget = n), (this.widget = n), (i = this);
  }
  matchesWidget(e) {
    return this.dirty == An && e.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(e) {
    let n = this.widget.spec.stopEvent;
    return n ? n(e) : !1;
  }
  ignoreMutation(e) {
    return e.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get side() {
    return this.widget.type.side;
  }
}
class HT extends _a {
  constructor(e, n, r, o) {
    super(e, [], n, null), (this.textDOM = r), (this.text = o);
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(e, n) {
    return e != this.textDOM
      ? this.posAtStart + (n ? this.size : 0)
      : this.posAtStart + n;
  }
  domFromPos(e) {
    return { node: this.textDOM, offset: e };
  }
  ignoreMutation(e) {
    return e.type === "characterData" && e.target.nodeValue == e.oldValue;
  }
}
class $i extends _a {
  constructor(e, n, r, o, i) {
    super(e, [], r, o), (this.mark = n), (this.spec = i);
  }
  static create(e, n, r, o) {
    let i = o.nodeViews[n.type.name],
      l = i && i(n, o, r);
    return (
      (!l || !l.dom) &&
        (l = Wi.renderSpec(document, n.type.spec.toDOM(n, r), null, n.attrs)),
      new $i(e, n, l.dom, l.contentDOM || l.dom, l)
    );
  }
  parseRule() {
    return this.dirty & yr || this.mark.type.spec.reparseInView
      ? null
      : {
          mark: this.mark.type.name,
          attrs: this.mark.attrs,
          contentElement: this.contentDOM,
        };
  }
  matchesMark(e) {
    return this.dirty != yr && this.mark.eq(e);
  }
  markDirty(e, n) {
    if ((super.markDirty(e, n), this.dirty != An)) {
      let r = this.parent;
      for (; !r.node; ) r = r.parent;
      r.dirty < this.dirty && (r.dirty = this.dirty), (this.dirty = An);
    }
  }
  slice(e, n, r) {
    let o = $i.create(this.parent, this.mark, !0, r),
      i = this.children,
      l = this.size;
    n < l && (i = mm(i, n, l, r)), e > 0 && (i = mm(i, 0, e, r));
    for (let u = 0; u < i.length; u++) i[u].parent = o;
    return (o.children = i), o;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation
      ? this.spec.ignoreMutation(e)
      : super.ignoreMutation(e);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
}
class zo extends _a {
  constructor(e, n, r, o, i, l, u, c, f) {
    super(e, [], i, l),
      (this.node = n),
      (this.outerDeco = r),
      (this.innerDeco = o),
      (this.nodeDOM = u);
  }
  static create(e, n, r, o, i, l) {
    let u = i.nodeViews[n.type.name],
      c,
      f =
        u &&
        u(
          n,
          i,
          () => {
            if (!c) return l;
            if (c.parent) return c.parent.posBeforeChild(c);
          },
          r,
          o
        ),
      p = f && f.dom,
      m = f && f.contentDOM;
    if (n.isText) {
      if (!p) p = document.createTextNode(n.text);
      else if (p.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else
      p ||
        ({ dom: p, contentDOM: m } = Wi.renderSpec(
          document,
          n.type.spec.toDOM(n),
          null,
          n.attrs
        ));
    !m &&
      !n.isText &&
      p.nodeName != "BR" &&
      (p.hasAttribute("contenteditable") || (p.contentEditable = "false"),
      n.type.spec.draggable && (p.draggable = !0));
    let y = p;
    return (
      (p = Wb(p, r, n)),
      f
        ? (c = new VT(e, n, r, o, p, m || null, y, f, i, l + 1))
        : n.isText
        ? new Vd(e, n, r, o, p, y, i)
        : new zo(e, n, r, o, p, m || null, y, i, l + 1)
    );
  }
  parseRule() {
    if (this.node.type.spec.reparseInView) return null;
    let e = { node: this.node.type.name, attrs: this.node.attrs };
    if (
      (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"),
      !this.contentDOM)
    )
      e.getContent = () => this.node.content;
    else if (!this.contentLost) e.contentElement = this.contentDOM;
    else {
      for (let n = this.children.length - 1; n >= 0; n--) {
        let r = this.children[n];
        if (this.dom.contains(r.dom.parentNode)) {
          e.contentElement = r.dom.parentNode;
          break;
        }
      }
      e.contentElement || (e.getContent = () => J.empty);
    }
    return e;
  }
  matchesNode(e, n, r) {
    return (
      this.dirty == An &&
      e.eq(this.node) &&
      Vc(n, this.outerDeco) &&
      r.eq(this.innerDeco)
    );
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  updateChildren(e, n) {
    let r = this.node.inlineContent,
      o = n,
      i = e.composing ? this.localCompositionInfo(e, n) : null,
      l = i && i.pos > -1 ? i : null,
      u = i && i.pos < 0,
      c = new UT(this, l && l.node, e);
    GT(
      this.node,
      this.innerDeco,
      (f, p, m) => {
        f.spec.marks
          ? c.syncToMarks(f.spec.marks, r, e)
          : f.type.side >= 0 &&
            !m &&
            c.syncToMarks(
              p == this.node.childCount ? He.none : this.node.child(p).marks,
              r,
              e
            ),
          c.placeWidget(f, e, o);
      },
      (f, p, m, y) => {
        c.syncToMarks(f.marks, r, e);
        let v;
        c.findNodeMatch(f, p, m, y) ||
          (u &&
            e.state.selection.from > o &&
            e.state.selection.to < o + f.nodeSize &&
            (v = c.findIndexWithChild(i.node)) > -1 &&
            c.updateNodeAt(f, p, m, v, e)) ||
          c.updateNextNode(f, p, m, e, y, o) ||
          c.addNode(f, p, m, e, o),
          (o += f.nodeSize);
      }
    ),
      c.syncToMarks([], r, e),
      this.node.isTextblock && c.addTextblockHacks(),
      c.destroyRest(),
      (c.changed || this.dirty == ki) &&
        (l && this.protectLocalComposition(e, l),
        Hb(this.contentDOM, this.children, e),
        Us && JT(this.dom));
  }
  localCompositionInfo(e, n) {
    let { from: r, to: o } = e.state.selection;
    if (
      !(e.state.selection instanceof Te) ||
      r < n ||
      o > n + this.node.content.size
    )
      return null;
    let i = e.input.compositionNode;
    if (!i || !this.dom.contains(i.parentNode)) return null;
    if (this.node.inlineContent) {
      let l = i.nodeValue,
        u = QT(this.node.content, l, r - n, o - n);
      return u < 0 ? null : { node: i, pos: u, text: l };
    } else return { node: i, pos: -1, text: "" };
  }
  protectLocalComposition(e, { node: n, pos: r, text: o }) {
    if (this.getDesc(n)) return;
    let i = n;
    for (; i.parentNode != this.contentDOM; i = i.parentNode) {
      for (; i.previousSibling; ) i.parentNode.removeChild(i.previousSibling);
      for (; i.nextSibling; ) i.parentNode.removeChild(i.nextSibling);
      i.pmViewDesc && (i.pmViewDesc = void 0);
    }
    let l = new HT(this, i, n, o);
    e.input.compositionNodes.push(l),
      (this.children = mm(this.children, r, r + o.length, e, l));
  }
  update(e, n, r, o) {
    return this.dirty == yr || !e.sameMarkup(this.node)
      ? !1
      : (this.updateInner(e, n, r, o), !0);
  }
  updateInner(e, n, r, o) {
    this.updateOuterDeco(n),
      (this.node = e),
      (this.innerDeco = r),
      this.contentDOM && this.updateChildren(o, this.posAtStart),
      (this.dirty = An);
  }
  updateOuterDeco(e) {
    if (Vc(e, this.outerDeco)) return;
    let n = this.nodeDOM.nodeType != 1,
      r = this.dom;
    (this.dom = Vb(
      this.dom,
      this.nodeDOM,
      hm(this.outerDeco, this.node, n),
      hm(e, this.node, n)
    )),
      this.dom != r && ((r.pmViewDesc = void 0), (this.dom.pmViewDesc = this)),
      (this.outerDeco = e);
  }
  selectNode() {
    this.nodeDOM.nodeType == 1 &&
      this.nodeDOM.classList.add("ProseMirror-selectednode"),
      (this.contentDOM || !this.node.type.spec.draggable) &&
        (this.dom.draggable = !0);
  }
  deselectNode() {
    this.nodeDOM.nodeType == 1 &&
      (this.nodeDOM.classList.remove("ProseMirror-selectednode"),
      (this.contentDOM || !this.node.type.spec.draggable) &&
        this.dom.removeAttribute("draggable"));
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function q1(t, e, n, r, o) {
  Wb(r, e, t);
  let i = new zo(void 0, t, e, n, r, r, r, o, 0);
  return i.contentDOM && i.updateChildren(o, 0), i;
}
class Vd extends zo {
  constructor(e, n, r, o, i, l, u) {
    super(e, n, r, o, i, null, l, u, 0);
  }
  parseRule() {
    let e = this.nodeDOM.parentNode;
    for (; e && e != this.dom && !e.pmIsDeco; ) e = e.parentNode;
    return { skip: e || !0 };
  }
  update(e, n, r, o) {
    return this.dirty == yr ||
      (this.dirty != An && !this.inParent()) ||
      !e.sameMarkup(this.node)
      ? !1
      : (this.updateOuterDeco(n),
        (this.dirty != An || e.text != this.node.text) &&
          e.text != this.nodeDOM.nodeValue &&
          ((this.nodeDOM.nodeValue = e.text),
          o.trackWrites == this.nodeDOM && (o.trackWrites = null)),
        (this.node = e),
        (this.dirty = An),
        !0);
  }
  inParent() {
    let e = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode) if (n == e) return !0;
    return !1;
  }
  domFromPos(e) {
    return { node: this.nodeDOM, offset: e };
  }
  localPosFromDOM(e, n, r) {
    return e == this.nodeDOM
      ? this.posAtStart + Math.min(n, this.node.text.length)
      : super.localPosFromDOM(e, n, r);
  }
  ignoreMutation(e) {
    return e.type != "characterData" && e.type != "selection";
  }
  slice(e, n, r) {
    let o = this.node.cut(e, n),
      i = document.createTextNode(o.text);
    return new Vd(this.parent, o, this.outerDeco, this.innerDeco, i, i, r);
  }
  markDirty(e, n) {
    super.markDirty(e, n),
      this.dom != this.nodeDOM &&
        (e == 0 || n == this.nodeDOM.nodeValue.length) &&
        (this.dirty = yr);
  }
  get domAtom() {
    return !1;
  }
  isText(e) {
    return this.node.text == e;
  }
}
class Bb extends _a {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(e) {
    return this.dirty == An && this.dom.nodeName == e;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class VT extends zo {
  constructor(e, n, r, o, i, l, u, c, f, p) {
    super(e, n, r, o, i, l, u, f, p), (this.spec = c);
  }
  update(e, n, r, o) {
    if (this.dirty == yr) return !1;
    if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) {
      let i = this.spec.update(e, n, r);
      return i && this.updateInner(e, n, r, o), i;
    } else return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, n, r, o);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(e, n, r, o) {
    this.spec.setSelection
      ? this.spec.setSelection(e, n, r.root)
      : super.setSelection(e, n, r, o);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(e) {
    return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation
      ? this.spec.ignoreMutation(e)
      : super.ignoreMutation(e);
  }
}
function Hb(t, e, n) {
  let r = t.firstChild,
    o = !1;
  for (let i = 0; i < e.length; i++) {
    let l = e[i],
      u = l.dom;
    if (u.parentNode == t) {
      for (; u != r; ) (r = G1(r)), (o = !0);
      r = r.nextSibling;
    } else (o = !0), t.insertBefore(u, r);
    if (l instanceof $i) {
      let c = r ? r.previousSibling : t.lastChild;
      Hb(l.contentDOM, l.children, n), (r = c ? c.nextSibling : t.firstChild);
    }
  }
  for (; r; ) (r = G1(r)), (o = !0);
  o && n.trackWrites == t && (n.trackWrites = null);
}
const na = function (t) {
  t && (this.nodeName = t);
};
na.prototype = Object.create(null);
const Ei = [new na()];
function hm(t, e, n) {
  if (t.length == 0) return Ei;
  let r = n ? Ei[0] : new na(),
    o = [r];
  for (let i = 0; i < t.length; i++) {
    let l = t[i].type.attrs;
    if (l) {
      l.nodeName && o.push((r = new na(l.nodeName)));
      for (let u in l) {
        let c = l[u];
        c != null &&
          (n &&
            o.length == 1 &&
            o.push((r = new na(e.isInline ? "span" : "div"))),
          u == "class"
            ? (r.class = (r.class ? r.class + " " : "") + c)
            : u == "style"
            ? (r.style = (r.style ? r.style + ";" : "") + c)
            : u != "nodeName" && (r[u] = c));
      }
    }
  }
  return o;
}
function Vb(t, e, n, r) {
  if (n == Ei && r == Ei) return e;
  let o = e;
  for (let i = 0; i < r.length; i++) {
    let l = r[i],
      u = n[i];
    if (i) {
      let c;
      (u &&
        u.nodeName == l.nodeName &&
        o != t &&
        (c = o.parentNode) &&
        c.nodeName.toLowerCase() == l.nodeName) ||
        ((c = document.createElement(l.nodeName)),
        (c.pmIsDeco = !0),
        c.appendChild(o),
        (u = Ei[0])),
        (o = c);
    }
    WT(o, u || Ei[0], l);
  }
  return o;
}
function WT(t, e, n) {
  for (let r in e)
    r != "class" &&
      r != "style" &&
      r != "nodeName" &&
      !(r in n) &&
      t.removeAttribute(r);
  for (let r in n)
    r != "class" &&
      r != "style" &&
      r != "nodeName" &&
      n[r] != e[r] &&
      t.setAttribute(r, n[r]);
  if (e.class != n.class) {
    let r = e.class ? e.class.split(" ").filter(Boolean) : [],
      o = n.class ? n.class.split(" ").filter(Boolean) : [];
    for (let i = 0; i < r.length; i++)
      o.indexOf(r[i]) == -1 && t.classList.remove(r[i]);
    for (let i = 0; i < o.length; i++)
      r.indexOf(o[i]) == -1 && t.classList.add(o[i]);
    t.classList.length == 0 && t.removeAttribute("class");
  }
  if (e.style != n.style) {
    if (e.style) {
      let r =
          /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g,
        o;
      for (; (o = r.exec(e.style)); ) t.style.removeProperty(o[1]);
    }
    n.style && (t.style.cssText += n.style);
  }
}
function Wb(t, e, n) {
  return Vb(t, t, Ei, hm(e, n, t.nodeType != 1));
}
function Vc(t, e) {
  if (t.length != e.length) return !1;
  for (let n = 0; n < t.length; n++) if (!t[n].type.eq(e[n].type)) return !1;
  return !0;
}
function G1(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class UT {
  constructor(e, n, r) {
    (this.lock = n),
      (this.view = r),
      (this.index = 0),
      (this.stack = []),
      (this.changed = !1),
      (this.top = e),
      (this.preMatch = KT(e.node.content, e));
  }
  destroyBetween(e, n) {
    if (e != n) {
      for (let r = e; r < n; r++) this.top.children[r].destroy();
      this.top.children.splice(e, n - e), (this.changed = !0);
    }
  }
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  syncToMarks(e, n, r) {
    let o = 0,
      i = this.stack.length >> 1,
      l = Math.min(i, e.length);
    for (
      ;
      o < l &&
      (o == i - 1 ? this.top : this.stack[(o + 1) << 1]).matchesMark(e[o]) &&
      e[o].type.spec.spanning !== !1;

    )
      o++;
    for (; o < i; )
      this.destroyRest(),
        (this.top.dirty = An),
        (this.index = this.stack.pop()),
        (this.top = this.stack.pop()),
        i--;
    for (; i < e.length; ) {
      this.stack.push(this.top, this.index + 1);
      let u = -1;
      for (
        let c = this.index;
        c < Math.min(this.index + 3, this.top.children.length);
        c++
      ) {
        let f = this.top.children[c];
        if (f.matchesMark(e[i]) && !this.isLocked(f.dom)) {
          u = c;
          break;
        }
      }
      if (u > -1)
        u > this.index &&
          ((this.changed = !0), this.destroyBetween(this.index, u)),
          (this.top = this.top.children[this.index]);
      else {
        let c = $i.create(this.top, e[i], n, r);
        this.top.children.splice(this.index, 0, c),
          (this.top = c),
          (this.changed = !0);
      }
      (this.index = 0), i++;
    }
  }
  findNodeMatch(e, n, r, o) {
    let i = -1,
      l;
    if (
      o >= this.preMatch.index &&
      (l = this.preMatch.matches[o - this.preMatch.index]).parent == this.top &&
      l.matchesNode(e, n, r)
    )
      i = this.top.children.indexOf(l, this.index);
    else
      for (
        let u = this.index, c = Math.min(this.top.children.length, u + 5);
        u < c;
        u++
      ) {
        let f = this.top.children[u];
        if (f.matchesNode(e, n, r) && !this.preMatch.matched.has(f)) {
          i = u;
          break;
        }
      }
    return i < 0 ? !1 : (this.destroyBetween(this.index, i), this.index++, !0);
  }
  updateNodeAt(e, n, r, o, i) {
    let l = this.top.children[o];
    return (
      l.dirty == yr && l.dom == l.contentDOM && (l.dirty = ki),
      l.update(e, n, r, i)
        ? (this.destroyBetween(this.index, o), this.index++, !0)
        : !1
    );
  }
  findIndexWithChild(e) {
    for (;;) {
      let n = e.parentNode;
      if (!n) return -1;
      if (n == this.top.contentDOM) {
        let r = e.pmViewDesc;
        if (r) {
          for (let o = this.index; o < this.top.children.length; o++)
            if (this.top.children[o] == r) return o;
        }
        return -1;
      }
      e = n;
    }
  }
  updateNextNode(e, n, r, o, i, l) {
    for (let u = this.index; u < this.top.children.length; u++) {
      let c = this.top.children[u];
      if (c instanceof zo) {
        let f = this.preMatch.matched.get(c);
        if (f != null && f != i) return !1;
        let p = c.dom,
          m,
          y =
            this.isLocked(p) &&
            !(
              e.isText &&
              c.node &&
              c.node.isText &&
              c.nodeDOM.nodeValue == e.text &&
              c.dirty != yr &&
              Vc(n, c.outerDeco)
            );
        if (!y && c.update(e, n, r, o))
          return (
            this.destroyBetween(this.index, u),
            c.dom != p && (this.changed = !0),
            this.index++,
            !0
          );
        if (!y && (m = this.recreateWrapper(c, e, n, r, o, l)))
          return (
            this.destroyBetween(this.index, u),
            (this.top.children[this.index] = m),
            m.contentDOM &&
              ((m.dirty = ki), m.updateChildren(o, l + 1), (m.dirty = An)),
            (this.changed = !0),
            this.index++,
            !0
          );
        break;
      }
    }
    return !1;
  }
  recreateWrapper(e, n, r, o, i, l) {
    if (
      e.dirty ||
      n.isAtom ||
      !e.children.length ||
      !e.node.content.eq(n.content) ||
      !Vc(r, e.outerDeco) ||
      !o.eq(e.innerDeco)
    )
      return null;
    let u = zo.create(this.top, n, r, o, i, l);
    if (u.contentDOM) {
      (u.children = e.children), (e.children = []);
      for (let c of u.children) c.parent = u;
    }
    return e.destroy(), u;
  }
  addNode(e, n, r, o, i) {
    let l = zo.create(this.top, e, n, r, o, i);
    l.contentDOM && l.updateChildren(o, i + 1),
      this.top.children.splice(this.index++, 0, l),
      (this.changed = !0);
  }
  placeWidget(e, n, r) {
    let o =
      this.index < this.top.children.length
        ? this.top.children[this.index]
        : null;
    if (
      o &&
      o.matchesWidget(e) &&
      (e == o.widget || !o.widget.type.toDOM.parentNode)
    )
      this.index++;
    else {
      let i = new jb(this.top, e, n, r);
      this.top.children.splice(this.index++, 0, i), (this.changed = !0);
    }
  }
  addTextblockHacks() {
    let e = this.top.children[this.index - 1],
      n = this.top;
    for (; e instanceof $i; ) (n = e), (e = n.children[n.children.length - 1]);
    (!e ||
      !(e instanceof Vd) ||
      /\n$/.test(e.node.text) ||
      (this.view.requiresGeckoHackNode && /\s$/.test(e.node.text))) &&
      ((jt || It) &&
        e &&
        e.dom.contentEditable == "false" &&
        this.addHackNode("IMG", n),
      this.addHackNode("BR", this.top));
  }
  addHackNode(e, n) {
    if (
      n == this.top &&
      this.index < n.children.length &&
      n.children[this.index].matchesHack(e)
    )
      this.index++;
    else {
      let r = document.createElement(e);
      e == "IMG" && ((r.className = "ProseMirror-separator"), (r.alt = "")),
        e == "BR" && (r.className = "ProseMirror-trailingBreak");
      let o = new Bb(this.top, [], r, null);
      n != this.top
        ? n.children.push(o)
        : n.children.splice(this.index++, 0, o),
        (this.changed = !0);
    }
  }
  isLocked(e) {
    return (
      this.lock &&
      (e == this.lock || (e.nodeType == 1 && e.contains(this.lock.parentNode)))
    );
  }
}
function KT(t, e) {
  let n = e,
    r = n.children.length,
    o = t.childCount,
    i = new Map(),
    l = [];
  e: for (; o > 0; ) {
    let u;
    for (;;)
      if (r) {
        let f = n.children[r - 1];
        if (f instanceof $i) (n = f), (r = f.children.length);
        else {
          (u = f), r--;
          break;
        }
      } else {
        if (n == e) break e;
        (r = n.parent.children.indexOf(n)), (n = n.parent);
      }
    let c = u.node;
    if (c) {
      if (c != t.child(o - 1)) break;
      --o, i.set(u, o), l.push(u);
    }
  }
  return { index: o, matched: i, matches: l.reverse() };
}
function qT(t, e) {
  return t.type.side - e.type.side;
}
function GT(t, e, n, r) {
  let o = e.locals(t),
    i = 0;
  if (o.length == 0) {
    for (let f = 0; f < t.childCount; f++) {
      let p = t.child(f);
      r(p, o, e.forChild(i, p), f), (i += p.nodeSize);
    }
    return;
  }
  let l = 0,
    u = [],
    c = null;
  for (let f = 0; ; ) {
    let p, m;
    for (; l < o.length && o[l].to == i; ) {
      let C = o[l++];
      C.widget && (p ? (m || (m = [p])).push(C) : (p = C));
    }
    if (p)
      if (m) {
        m.sort(qT);
        for (let C = 0; C < m.length; C++) n(m[C], f, !!c);
      } else n(p, f, !!c);
    let y, v;
    if (c) (v = -1), (y = c), (c = null);
    else if (f < t.childCount) (v = f), (y = t.child(f++));
    else break;
    for (let C = 0; C < u.length; C++) u[C].to <= i && u.splice(C--, 1);
    for (; l < o.length && o[l].from <= i && o[l].to > i; ) u.push(o[l++]);
    let x = i + y.nodeSize;
    if (y.isText) {
      let C = x;
      l < o.length && o[l].from < C && (C = o[l].from);
      for (let E = 0; E < u.length; E++) u[E].to < C && (C = u[E].to);
      C < x && ((c = y.cut(C - i)), (y = y.cut(0, C - i)), (x = C), (v = -1));
    } else for (; l < o.length && o[l].to < x; ) l++;
    let S = y.isInline && !y.isLeaf ? u.filter((C) => !C.inline) : u.slice();
    r(y, S, e.forChild(i, y), v), (i = x);
  }
}
function JT(t) {
  if (t.nodeName == "UL" || t.nodeName == "OL") {
    let e = t.style.cssText;
    (t.style.cssText = e + "; list-style: square !important"),
      window.getComputedStyle(t).listStyle,
      (t.style.cssText = e);
  }
}
function QT(t, e, n, r) {
  for (let o = 0, i = 0; o < t.childCount && i <= r; ) {
    let l = t.child(o++),
      u = i;
    if (((i += l.nodeSize), !l.isText)) continue;
    let c = l.text;
    for (; o < t.childCount; ) {
      let f = t.child(o++);
      if (((i += f.nodeSize), !f.isText)) break;
      c += f.text;
    }
    if (i >= n) {
      if (i >= r && c.slice(r - e.length - u, r - u) == e) return r - e.length;
      let f = u < r ? c.lastIndexOf(e, r - u - 1) : -1;
      if (f >= 0 && f + e.length + u >= n) return u + f;
      if (
        n == r &&
        c.length >= r + e.length - u &&
        c.slice(r - u, r - u + e.length) == e
      )
        return r;
    }
  }
  return -1;
}
function mm(t, e, n, r, o) {
  let i = [];
  for (let l = 0, u = 0; l < t.length; l++) {
    let c = t[l],
      f = u,
      p = (u += c.size);
    f >= n || p <= e
      ? i.push(c)
      : (f < e && i.push(c.slice(0, e - f, r)),
        o && (i.push(o), (o = void 0)),
        p > n && i.push(c.slice(n - f, c.size, r)));
  }
  return i;
}
function lg(t, e = null) {
  let n = t.domSelectionRange(),
    r = t.state.doc;
  if (!n.focusNode) return null;
  let o = t.docView.nearestDesc(n.focusNode),
    i = o && o.size == 0,
    l = t.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
  if (l < 0) return null;
  let u = r.resolve(l),
    c,
    f;
  if (Hd(n)) {
    for (c = l; o && !o.node; ) o = o.parent;
    let m = o.node;
    if (
      o &&
      m.isAtom &&
      ke.isSelectable(m) &&
      o.parent &&
      !(m.isInline && ST(n.focusNode, n.focusOffset, o.dom))
    ) {
      let y = o.posBefore;
      f = new ke(l == y ? u : r.resolve(y));
    }
  } else {
    if (
      n instanceof t.dom.ownerDocument.defaultView.Selection &&
      n.rangeCount > 1
    ) {
      let m = l,
        y = l;
      for (let v = 0; v < n.rangeCount; v++) {
        let x = n.getRangeAt(v);
        (m = Math.min(
          m,
          t.docView.posFromDOM(x.startContainer, x.startOffset, 1)
        )),
          (y = Math.max(
            y,
            t.docView.posFromDOM(x.endContainer, x.endOffset, -1)
          ));
      }
      if (m < 0) return null;
      ([c, l] = y == t.state.selection.anchor ? [y, m] : [m, y]),
        (u = r.resolve(l));
    } else c = t.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
    if (c < 0) return null;
  }
  let p = r.resolve(c);
  if (!f) {
    let m = e == "pointer" || (t.state.selection.head < u.pos && !i) ? 1 : -1;
    f = ag(t, p, u, m);
  }
  return f;
}
function Ub(t) {
  return t.editable
    ? t.hasFocus()
    : qb(t) && document.activeElement && document.activeElement.contains(t.dom);
}
function Ur(t, e = !1) {
  let n = t.state.selection;
  if ((Kb(t, n), !!Ub(t))) {
    if (!e && t.input.mouseDown && t.input.mouseDown.allowDefault && It) {
      let r = t.domSelectionRange(),
        o = t.domObserver.currentSelection;
      if (
        r.anchorNode &&
        o.anchorNode &&
        Li(r.anchorNode, r.anchorOffset, o.anchorNode, o.anchorOffset)
      ) {
        (t.input.mouseDown.delayedSelectionSync = !0),
          t.domObserver.setCurSelection();
        return;
      }
    }
    if ((t.domObserver.disconnectSelection(), t.cursorWrapper)) XT(t);
    else {
      let { anchor: r, head: o } = n,
        i,
        l;
      J1 &&
        !(n instanceof Te) &&
        (n.$from.parent.inlineContent || (i = Q1(t, n.from)),
        !n.empty && !n.$from.parent.inlineContent && (l = Q1(t, n.to))),
        t.docView.setSelection(r, o, t, e),
        J1 && (i && Y1(i), l && Y1(l)),
        n.visible
          ? t.dom.classList.remove("ProseMirror-hideselection")
          : (t.dom.classList.add("ProseMirror-hideselection"),
            "onselectionchange" in document && YT(t));
    }
    t.domObserver.setCurSelection(), t.domObserver.connectSelection();
  }
}
const J1 = jt || (It && Db < 63);
function Q1(t, e) {
  let { node: n, offset: r } = t.docView.domFromPos(e, 0),
    o = r < n.childNodes.length ? n.childNodes[r] : null,
    i = r ? n.childNodes[r - 1] : null;
  if (jt && o && o.contentEditable == "false") return gh(o);
  if (
    (!o || o.contentEditable == "false") &&
    (!i || i.contentEditable == "false")
  ) {
    if (o) return gh(o);
    if (i) return gh(i);
  }
}
function gh(t) {
  return (
    (t.contentEditable = "true"),
    jt && t.draggable && ((t.draggable = !1), (t.wasDraggable = !0)),
    t
  );
}
function Y1(t) {
  (t.contentEditable = "false"),
    t.wasDraggable && ((t.draggable = !0), (t.wasDraggable = null));
}
function YT(t) {
  let e = t.dom.ownerDocument;
  e.removeEventListener("selectionchange", t.input.hideSelectionGuard);
  let n = t.domSelectionRange(),
    r = n.anchorNode,
    o = n.anchorOffset;
  e.addEventListener(
    "selectionchange",
    (t.input.hideSelectionGuard = () => {
      (n.anchorNode != r || n.anchorOffset != o) &&
        (e.removeEventListener("selectionchange", t.input.hideSelectionGuard),
        setTimeout(() => {
          (!Ub(t) || t.state.selection.visible) &&
            t.dom.classList.remove("ProseMirror-hideselection");
        }, 20));
    })
  );
}
function XT(t) {
  let e = t.domSelection(),
    n = document.createRange();
  if (!e) return;
  let r = t.cursorWrapper.dom,
    o = r.nodeName == "IMG";
  o ? n.setStart(r.parentNode, kt(r) + 1) : n.setStart(r, 0),
    n.collapse(!0),
    e.removeAllRanges(),
    e.addRange(n),
    !o &&
      !t.state.selection.visible &&
      tn &&
      Fo <= 11 &&
      ((r.disabled = !0), (r.disabled = !1));
}
function Kb(t, e) {
  if (e instanceof ke) {
    let n = t.docView.descAt(e.from);
    n != t.lastSelectedViewDesc &&
      (X1(t), n && n.selectNode(), (t.lastSelectedViewDesc = n));
  } else X1(t);
}
function X1(t) {
  t.lastSelectedViewDesc &&
    (t.lastSelectedViewDesc.parent && t.lastSelectedViewDesc.deselectNode(),
    (t.lastSelectedViewDesc = void 0));
}
function ag(t, e, n, r) {
  return (
    t.someProp("createSelectionBetween", (o) => o(t, e, n)) ||
    Te.between(e, n, r)
  );
}
function Z1(t) {
  return t.editable && !t.hasFocus() ? !1 : qb(t);
}
function qb(t) {
  let e = t.domSelectionRange();
  if (!e.anchorNode) return !1;
  try {
    return (
      t.dom.contains(
        e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode
      ) &&
      (t.editable ||
        t.dom.contains(
          e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode
        ))
    );
  } catch {
    return !1;
  }
}
function ZT(t) {
  let e = t.docView.domFromPos(t.state.selection.anchor, 0),
    n = t.domSelectionRange();
  return Li(e.node, e.offset, n.anchorNode, n.anchorOffset);
}
function gm(t, e) {
  let { $anchor: n, $head: r } = t.selection,
    o = e > 0 ? n.max(r) : n.min(r),
    i = o.parent.inlineContent
      ? o.depth
        ? t.doc.resolve(e > 0 ? o.after() : o.before())
        : null
      : o;
  return i && Ae.findFrom(i, e);
}
function Eo(t, e) {
  return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()), !0;
}
function ew(t, e, n) {
  let r = t.state.selection;
  if (r instanceof Te)
    if (n.indexOf("s") > -1) {
      let { $head: o } = r,
        i = o.textOffset ? null : e < 0 ? o.nodeBefore : o.nodeAfter;
      if (!i || i.isText || !i.isLeaf) return !1;
      let l = t.state.doc.resolve(o.pos + i.nodeSize * (e < 0 ? -1 : 1));
      return Eo(t, new Te(r.$anchor, l));
    } else if (r.empty) {
      if (t.endOfTextblock(e > 0 ? "forward" : "backward")) {
        let o = gm(t.state, e);
        return o && o instanceof ke ? Eo(t, o) : !1;
      } else if (!(Mn && n.indexOf("m") > -1)) {
        let o = r.$head,
          i = o.textOffset ? null : e < 0 ? o.nodeBefore : o.nodeAfter,
          l;
        if (!i || i.isText) return !1;
        let u = e < 0 ? o.pos - i.nodeSize : o.pos;
        return i.isAtom || ((l = t.docView.descAt(u)) && !l.contentDOM)
          ? ke.isSelectable(i)
            ? Eo(t, new ke(e < 0 ? t.state.doc.resolve(o.pos - i.nodeSize) : o))
            : $a
            ? Eo(t, new Te(t.state.doc.resolve(e < 0 ? u : u + i.nodeSize)))
            : !1
          : !1;
      }
    } else return !1;
  else {
    if (r instanceof ke && r.node.isInline)
      return Eo(t, new Te(e > 0 ? r.$to : r.$from));
    {
      let o = gm(t.state, e);
      return o ? Eo(t, o) : !1;
    }
  }
}
function Wc(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function ra(t, e) {
  let n = t.pmViewDesc;
  return n && n.size == 0 && (e < 0 || t.nextSibling || t.nodeName != "BR");
}
function bs(t, e) {
  return e < 0 ? eN(t) : tN(t);
}
function eN(t) {
  let e = t.domSelectionRange(),
    n = e.focusNode,
    r = e.focusOffset;
  if (!n) return;
  let o,
    i,
    l = !1;
  for (
    qn && n.nodeType == 1 && r < Wc(n) && ra(n.childNodes[r], -1) && (l = !0);
    ;

  )
    if (r > 0) {
      if (n.nodeType != 1) break;
      {
        let u = n.childNodes[r - 1];
        if (ra(u, -1)) (o = n), (i = --r);
        else if (u.nodeType == 3) (n = u), (r = n.nodeValue.length);
        else break;
      }
    } else {
      if (Gb(n)) break;
      {
        let u = n.previousSibling;
        for (; u && ra(u, -1); )
          (o = n.parentNode), (i = kt(u)), (u = u.previousSibling);
        if (u) (n = u), (r = Wc(n));
        else {
          if (((n = n.parentNode), n == t.dom)) break;
          r = 0;
        }
      }
    }
  l ? ym(t, n, r) : o && ym(t, o, i);
}
function tN(t) {
  let e = t.domSelectionRange(),
    n = e.focusNode,
    r = e.focusOffset;
  if (!n) return;
  let o = Wc(n),
    i,
    l;
  for (;;)
    if (r < o) {
      if (n.nodeType != 1) break;
      let u = n.childNodes[r];
      if (ra(u, 1)) (i = n), (l = ++r);
      else break;
    } else {
      if (Gb(n)) break;
      {
        let u = n.nextSibling;
        for (; u && ra(u, 1); )
          (i = u.parentNode), (l = kt(u) + 1), (u = u.nextSibling);
        if (u) (n = u), (r = 0), (o = Wc(n));
        else {
          if (((n = n.parentNode), n == t.dom)) break;
          r = o = 0;
        }
      }
    }
  i && ym(t, i, l);
}
function Gb(t) {
  let e = t.pmViewDesc;
  return e && e.node && e.node.isBlock;
}
function nN(t, e) {
  for (; t && e == t.childNodes.length && !La(t); )
    (e = kt(t) + 1), (t = t.parentNode);
  for (; t && e < t.childNodes.length; ) {
    let n = t.childNodes[e];
    if (n.nodeType == 3) return n;
    if (n.nodeType == 1 && n.contentEditable == "false") break;
    (t = n), (e = 0);
  }
}
function rN(t, e) {
  for (; t && !e && !La(t); ) (e = kt(t)), (t = t.parentNode);
  for (; t && e; ) {
    let n = t.childNodes[e - 1];
    if (n.nodeType == 3) return n;
    if (n.nodeType == 1 && n.contentEditable == "false") break;
    (t = n), (e = t.childNodes.length);
  }
}
function ym(t, e, n) {
  if (e.nodeType != 3) {
    let i, l;
    (l = nN(e, n))
      ? ((e = l), (n = 0))
      : (i = rN(e, n)) && ((e = i), (n = i.nodeValue.length));
  }
  let r = t.domSelection();
  if (!r) return;
  if (Hd(r)) {
    let i = document.createRange();
    i.setEnd(e, n), i.setStart(e, n), r.removeAllRanges(), r.addRange(i);
  } else r.extend && r.extend(e, n);
  t.domObserver.setCurSelection();
  let { state: o } = t;
  setTimeout(() => {
    t.state == o && Ur(t);
  }, 50);
}
function tw(t, e) {
  let n = t.state.doc.resolve(e);
  if (!(It || ET) && n.parent.inlineContent) {
    let o = t.coordsAtPos(e);
    if (e > n.start()) {
      let i = t.coordsAtPos(e - 1),
        l = (i.top + i.bottom) / 2;
      if (l > o.top && l < o.bottom && Math.abs(i.left - o.left) > 1)
        return i.left < o.left ? "ltr" : "rtl";
    }
    if (e < n.end()) {
      let i = t.coordsAtPos(e + 1),
        l = (i.top + i.bottom) / 2;
      if (l > o.top && l < o.bottom && Math.abs(i.left - o.left) > 1)
        return i.left > o.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(t.dom).direction == "rtl" ? "rtl" : "ltr";
}
function nw(t, e, n) {
  let r = t.state.selection;
  if (
    (r instanceof Te && !r.empty) ||
    n.indexOf("s") > -1 ||
    (Mn && n.indexOf("m") > -1)
  )
    return !1;
  let { $from: o, $to: i } = r;
  if (!o.parent.inlineContent || t.endOfTextblock(e < 0 ? "up" : "down")) {
    let l = gm(t.state, e);
    if (l && l instanceof ke) return Eo(t, l);
  }
  if (!o.parent.inlineContent) {
    let l = e < 0 ? o : i,
      u = r instanceof Nn ? Ae.near(l, e) : Ae.findFrom(l, e);
    return u ? Eo(t, u) : !1;
  }
  return !1;
}
function rw(t, e) {
  if (!(t.state.selection instanceof Te)) return !0;
  let { $head: n, $anchor: r, empty: o } = t.state.selection;
  if (!n.sameParent(r)) return !0;
  if (!o) return !1;
  if (t.endOfTextblock(e > 0 ? "forward" : "backward")) return !0;
  let i = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter);
  if (i && !i.isText) {
    let l = t.state.tr;
    return (
      e < 0
        ? l.delete(n.pos - i.nodeSize, n.pos)
        : l.delete(n.pos, n.pos + i.nodeSize),
      t.dispatch(l),
      !0
    );
  }
  return !1;
}
function ow(t, e, n) {
  t.domObserver.stop(), (e.contentEditable = n), t.domObserver.start();
}
function oN(t) {
  if (!jt || t.state.selection.$head.parentOffset > 0) return !1;
  let { focusNode: e, focusOffset: n } = t.domSelectionRange();
  if (
    e &&
    e.nodeType == 1 &&
    n == 0 &&
    e.firstChild &&
    e.firstChild.contentEditable == "false"
  ) {
    let r = e.firstChild;
    ow(t, r, "true"), setTimeout(() => ow(t, r, "false"), 20);
  }
  return !1;
}
function iN(t) {
  let e = "";
  return (
    t.ctrlKey && (e += "c"),
    t.metaKey && (e += "m"),
    t.altKey && (e += "a"),
    t.shiftKey && (e += "s"),
    e
  );
}
function sN(t, e) {
  let n = e.keyCode,
    r = iN(e);
  if (n == 8 || (Mn && n == 72 && r == "c")) return rw(t, -1) || bs(t, -1);
  if ((n == 46 && !e.shiftKey) || (Mn && n == 68 && r == "c"))
    return rw(t, 1) || bs(t, 1);
  if (n == 13 || n == 27) return !0;
  if (n == 37 || (Mn && n == 66 && r == "c")) {
    let o = n == 37 ? (tw(t, t.state.selection.from) == "ltr" ? -1 : 1) : -1;
    return ew(t, o, r) || bs(t, o);
  } else if (n == 39 || (Mn && n == 70 && r == "c")) {
    let o = n == 39 ? (tw(t, t.state.selection.from) == "ltr" ? 1 : -1) : 1;
    return ew(t, o, r) || bs(t, o);
  } else {
    if (n == 38 || (Mn && n == 80 && r == "c"))
      return nw(t, -1, r) || bs(t, -1);
    if (n == 40 || (Mn && n == 78 && r == "c"))
      return oN(t) || nw(t, 1, r) || bs(t, 1);
    if (r == (Mn ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90))
      return !0;
  }
  return !1;
}
function ug(t, e) {
  t.someProp("transformCopied", (v) => {
    e = v(e, t);
  });
  let n = [],
    { content: r, openStart: o, openEnd: i } = e;
  for (
    ;
    o > 1 && i > 1 && r.childCount == 1 && r.firstChild.childCount == 1;

  ) {
    o--, i--;
    let v = r.firstChild;
    n.push(v.type.name, v.attrs != v.type.defaultAttrs ? v.attrs : null),
      (r = v.content);
  }
  let l = t.someProp("clipboardSerializer") || Wi.fromSchema(t.state.schema),
    u = eS(),
    c = u.createElement("div");
  c.appendChild(l.serializeFragment(r, { document: u }));
  let f = c.firstChild,
    p,
    m = 0;
  for (; f && f.nodeType == 1 && (p = Zb[f.nodeName.toLowerCase()]); ) {
    for (let v = p.length - 1; v >= 0; v--) {
      let x = u.createElement(p[v]);
      for (; c.firstChild; ) x.appendChild(c.firstChild);
      c.appendChild(x), m++;
    }
    f = c.firstChild;
  }
  f &&
    f.nodeType == 1 &&
    f.setAttribute(
      "data-pm-slice",
      `${o} ${i}${m ? ` -${m}` : ""} ${JSON.stringify(n)}`
    );
  let y =
    t.someProp("clipboardTextSerializer", (v) => v(e, t)) ||
    e.content.textBetween(
      0,
      e.content.size,
      `

`
    );
  return { dom: c, text: y, slice: e };
}
function Jb(t, e, n, r, o) {
  let i = o.parent.type.spec.code,
    l,
    u;
  if (!n && !e) return null;
  let c = e && (r || i || !n);
  if (c) {
    if (
      (t.someProp("transformPastedText", (y) => {
        e = y(e, i || r, t);
      }),
      i)
    )
      return e
        ? new ae(
            J.from(
              t.state.schema.text(
                e.replace(
                  /\r\n?/g,
                  `
`
                )
              )
            ),
            0,
            0
          )
        : ae.empty;
    let m = t.someProp("clipboardTextParser", (y) => y(e, o, r, t));
    if (m) u = m;
    else {
      let y = o.marks(),
        { schema: v } = t.state,
        x = Wi.fromSchema(v);
      (l = document.createElement("div")),
        e.split(/(?:\r\n?|\n)+/).forEach((S) => {
          let C = l.appendChild(document.createElement("p"));
          S && C.appendChild(x.serializeNode(v.text(S, y)));
        });
    }
  } else
    t.someProp("transformPastedHTML", (m) => {
      n = m(n, t);
    }),
      (l = cN(n)),
      $a && dN(l);
  let f = l && l.querySelector("[data-pm-slice]"),
    p =
      f &&
      /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(
        f.getAttribute("data-pm-slice") || ""
      );
  if (p && p[3])
    for (let m = +p[3]; m > 0; m--) {
      let y = l.firstChild;
      for (; y && y.nodeType != 1; ) y = y.nextSibling;
      if (!y) break;
      l = y;
    }
  if (
    (u ||
      (u = (
        t.someProp("clipboardParser") ||
        t.someProp("domParser") ||
        _o.fromSchema(t.state.schema)
      ).parseSlice(l, {
        preserveWhitespace: !!(c || p),
        context: o,
        ruleFromNode(y) {
          return y.nodeName == "BR" &&
            !y.nextSibling &&
            y.parentNode &&
            !lN.test(y.parentNode.nodeName)
            ? { ignore: !0 }
            : null;
        },
      })),
    p)
  )
    u = fN(iw(u, +p[1], +p[2]), p[4]);
  else if (((u = ae.maxOpen(aN(u.content, o), !0)), u.openStart || u.openEnd)) {
    let m = 0,
      y = 0;
    for (
      let v = u.content.firstChild;
      m < u.openStart && !v.type.spec.isolating;
      m++, v = v.firstChild
    );
    for (
      let v = u.content.lastChild;
      y < u.openEnd && !v.type.spec.isolating;
      y++, v = v.lastChild
    );
    u = iw(u, m, y);
  }
  return (
    t.someProp("transformPasted", (m) => {
      u = m(u, t);
    }),
    u
  );
}
const lN =
  /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function aN(t, e) {
  if (t.childCount < 2) return t;
  for (let n = e.depth; n >= 0; n--) {
    let o = e.node(n).contentMatchAt(e.index(n)),
      i,
      l = [];
    if (
      (t.forEach((u) => {
        if (!l) return;
        let c = o.findWrapping(u.type),
          f;
        if (!c) return (l = null);
        if ((f = l.length && i.length && Yb(c, i, u, l[l.length - 1], 0)))
          l[l.length - 1] = f;
        else {
          l.length && (l[l.length - 1] = Xb(l[l.length - 1], i.length));
          let p = Qb(u, c);
          l.push(p), (o = o.matchType(p.type)), (i = c);
        }
      }),
      l)
    )
      return J.from(l);
  }
  return t;
}
function Qb(t, e, n = 0) {
  for (let r = e.length - 1; r >= n; r--) t = e[r].create(null, J.from(t));
  return t;
}
function Yb(t, e, n, r, o) {
  if (o < t.length && o < e.length && t[o] == e[o]) {
    let i = Yb(t, e, n, r.lastChild, o + 1);
    if (i) return r.copy(r.content.replaceChild(r.childCount - 1, i));
    if (
      r
        .contentMatchAt(r.childCount)
        .matchType(o == t.length - 1 ? n.type : t[o + 1])
    )
      return r.copy(r.content.append(J.from(Qb(n, t, o + 1))));
  }
}
function Xb(t, e) {
  if (e == 0) return t;
  let n = t.content.replaceChild(t.childCount - 1, Xb(t.lastChild, e - 1)),
    r = t.contentMatchAt(t.childCount).fillBefore(J.empty, !0);
  return t.copy(n.append(r));
}
function vm(t, e, n, r, o, i) {
  let l = e < 0 ? t.firstChild : t.lastChild,
    u = l.content;
  return (
    t.childCount > 1 && (i = 0),
    o < r - 1 && (u = vm(u, e, n, r, o + 1, i)),
    o >= n &&
      (u =
        e < 0
          ? l
              .contentMatchAt(0)
              .fillBefore(u, i <= o)
              .append(u)
          : u.append(l.contentMatchAt(l.childCount).fillBefore(J.empty, !0))),
    t.replaceChild(e < 0 ? 0 : t.childCount - 1, l.copy(u))
  );
}
function iw(t, e, n) {
  return (
    e < t.openStart &&
      (t = new ae(
        vm(t.content, -1, e, t.openStart, 0, t.openEnd),
        e,
        t.openEnd
      )),
    n < t.openEnd &&
      (t = new ae(vm(t.content, 1, n, t.openEnd, 0, 0), t.openStart, n)),
    t
  );
}
const Zb = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"],
};
let sw = null;
function eS() {
  return sw || (sw = document.implementation.createHTMLDocument("title"));
}
let yh = null;
function uN(t) {
  let e = window.trustedTypes;
  return e
    ? (yh ||
        (yh = e.createPolicy("ProseMirrorClipboard", { createHTML: (n) => n })),
      yh.createHTML(t))
    : t;
}
function cN(t) {
  let e = /^(\s*<meta [^>]*>)*/.exec(t);
  e && (t = t.slice(e[0].length));
  let n = eS().createElement("div"),
    r = /<([a-z][^>\s]+)/i.exec(t),
    o;
  if (
    ((o = r && Zb[r[1].toLowerCase()]) &&
      (t =
        o.map((i) => "<" + i + ">").join("") +
        t +
        o
          .map((i) => "</" + i + ">")
          .reverse()
          .join("")),
    (n.innerHTML = uN(t)),
    o)
  )
    for (let i = 0; i < o.length; i++) n = n.querySelector(o[i]) || n;
  return n;
}
function dN(t) {
  let e = t.querySelectorAll(
    It ? "span:not([class]):not([style])" : "span.Apple-converted-space"
  );
  for (let n = 0; n < e.length; n++) {
    let r = e[n];
    r.childNodes.length == 1 &&
      r.textContent == "" &&
      r.parentNode &&
      r.parentNode.replaceChild(t.ownerDocument.createTextNode(" "), r);
  }
}
function fN(t, e) {
  if (!t.size) return t;
  let n = t.content.firstChild.type.schema,
    r;
  try {
    r = JSON.parse(e);
  } catch {
    return t;
  }
  let { content: o, openStart: i, openEnd: l } = t;
  for (let u = r.length - 2; u >= 0; u -= 2) {
    let c = n.nodes[r[u]];
    if (!c || c.hasRequiredAttrs()) break;
    (o = J.from(c.create(r[u + 1], o))), i++, l++;
  }
  return new ae(o, i, l);
}
const Bt = {},
  Ht = {},
  pN = { touchstart: !0, touchmove: !0 };
class hN {
  constructor() {
    (this.shiftKey = !1),
      (this.mouseDown = null),
      (this.lastKeyCode = null),
      (this.lastKeyCodeTime = 0),
      (this.lastClick = { time: 0, x: 0, y: 0, type: "" }),
      (this.lastSelectionOrigin = null),
      (this.lastSelectionTime = 0),
      (this.lastIOSEnter = 0),
      (this.lastIOSEnterFallbackTimeout = -1),
      (this.lastFocus = 0),
      (this.lastTouch = 0),
      (this.lastChromeDelete = 0),
      (this.composing = !1),
      (this.compositionNode = null),
      (this.composingTimeout = -1),
      (this.compositionNodes = []),
      (this.compositionEndedAt = -2e8),
      (this.compositionID = 1),
      (this.compositionPendingChanges = 0),
      (this.domChangeCount = 0),
      (this.eventHandlers = Object.create(null)),
      (this.hideSelectionGuard = null);
  }
}
function mN(t) {
  for (let e in Bt) {
    let n = Bt[e];
    t.dom.addEventListener(
      e,
      (t.input.eventHandlers[e] = (r) => {
        yN(t, r) && !cg(t, r) && (t.editable || !(r.type in Ht)) && n(t, r);
      }),
      pN[e] ? { passive: !0 } : void 0
    );
  }
  jt && t.dom.addEventListener("input", () => null), wm(t);
}
function Io(t, e) {
  (t.input.lastSelectionOrigin = e), (t.input.lastSelectionTime = Date.now());
}
function gN(t) {
  t.domObserver.stop();
  for (let e in t.input.eventHandlers)
    t.dom.removeEventListener(e, t.input.eventHandlers[e]);
  clearTimeout(t.input.composingTimeout),
    clearTimeout(t.input.lastIOSEnterFallbackTimeout);
}
function wm(t) {
  t.someProp("handleDOMEvents", (e) => {
    for (let n in e)
      t.input.eventHandlers[n] ||
        t.dom.addEventListener(n, (t.input.eventHandlers[n] = (r) => cg(t, r)));
  });
}
function cg(t, e) {
  return t.someProp("handleDOMEvents", (n) => {
    let r = n[e.type];
    return r ? r(t, e) || e.defaultPrevented : !1;
  });
}
function yN(t, e) {
  if (!e.bubbles) return !0;
  if (e.defaultPrevented) return !1;
  for (let n = e.target; n != t.dom; n = n.parentNode)
    if (!n || n.nodeType == 11 || (n.pmViewDesc && n.pmViewDesc.stopEvent(e)))
      return !1;
  return !0;
}
function vN(t, e) {
  !cg(t, e) &&
    Bt[e.type] &&
    (t.editable || !(e.type in Ht)) &&
    Bt[e.type](t, e);
}
Ht.keydown = (t, e) => {
  let n = e;
  if (
    ((t.input.shiftKey = n.keyCode == 16 || n.shiftKey),
    !nS(t, n) &&
      ((t.input.lastKeyCode = n.keyCode),
      (t.input.lastKeyCodeTime = Date.now()),
      !(Vr && It && n.keyCode == 13)))
  )
    if (
      (n.keyCode != 229 && t.domObserver.forceFlush(),
      Us && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey)
    ) {
      let r = Date.now();
      (t.input.lastIOSEnter = r),
        (t.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
          t.input.lastIOSEnter == r &&
            (t.someProp("handleKeyDown", (o) => o(t, bi(13, "Enter"))),
            (t.input.lastIOSEnter = 0));
        }, 200));
    } else
      t.someProp("handleKeyDown", (r) => r(t, n)) || sN(t, n)
        ? n.preventDefault()
        : Io(t, "key");
};
Ht.keyup = (t, e) => {
  e.keyCode == 16 && (t.input.shiftKey = !1);
};
Ht.keypress = (t, e) => {
  let n = e;
  if (nS(t, n) || !n.charCode || (n.ctrlKey && !n.altKey) || (Mn && n.metaKey))
    return;
  if (t.someProp("handleKeyPress", (o) => o(t, n))) {
    n.preventDefault();
    return;
  }
  let r = t.state.selection;
  if (!(r instanceof Te) || !r.$from.sameParent(r.$to)) {
    let o = String.fromCharCode(n.charCode);
    !/[\r\n]/.test(o) &&
      !t.someProp("handleTextInput", (i) => i(t, r.$from.pos, r.$to.pos, o)) &&
      t.dispatch(t.state.tr.insertText(o).scrollIntoView()),
      n.preventDefault();
  }
};
function Wd(t) {
  return { left: t.clientX, top: t.clientY };
}
function wN(t, e) {
  let n = e.x - t.clientX,
    r = e.y - t.clientY;
  return n * n + r * r < 100;
}
function dg(t, e, n, r, o) {
  if (r == -1) return !1;
  let i = t.state.doc.resolve(r);
  for (let l = i.depth + 1; l > 0; l--)
    if (
      t.someProp(e, (u) =>
        l > i.depth
          ? u(t, n, i.nodeAfter, i.before(l), o, !0)
          : u(t, n, i.node(l), i.before(l), o, !1)
      )
    )
      return !0;
  return !1;
}
function _s(t, e, n) {
  if ((t.focused || t.focus(), t.state.selection.eq(e))) return;
  let r = t.state.tr.setSelection(e);
  r.setMeta("pointer", !0), t.dispatch(r);
}
function xN(t, e) {
  if (e == -1) return !1;
  let n = t.state.doc.resolve(e),
    r = n.nodeAfter;
  return r && r.isAtom && ke.isSelectable(r) ? (_s(t, new ke(n)), !0) : !1;
}
function bN(t, e) {
  if (e == -1) return !1;
  let n = t.state.selection,
    r,
    o;
  n instanceof ke && (r = n.node);
  let i = t.state.doc.resolve(e);
  for (let l = i.depth + 1; l > 0; l--) {
    let u = l > i.depth ? i.nodeAfter : i.node(l);
    if (ke.isSelectable(u)) {
      r &&
      n.$from.depth > 0 &&
      l >= n.$from.depth &&
      i.before(n.$from.depth + 1) == n.$from.pos
        ? (o = i.before(n.$from.depth))
        : (o = i.before(l));
      break;
    }
  }
  return o != null ? (_s(t, ke.create(t.state.doc, o)), !0) : !1;
}
function SN(t, e, n, r, o) {
  return (
    dg(t, "handleClickOn", e, n, r) ||
    t.someProp("handleClick", (i) => i(t, e, r)) ||
    (o ? bN(t, n) : xN(t, n))
  );
}
function CN(t, e, n, r) {
  return (
    dg(t, "handleDoubleClickOn", e, n, r) ||
    t.someProp("handleDoubleClick", (o) => o(t, e, r))
  );
}
function kN(t, e, n, r) {
  return (
    dg(t, "handleTripleClickOn", e, n, r) ||
    t.someProp("handleTripleClick", (o) => o(t, e, r)) ||
    EN(t, n, r)
  );
}
function EN(t, e, n) {
  if (n.button != 0) return !1;
  let r = t.state.doc;
  if (e == -1)
    return r.inlineContent ? (_s(t, Te.create(r, 0, r.content.size)), !0) : !1;
  let o = r.resolve(e);
  for (let i = o.depth + 1; i > 0; i--) {
    let l = i > o.depth ? o.nodeAfter : o.node(i),
      u = o.before(i);
    if (l.inlineContent) _s(t, Te.create(r, u + 1, u + 1 + l.content.size));
    else if (ke.isSelectable(l)) _s(t, ke.create(r, u));
    else continue;
    return !0;
  }
}
function fg(t) {
  return Uc(t);
}
const tS = Mn ? "metaKey" : "ctrlKey";
Bt.mousedown = (t, e) => {
  let n = e;
  t.input.shiftKey = n.shiftKey;
  let r = fg(t),
    o = Date.now(),
    i = "singleClick";
  o - t.input.lastClick.time < 500 &&
    wN(n, t.input.lastClick) &&
    !n[tS] &&
    (t.input.lastClick.type == "singleClick"
      ? (i = "doubleClick")
      : t.input.lastClick.type == "doubleClick" && (i = "tripleClick")),
    (t.input.lastClick = { time: o, x: n.clientX, y: n.clientY, type: i });
  let l = t.posAtCoords(Wd(n));
  l &&
    (i == "singleClick"
      ? (t.input.mouseDown && t.input.mouseDown.done(),
        (t.input.mouseDown = new MN(t, l, n, !!r)))
      : (i == "doubleClick" ? CN : kN)(t, l.pos, l.inside, n)
      ? n.preventDefault()
      : Io(t, "pointer"));
};
class MN {
  constructor(e, n, r, o) {
    (this.view = e),
      (this.pos = n),
      (this.event = r),
      (this.flushed = o),
      (this.delayedSelectionSync = !1),
      (this.mightDrag = null),
      (this.startDoc = e.state.doc),
      (this.selectNode = !!r[tS]),
      (this.allowDefault = r.shiftKey);
    let i, l;
    if (n.inside > -1) (i = e.state.doc.nodeAt(n.inside)), (l = n.inside);
    else {
      let p = e.state.doc.resolve(n.pos);
      (i = p.parent), (l = p.depth ? p.before() : 0);
    }
    const u = o ? null : r.target,
      c = u ? e.docView.nearestDesc(u, !0) : null;
    this.target = c && c.dom.nodeType == 1 ? c.dom : null;
    let { selection: f } = e.state;
    ((r.button == 0 &&
      i.type.spec.draggable &&
      i.type.spec.selectable !== !1) ||
      (f instanceof ke && f.from <= l && f.to > l)) &&
      (this.mightDrag = {
        node: i,
        pos: l,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(
          this.target &&
          qn &&
          !this.target.hasAttribute("contentEditable")
        ),
      }),
      this.target &&
        this.mightDrag &&
        (this.mightDrag.addAttr || this.mightDrag.setUneditable) &&
        (this.view.domObserver.stop(),
        this.mightDrag.addAttr && (this.target.draggable = !0),
        this.mightDrag.setUneditable &&
          setTimeout(() => {
            this.view.input.mouseDown == this &&
              this.target.setAttribute("contentEditable", "false");
          }, 20),
        this.view.domObserver.start()),
      e.root.addEventListener("mouseup", (this.up = this.up.bind(this))),
      e.root.addEventListener("mousemove", (this.move = this.move.bind(this))),
      Io(e, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up),
      this.view.root.removeEventListener("mousemove", this.move),
      this.mightDrag &&
        this.target &&
        (this.view.domObserver.stop(),
        this.mightDrag.addAttr && this.target.removeAttribute("draggable"),
        this.mightDrag.setUneditable &&
          this.target.removeAttribute("contentEditable"),
        this.view.domObserver.start()),
      this.delayedSelectionSync && setTimeout(() => Ur(this.view)),
      (this.view.input.mouseDown = null);
  }
  up(e) {
    if ((this.done(), !this.view.dom.contains(e.target))) return;
    let n = this.pos;
    this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(Wd(e))),
      this.updateAllowDefault(e),
      this.allowDefault || !n
        ? Io(this.view, "pointer")
        : SN(this.view, n.pos, n.inside, e, this.selectNode)
        ? e.preventDefault()
        : e.button == 0 &&
          (this.flushed ||
            (jt && this.mightDrag && !this.mightDrag.node.isAtom) ||
            (It &&
              !this.view.state.selection.visible &&
              Math.min(
                Math.abs(n.pos - this.view.state.selection.from),
                Math.abs(n.pos - this.view.state.selection.to)
              ) <= 2))
        ? (_s(this.view, Ae.near(this.view.state.doc.resolve(n.pos))),
          e.preventDefault())
        : Io(this.view, "pointer");
  }
  move(e) {
    this.updateAllowDefault(e),
      Io(this.view, "pointer"),
      e.buttons == 0 && this.done();
  }
  updateAllowDefault(e) {
    !this.allowDefault &&
      (Math.abs(this.event.x - e.clientX) > 4 ||
        Math.abs(this.event.y - e.clientY) > 4) &&
      (this.allowDefault = !0);
  }
}
Bt.touchstart = (t) => {
  (t.input.lastTouch = Date.now()), fg(t), Io(t, "pointer");
};
Bt.touchmove = (t) => {
  (t.input.lastTouch = Date.now()), Io(t, "pointer");
};
Bt.contextmenu = (t) => fg(t);
function nS(t, e) {
  return t.composing
    ? !0
    : jt && Math.abs(e.timeStamp - t.input.compositionEndedAt) < 500
    ? ((t.input.compositionEndedAt = -2e8), !0)
    : !1;
}
const ON = Vr ? 5e3 : -1;
Ht.compositionstart = Ht.compositionupdate = (t) => {
  if (!t.composing) {
    t.domObserver.flush();
    let { state: e } = t,
      n = e.selection.$to;
    if (
      e.selection instanceof Te &&
      (e.storedMarks ||
        (!n.textOffset &&
          n.parentOffset &&
          n.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1)))
    )
      (t.markCursor = t.state.storedMarks || n.marks()),
        Uc(t, !0),
        (t.markCursor = null);
    else if (
      (Uc(t, !e.selection.empty),
      qn &&
        e.selection.empty &&
        n.parentOffset &&
        !n.textOffset &&
        n.nodeBefore.marks.length)
    ) {
      let r = t.domSelectionRange();
      for (
        let o = r.focusNode, i = r.focusOffset;
        o && o.nodeType == 1 && i != 0;

      ) {
        let l = i < 0 ? o.lastChild : o.childNodes[i - 1];
        if (!l) break;
        if (l.nodeType == 3) {
          let u = t.domSelection();
          u && u.collapse(l, l.nodeValue.length);
          break;
        } else (o = l), (i = -1);
      }
    }
    t.input.composing = !0;
  }
  rS(t, ON);
};
Ht.compositionend = (t, e) => {
  t.composing &&
    ((t.input.composing = !1),
    (t.input.compositionEndedAt = e.timeStamp),
    (t.input.compositionPendingChanges = t.domObserver.pendingRecords().length
      ? t.input.compositionID
      : 0),
    (t.input.compositionNode = null),
    t.input.compositionPendingChanges &&
      Promise.resolve().then(() => t.domObserver.flush()),
    t.input.compositionID++,
    rS(t, 20));
};
function rS(t, e) {
  clearTimeout(t.input.composingTimeout),
    e > -1 && (t.input.composingTimeout = setTimeout(() => Uc(t), e));
}
function oS(t) {
  for (
    t.composing &&
    ((t.input.composing = !1), (t.input.compositionEndedAt = NN()));
    t.input.compositionNodes.length > 0;

  )
    t.input.compositionNodes.pop().markParentsDirty();
}
function TN(t) {
  let e = t.domSelectionRange();
  if (!e.focusNode) return null;
  let n = xT(e.focusNode, e.focusOffset),
    r = bT(e.focusNode, e.focusOffset);
  if (n && r && n != r) {
    let o = r.pmViewDesc,
      i = t.domObserver.lastChangedTextNode;
    if (n == i || r == i) return i;
    if (!o || !o.isText(r.nodeValue)) return r;
    if (t.input.compositionNode == r) {
      let l = n.pmViewDesc;
      if (!(!l || !l.isText(n.nodeValue))) return r;
    }
  }
  return n || r;
}
function NN() {
  let t = document.createEvent("Event");
  return t.initEvent("event", !0, !0), t.timeStamp;
}
function Uc(t, e = !1) {
  if (!(Vr && t.domObserver.flushingSoon >= 0)) {
    if (
      (t.domObserver.forceFlush(), oS(t), e || (t.docView && t.docView.dirty))
    ) {
      let n = lg(t);
      return (
        n && !n.eq(t.state.selection)
          ? t.dispatch(t.state.tr.setSelection(n))
          : (t.markCursor || e) && !t.state.selection.empty
          ? t.dispatch(t.state.tr.deleteSelection())
          : t.updateState(t.state),
        !0
      );
    }
    return !1;
  }
}
function AN(t, e) {
  if (!t.dom.parentNode) return;
  let n = t.dom.parentNode.appendChild(document.createElement("div"));
  n.appendChild(e),
    (n.style.cssText = "position: fixed; left: -10000px; top: 10px");
  let r = getSelection(),
    o = document.createRange();
  o.selectNodeContents(e),
    t.dom.blur(),
    r.removeAllRanges(),
    r.addRange(o),
    setTimeout(() => {
      n.parentNode && n.parentNode.removeChild(n), t.focus();
    }, 50);
}
const xa = (tn && Fo < 15) || (Us && MT < 604);
Bt.copy = Ht.cut = (t, e) => {
  let n = e,
    r = t.state.selection,
    o = n.type == "cut";
  if (r.empty) return;
  let i = xa ? null : n.clipboardData,
    l = r.content(),
    { dom: u, text: c } = ug(t, l);
  i
    ? (n.preventDefault(),
      i.clearData(),
      i.setData("text/html", u.innerHTML),
      i.setData("text/plain", c))
    : AN(t, u),
    o &&
      t.dispatch(
        t.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut")
      );
};
function RN(t) {
  return t.openStart == 0 && t.openEnd == 0 && t.content.childCount == 1
    ? t.content.firstChild
    : null;
}
function PN(t, e) {
  if (!t.dom.parentNode) return;
  let n = t.input.shiftKey || t.state.selection.$from.parent.type.spec.code,
    r = t.dom.parentNode.appendChild(
      document.createElement(n ? "textarea" : "div")
    );
  n || (r.contentEditable = "true"),
    (r.style.cssText = "position: fixed; left: -10000px; top: 10px"),
    r.focus();
  let o = t.input.shiftKey && t.input.lastKeyCode != 45;
  setTimeout(() => {
    t.focus(),
      r.parentNode && r.parentNode.removeChild(r),
      n ? ba(t, r.value, null, o, e) : ba(t, r.textContent, r.innerHTML, o, e);
  }, 50);
}
function ba(t, e, n, r, o) {
  let i = Jb(t, e, n, r, t.state.selection.$from);
  if (t.someProp("handlePaste", (c) => c(t, o, i || ae.empty))) return !0;
  if (!i) return !1;
  let l = RN(i),
    u = l
      ? t.state.tr.replaceSelectionWith(l, r)
      : t.state.tr.replaceSelection(i);
  return (
    t.dispatch(
      u.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")
    ),
    !0
  );
}
function iS(t) {
  let e = t.getData("text/plain") || t.getData("Text");
  if (e) return e;
  let n = t.getData("text/uri-list");
  return n ? n.replace(/\r?\n/g, " ") : "";
}
Ht.paste = (t, e) => {
  let n = e;
  if (t.composing && !Vr) return;
  let r = xa ? null : n.clipboardData,
    o = t.input.shiftKey && t.input.lastKeyCode != 45;
  r && ba(t, iS(r), r.getData("text/html"), o, n)
    ? n.preventDefault()
    : PN(t, n);
};
class sS {
  constructor(e, n, r) {
    (this.slice = e), (this.move = n), (this.node = r);
  }
}
const lS = Mn ? "altKey" : "ctrlKey";
Bt.dragstart = (t, e) => {
  let n = e,
    r = t.input.mouseDown;
  if ((r && r.done(), !n.dataTransfer)) return;
  let o = t.state.selection,
    i = o.empty ? null : t.posAtCoords(Wd(n)),
    l;
  if (!(i && i.pos >= o.from && i.pos <= (o instanceof ke ? o.to - 1 : o.to))) {
    if (r && r.mightDrag) l = ke.create(t.state.doc, r.mightDrag.pos);
    else if (n.target && n.target.nodeType == 1) {
      let m = t.docView.nearestDesc(n.target, !0);
      m &&
        m.node.type.spec.draggable &&
        m != t.docView &&
        (l = ke.create(t.state.doc, m.posBefore));
    }
  }
  let u = (l || t.state.selection).content(),
    { dom: c, text: f, slice: p } = ug(t, u);
  (!n.dataTransfer.files.length || !It || Db > 120) &&
    n.dataTransfer.clearData(),
    n.dataTransfer.setData(xa ? "Text" : "text/html", c.innerHTML),
    (n.dataTransfer.effectAllowed = "copyMove"),
    xa || n.dataTransfer.setData("text/plain", f),
    (t.dragging = new sS(p, !n[lS], l));
};
Bt.dragend = (t) => {
  let e = t.dragging;
  window.setTimeout(() => {
    t.dragging == e && (t.dragging = null);
  }, 50);
};
Ht.dragover = Ht.dragenter = (t, e) => e.preventDefault();
Ht.drop = (t, e) => {
  let n = e,
    r = t.dragging;
  if (((t.dragging = null), !n.dataTransfer)) return;
  let o = t.posAtCoords(Wd(n));
  if (!o) return;
  let i = t.state.doc.resolve(o.pos),
    l = r && r.slice;
  l
    ? t.someProp("transformPasted", (x) => {
        l = x(l, t);
      })
    : (l = Jb(
        t,
        iS(n.dataTransfer),
        xa ? null : n.dataTransfer.getData("text/html"),
        !1,
        i
      ));
  let u = !!(r && !n[lS]);
  if (t.someProp("handleDrop", (x) => x(t, n, l || ae.empty, u))) {
    n.preventDefault();
    return;
  }
  if (!l) return;
  n.preventDefault();
  let c = l ? kb(t.state.doc, i.pos, l) : i.pos;
  c == null && (c = i.pos);
  let f = t.state.tr;
  if (u) {
    let { node: x } = r;
    x ? x.replace(f) : f.deleteSelection();
  }
  let p = f.mapping.map(c),
    m = l.openStart == 0 && l.openEnd == 0 && l.content.childCount == 1,
    y = f.doc;
  if (
    (m
      ? f.replaceRangeWith(p, p, l.content.firstChild)
      : f.replaceRange(p, p, l),
    f.doc.eq(y))
  )
    return;
  let v = f.doc.resolve(p);
  if (
    m &&
    ke.isSelectable(l.content.firstChild) &&
    v.nodeAfter &&
    v.nodeAfter.sameMarkup(l.content.firstChild)
  )
    f.setSelection(new ke(v));
  else {
    let x = f.mapping.map(c);
    f.mapping.maps[f.mapping.maps.length - 1].forEach((S, C, E, N) => (x = N)),
      f.setSelection(ag(t, v, f.doc.resolve(x)));
  }
  t.focus(), t.dispatch(f.setMeta("uiEvent", "drop"));
};
Bt.focus = (t) => {
  (t.input.lastFocus = Date.now()),
    t.focused ||
      (t.domObserver.stop(),
      t.dom.classList.add("ProseMirror-focused"),
      t.domObserver.start(),
      (t.focused = !0),
      setTimeout(() => {
        t.docView &&
          t.hasFocus() &&
          !t.domObserver.currentSelection.eq(t.domSelectionRange()) &&
          Ur(t);
      }, 20));
};
Bt.blur = (t, e) => {
  let n = e;
  t.focused &&
    (t.domObserver.stop(),
    t.dom.classList.remove("ProseMirror-focused"),
    t.domObserver.start(),
    n.relatedTarget &&
      t.dom.contains(n.relatedTarget) &&
      t.domObserver.currentSelection.clear(),
    (t.focused = !1));
};
Bt.beforeinput = (t, e) => {
  if (It && Vr && e.inputType == "deleteContentBackward") {
    t.domObserver.flushSoon();
    let { domChangeCount: r } = t.input;
    setTimeout(() => {
      if (
        t.input.domChangeCount != r ||
        (t.dom.blur(),
        t.focus(),
        t.someProp("handleKeyDown", (i) => i(t, bi(8, "Backspace"))))
      )
        return;
      let { $cursor: o } = t.state.selection;
      o &&
        o.pos > 0 &&
        t.dispatch(t.state.tr.delete(o.pos - 1, o.pos).scrollIntoView());
    }, 50);
  }
};
for (let t in Ht) Bt[t] = Ht[t];
function Sa(t, e) {
  if (t == e) return !0;
  for (let n in t) if (t[n] !== e[n]) return !1;
  for (let n in e) if (!(n in t)) return !1;
  return !0;
}
class Kc {
  constructor(e, n) {
    (this.toDOM = e), (this.spec = n || Ai), (this.side = this.spec.side || 0);
  }
  map(e, n, r, o) {
    let { pos: i, deleted: l } = e.mapResult(
      n.from + o,
      this.side < 0 ? -1 : 1
    );
    return l ? null : new Tn(i - r, i - r, this);
  }
  valid() {
    return !0;
  }
  eq(e) {
    return (
      this == e ||
      (e instanceof Kc &&
        ((this.spec.key && this.spec.key == e.spec.key) ||
          (this.toDOM == e.toDOM && Sa(this.spec, e.spec))))
    );
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e);
  }
}
class jo {
  constructor(e, n) {
    (this.attrs = e), (this.spec = n || Ai);
  }
  map(e, n, r, o) {
    let i = e.map(n.from + o, this.spec.inclusiveStart ? -1 : 1) - r,
      l = e.map(n.to + o, this.spec.inclusiveEnd ? 1 : -1) - r;
    return i >= l ? null : new Tn(i, l, this);
  }
  valid(e, n) {
    return n.from < n.to;
  }
  eq(e) {
    return (
      this == e ||
      (e instanceof jo && Sa(this.attrs, e.attrs) && Sa(this.spec, e.spec))
    );
  }
  static is(e) {
    return e.type instanceof jo;
  }
  destroy() {}
}
class pg {
  constructor(e, n) {
    (this.attrs = e), (this.spec = n || Ai);
  }
  map(e, n, r, o) {
    let i = e.mapResult(n.from + o, 1);
    if (i.deleted) return null;
    let l = e.mapResult(n.to + o, -1);
    return l.deleted || l.pos <= i.pos
      ? null
      : new Tn(i.pos - r, l.pos - r, this);
  }
  valid(e, n) {
    let { index: r, offset: o } = e.content.findIndex(n.from),
      i;
    return o == n.from && !(i = e.child(r)).isText && o + i.nodeSize == n.to;
  }
  eq(e) {
    return (
      this == e ||
      (e instanceof pg && Sa(this.attrs, e.attrs) && Sa(this.spec, e.spec))
    );
  }
  destroy() {}
}
class Tn {
  constructor(e, n, r) {
    (this.from = e), (this.to = n), (this.type = r);
  }
  copy(e, n) {
    return new Tn(e, n, this.type);
  }
  eq(e, n = 0) {
    return (
      this.type.eq(e.type) && this.from + n == e.from && this.to + n == e.to
    );
  }
  map(e, n, r) {
    return this.type.map(e, this, n, r);
  }
  static widget(e, n, r) {
    return new Tn(e, e, new Kc(n, r));
  }
  static inline(e, n, r, o) {
    return new Tn(e, n, new jo(r, o));
  }
  static node(e, n, r, o) {
    return new Tn(e, n, new pg(r, o));
  }
  get spec() {
    return this.type.spec;
  }
  get inline() {
    return this.type instanceof jo;
  }
  get widget() {
    return this.type instanceof Kc;
  }
}
const Ns = [],
  Ai = {};
class ct {
  constructor(e, n) {
    (this.local = e.length ? e : Ns), (this.children = n.length ? n : Ns);
  }
  static create(e, n) {
    return n.length ? qc(n, e, 0, Ai) : Pt;
  }
  find(e, n, r) {
    let o = [];
    return this.findInner(e ?? 0, n ?? 1e9, o, 0, r), o;
  }
  findInner(e, n, r, o, i) {
    for (let l = 0; l < this.local.length; l++) {
      let u = this.local[l];
      u.from <= n &&
        u.to >= e &&
        (!i || i(u.spec)) &&
        r.push(u.copy(u.from + o, u.to + o));
    }
    for (let l = 0; l < this.children.length; l += 3)
      if (this.children[l] < n && this.children[l + 1] > e) {
        let u = this.children[l] + 1;
        this.children[l + 2].findInner(e - u, n - u, r, o + u, i);
      }
  }
  map(e, n, r) {
    return this == Pt || e.maps.length == 0
      ? this
      : this.mapInner(e, n, 0, 0, r || Ai);
  }
  mapInner(e, n, r, o, i) {
    let l;
    for (let u = 0; u < this.local.length; u++) {
      let c = this.local[u].map(e, r, o);
      c && c.type.valid(n, c)
        ? (l || (l = [])).push(c)
        : i.onRemove && i.onRemove(this.local[u].spec);
    }
    return this.children.length
      ? DN(this.children, l || [], e, n, r, o, i)
      : l
      ? new ct(l.sort(Ri), Ns)
      : Pt;
  }
  add(e, n) {
    return n.length
      ? this == Pt
        ? ct.create(e, n)
        : this.addInner(e, n, 0)
      : this;
  }
  addInner(e, n, r) {
    let o,
      i = 0;
    e.forEach((u, c) => {
      let f = c + r,
        p;
      if ((p = uS(n, u, f))) {
        for (o || (o = this.children.slice()); i < o.length && o[i] < c; )
          i += 3;
        o[i] == c
          ? (o[i + 2] = o[i + 2].addInner(u, p, f + 1))
          : o.splice(i, 0, c, c + u.nodeSize, qc(p, u, f + 1, Ai)),
          (i += 3);
      }
    });
    let l = aS(i ? cS(n) : n, -r);
    for (let u = 0; u < l.length; u++)
      l[u].type.valid(e, l[u]) || l.splice(u--, 1);
    return new ct(
      l.length ? this.local.concat(l).sort(Ri) : this.local,
      o || this.children
    );
  }
  remove(e) {
    return e.length == 0 || this == Pt ? this : this.removeInner(e, 0);
  }
  removeInner(e, n) {
    let r = this.children,
      o = this.local;
    for (let i = 0; i < r.length; i += 3) {
      let l,
        u = r[i] + n,
        c = r[i + 1] + n;
      for (let p = 0, m; p < e.length; p++)
        (m = e[p]) &&
          m.from > u &&
          m.to < c &&
          ((e[p] = null), (l || (l = [])).push(m));
      if (!l) continue;
      r == this.children && (r = this.children.slice());
      let f = r[i + 2].removeInner(l, u + 1);
      f != Pt ? (r[i + 2] = f) : (r.splice(i, 3), (i -= 3));
    }
    if (o.length) {
      for (let i = 0, l; i < e.length; i++)
        if ((l = e[i]))
          for (let u = 0; u < o.length; u++)
            o[u].eq(l, n) &&
              (o == this.local && (o = this.local.slice()), o.splice(u--, 1));
    }
    return r == this.children && o == this.local
      ? this
      : o.length || r.length
      ? new ct(o, r)
      : Pt;
  }
  forChild(e, n) {
    if (this == Pt) return this;
    if (n.isLeaf) return ct.empty;
    let r, o;
    for (let u = 0; u < this.children.length; u += 3)
      if (this.children[u] >= e) {
        this.children[u] == e && (r = this.children[u + 2]);
        break;
      }
    let i = e + 1,
      l = i + n.content.size;
    for (let u = 0; u < this.local.length; u++) {
      let c = this.local[u];
      if (c.from < l && c.to > i && c.type instanceof jo) {
        let f = Math.max(i, c.from) - i,
          p = Math.min(l, c.to) - i;
        f < p && (o || (o = [])).push(c.copy(f, p));
      }
    }
    if (o) {
      let u = new ct(o.sort(Ri), Ns);
      return r ? new No([u, r]) : u;
    }
    return r || Pt;
  }
  eq(e) {
    if (this == e) return !0;
    if (
      !(e instanceof ct) ||
      this.local.length != e.local.length ||
      this.children.length != e.children.length
    )
      return !1;
    for (let n = 0; n < this.local.length; n++)
      if (!this.local[n].eq(e.local[n])) return !1;
    for (let n = 0; n < this.children.length; n += 3)
      if (
        this.children[n] != e.children[n] ||
        this.children[n + 1] != e.children[n + 1] ||
        !this.children[n + 2].eq(e.children[n + 2])
      )
        return !1;
    return !0;
  }
  locals(e) {
    return hg(this.localsInner(e));
  }
  localsInner(e) {
    if (this == Pt) return Ns;
    if (e.inlineContent || !this.local.some(jo.is)) return this.local;
    let n = [];
    for (let r = 0; r < this.local.length; r++)
      this.local[r].type instanceof jo || n.push(this.local[r]);
    return n;
  }
  forEachSet(e) {
    e(this);
  }
}
ct.empty = new ct([], []);
ct.removeOverlap = hg;
const Pt = ct.empty;
class No {
  constructor(e) {
    this.members = e;
  }
  map(e, n) {
    const r = this.members.map((o) => o.map(e, n, Ai));
    return No.from(r);
  }
  forChild(e, n) {
    if (n.isLeaf) return ct.empty;
    let r = [];
    for (let o = 0; o < this.members.length; o++) {
      let i = this.members[o].forChild(e, n);
      i != Pt && (i instanceof No ? (r = r.concat(i.members)) : r.push(i));
    }
    return No.from(r);
  }
  eq(e) {
    if (!(e instanceof No) || e.members.length != this.members.length)
      return !1;
    for (let n = 0; n < this.members.length; n++)
      if (!this.members[n].eq(e.members[n])) return !1;
    return !0;
  }
  locals(e) {
    let n,
      r = !0;
    for (let o = 0; o < this.members.length; o++) {
      let i = this.members[o].localsInner(e);
      if (i.length)
        if (!n) n = i;
        else {
          r && ((n = n.slice()), (r = !1));
          for (let l = 0; l < i.length; l++) n.push(i[l]);
        }
    }
    return n ? hg(r ? n : n.sort(Ri)) : Ns;
  }
  static from(e) {
    switch (e.length) {
      case 0:
        return Pt;
      case 1:
        return e[0];
      default:
        return new No(
          e.every((n) => n instanceof ct)
            ? e
            : e.reduce((n, r) => n.concat(r instanceof ct ? r : r.members), [])
        );
    }
  }
  forEachSet(e) {
    for (let n = 0; n < this.members.length; n++) this.members[n].forEachSet(e);
  }
}
function DN(t, e, n, r, o, i, l) {
  let u = t.slice();
  for (let f = 0, p = i; f < n.maps.length; f++) {
    let m = 0;
    n.maps[f].forEach((y, v, x, S) => {
      let C = S - x - (v - y);
      for (let E = 0; E < u.length; E += 3) {
        let N = u[E + 1];
        if (N < 0 || y > N + p - m) continue;
        let $ = u[E] + p - m;
        v >= $
          ? (u[E + 1] = y <= $ ? -2 : -1)
          : y >= p && C && ((u[E] += C), (u[E + 1] += C));
      }
      m += C;
    }),
      (p = n.maps[f].map(p, -1));
  }
  let c = !1;
  for (let f = 0; f < u.length; f += 3)
    if (u[f + 1] < 0) {
      if (u[f + 1] == -2) {
        (c = !0), (u[f + 1] = -1);
        continue;
      }
      let p = n.map(t[f] + i),
        m = p - o;
      if (m < 0 || m >= r.content.size) {
        c = !0;
        continue;
      }
      let y = n.map(t[f + 1] + i, -1),
        v = y - o,
        { index: x, offset: S } = r.content.findIndex(m),
        C = r.maybeChild(x);
      if (C && S == m && S + C.nodeSize == v) {
        let E = u[f + 2].mapInner(n, C, p + 1, t[f] + i + 1, l);
        E != Pt
          ? ((u[f] = m), (u[f + 1] = v), (u[f + 2] = E))
          : ((u[f + 1] = -2), (c = !0));
      } else c = !0;
    }
  if (c) {
    let f = IN(u, t, e, n, o, i, l),
      p = qc(f, r, 0, l);
    e = p.local;
    for (let m = 0; m < u.length; m += 3)
      u[m + 1] < 0 && (u.splice(m, 3), (m -= 3));
    for (let m = 0, y = 0; m < p.children.length; m += 3) {
      let v = p.children[m];
      for (; y < u.length && u[y] < v; ) y += 3;
      u.splice(y, 0, p.children[m], p.children[m + 1], p.children[m + 2]);
    }
  }
  return new ct(e.sort(Ri), u);
}
function aS(t, e) {
  if (!e || !t.length) return t;
  let n = [];
  for (let r = 0; r < t.length; r++) {
    let o = t[r];
    n.push(new Tn(o.from + e, o.to + e, o.type));
  }
  return n;
}
function IN(t, e, n, r, o, i, l) {
  function u(c, f) {
    for (let p = 0; p < c.local.length; p++) {
      let m = c.local[p].map(r, o, f);
      m ? n.push(m) : l.onRemove && l.onRemove(c.local[p].spec);
    }
    for (let p = 0; p < c.children.length; p += 3)
      u(c.children[p + 2], c.children[p] + f + 1);
  }
  for (let c = 0; c < t.length; c += 3)
    t[c + 1] == -1 && u(t[c + 2], e[c] + i + 1);
  return n;
}
function uS(t, e, n) {
  if (e.isLeaf) return null;
  let r = n + e.nodeSize,
    o = null;
  for (let i = 0, l; i < t.length; i++)
    (l = t[i]) &&
      l.from > n &&
      l.to < r &&
      ((o || (o = [])).push(l), (t[i] = null));
  return o;
}
function cS(t) {
  let e = [];
  for (let n = 0; n < t.length; n++) t[n] != null && e.push(t[n]);
  return e;
}
function qc(t, e, n, r) {
  let o = [],
    i = !1;
  e.forEach((u, c) => {
    let f = uS(t, u, c + n);
    if (f) {
      i = !0;
      let p = qc(f, u, n + c + 1, r);
      p != Pt && o.push(c, c + u.nodeSize, p);
    }
  });
  let l = aS(i ? cS(t) : t, -n).sort(Ri);
  for (let u = 0; u < l.length; u++)
    l[u].type.valid(e, l[u]) ||
      (r.onRemove && r.onRemove(l[u].spec), l.splice(u--, 1));
  return l.length || o.length ? new ct(l, o) : Pt;
}
function Ri(t, e) {
  return t.from - e.from || t.to - e.to;
}
function hg(t) {
  let e = t;
  for (let n = 0; n < e.length - 1; n++) {
    let r = e[n];
    if (r.from != r.to)
      for (let o = n + 1; o < e.length; o++) {
        let i = e[o];
        if (i.from == r.from) {
          i.to != r.to &&
            (e == t && (e = t.slice()),
            (e[o] = i.copy(i.from, r.to)),
            lw(e, o + 1, i.copy(r.to, i.to)));
          continue;
        } else {
          i.from < r.to &&
            (e == t && (e = t.slice()),
            (e[n] = r.copy(r.from, i.from)),
            lw(e, o, r.copy(i.from, r.to)));
          break;
        }
      }
  }
  return e;
}
function lw(t, e, n) {
  for (; e < t.length && Ri(n, t[e]) > 0; ) e++;
  t.splice(e, 0, n);
}
function vh(t) {
  let e = [];
  return (
    t.someProp("decorations", (n) => {
      let r = n(t.state);
      r && r != Pt && e.push(r);
    }),
    t.cursorWrapper && e.push(ct.create(t.state.doc, [t.cursorWrapper.deco])),
    No.from(e)
  );
}
const LN = {
    childList: !0,
    characterData: !0,
    characterDataOldValue: !0,
    attributes: !0,
    attributeOldValue: !0,
    subtree: !0,
  },
  $N = tn && Fo <= 11;
class _N {
  constructor() {
    (this.anchorNode = null),
      (this.anchorOffset = 0),
      (this.focusNode = null),
      (this.focusOffset = 0);
  }
  set(e) {
    (this.anchorNode = e.anchorNode),
      (this.anchorOffset = e.anchorOffset),
      (this.focusNode = e.focusNode),
      (this.focusOffset = e.focusOffset);
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(e) {
    return (
      e.anchorNode == this.anchorNode &&
      e.anchorOffset == this.anchorOffset &&
      e.focusNode == this.focusNode &&
      e.focusOffset == this.focusOffset
    );
  }
}
class FN {
  constructor(e, n) {
    (this.view = e),
      (this.handleDOMChange = n),
      (this.queue = []),
      (this.flushingSoon = -1),
      (this.observer = null),
      (this.currentSelection = new _N()),
      (this.onCharData = null),
      (this.suppressingSelectionUpdates = !1),
      (this.lastChangedTextNode = null),
      (this.observer =
        window.MutationObserver &&
        new window.MutationObserver((r) => {
          for (let o = 0; o < r.length; o++) this.queue.push(r[o]);
          tn &&
          Fo <= 11 &&
          r.some(
            (o) =>
              (o.type == "childList" && o.removedNodes.length) ||
              (o.type == "characterData" &&
                o.oldValue.length > o.target.nodeValue.length)
          )
            ? this.flushSoon()
            : this.flush();
        })),
      $N &&
        (this.onCharData = (r) => {
          this.queue.push({
            target: r.target,
            type: "characterData",
            oldValue: r.prevValue,
          }),
            this.flushSoon();
        }),
      (this.onSelectionChange = this.onSelectionChange.bind(this));
  }
  flushSoon() {
    this.flushingSoon < 0 &&
      (this.flushingSoon = window.setTimeout(() => {
        (this.flushingSoon = -1), this.flush();
      }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 &&
      (window.clearTimeout(this.flushingSoon),
      (this.flushingSoon = -1),
      this.flush());
  }
  start() {
    this.observer &&
      (this.observer.takeRecords(), this.observer.observe(this.view.dom, LN)),
      this.onCharData &&
        this.view.dom.addEventListener(
          "DOMCharacterDataModified",
          this.onCharData
        ),
      this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let e = this.observer.takeRecords();
      if (e.length) {
        for (let n = 0; n < e.length; n++) this.queue.push(e[n]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData &&
      this.view.dom.removeEventListener(
        "DOMCharacterDataModified",
        this.onCharData
      ),
      this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener(
      "selectionchange",
      this.onSelectionChange
    );
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener(
      "selectionchange",
      this.onSelectionChange
    );
  }
  suppressSelectionUpdates() {
    (this.suppressingSelectionUpdates = !0),
      setTimeout(() => (this.suppressingSelectionUpdates = !1), 50);
  }
  onSelectionChange() {
    if (Z1(this.view)) {
      if (this.suppressingSelectionUpdates) return Ur(this.view);
      if (tn && Fo <= 11 && !this.view.state.selection.empty) {
        let e = this.view.domSelectionRange();
        if (
          e.focusNode &&
          Li(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset)
        )
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(e) {
    if (!e.focusNode) return !0;
    let n = new Set(),
      r;
    for (let i = e.focusNode; i; i = Ws(i)) n.add(i);
    for (let i = e.anchorNode; i; i = Ws(i))
      if (n.has(i)) {
        r = i;
        break;
      }
    let o = r && this.view.docView.nearestDesc(r);
    if (
      o &&
      o.ignoreMutation({
        type: "selection",
        target: r.nodeType == 3 ? r.parentNode : r,
      })
    )
      return this.setCurSelection(), !0;
  }
  pendingRecords() {
    if (this.observer)
      for (let e of this.observer.takeRecords()) this.queue.push(e);
    return this.queue;
  }
  flush() {
    let { view: e } = this;
    if (!e.docView || this.flushingSoon > -1) return;
    let n = this.pendingRecords();
    n.length && (this.queue = []);
    let r = e.domSelectionRange(),
      o =
        !this.suppressingSelectionUpdates &&
        !this.currentSelection.eq(r) &&
        Z1(e) &&
        !this.ignoreSelectionChange(r),
      i = -1,
      l = -1,
      u = !1,
      c = [];
    if (e.editable)
      for (let p = 0; p < n.length; p++) {
        let m = this.registerMutation(n[p], c);
        m &&
          ((i = i < 0 ? m.from : Math.min(m.from, i)),
          (l = l < 0 ? m.to : Math.max(m.to, l)),
          m.typeOver && (u = !0));
      }
    if (qn && c.length) {
      let p = c.filter((m) => m.nodeName == "BR");
      if (p.length == 2) {
        let [m, y] = p;
        m.parentNode && m.parentNode.parentNode == y.parentNode
          ? y.remove()
          : m.remove();
      } else {
        let { focusNode: m } = this.currentSelection;
        for (let y of p) {
          let v = y.parentNode;
          v && v.nodeName == "LI" && (!m || BN(e, m) != v) && y.remove();
        }
      }
    }
    let f = null;
    i < 0 &&
    o &&
    e.input.lastFocus > Date.now() - 200 &&
    Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 &&
    Hd(r) &&
    (f = lg(e)) &&
    f.eq(Ae.near(e.state.doc.resolve(0), 1))
      ? ((e.input.lastFocus = 0),
        Ur(e),
        this.currentSelection.set(r),
        e.scrollToSelection())
      : (i > -1 || o) &&
        (i > -1 && (e.docView.markDirty(i, l), zN(e)),
        this.handleDOMChange(i, l, u, c),
        e.docView && e.docView.dirty
          ? e.updateState(e.state)
          : this.currentSelection.eq(r) || Ur(e),
        this.currentSelection.set(r));
  }
  registerMutation(e, n) {
    if (n.indexOf(e.target) > -1) return null;
    let r = this.view.docView.nearestDesc(e.target);
    if (
      (e.type == "attributes" &&
        (r == this.view.docView ||
          e.attributeName == "contenteditable" ||
          (e.attributeName == "style" &&
            !e.oldValue &&
            !e.target.getAttribute("style")))) ||
      !r ||
      r.ignoreMutation(e)
    )
      return null;
    if (e.type == "childList") {
      for (let p = 0; p < e.addedNodes.length; p++) {
        let m = e.addedNodes[p];
        n.push(m), m.nodeType == 3 && (this.lastChangedTextNode = m);
      }
      if (
        r.contentDOM &&
        r.contentDOM != r.dom &&
        !r.contentDOM.contains(e.target)
      )
        return { from: r.posBefore, to: r.posAfter };
      let o = e.previousSibling,
        i = e.nextSibling;
      if (tn && Fo <= 11 && e.addedNodes.length)
        for (let p = 0; p < e.addedNodes.length; p++) {
          let { previousSibling: m, nextSibling: y } = e.addedNodes[p];
          (!m || Array.prototype.indexOf.call(e.addedNodes, m) < 0) && (o = m),
            (!y || Array.prototype.indexOf.call(e.addedNodes, y) < 0) &&
              (i = y);
        }
      let l = o && o.parentNode == e.target ? kt(o) + 1 : 0,
        u = r.localPosFromDOM(e.target, l, -1),
        c = i && i.parentNode == e.target ? kt(i) : e.target.childNodes.length,
        f = r.localPosFromDOM(e.target, c, 1);
      return { from: u, to: f };
    } else
      return e.type == "attributes"
        ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border }
        : ((this.lastChangedTextNode = e.target),
          {
            from: r.posAtStart,
            to: r.posAtEnd,
            typeOver: e.target.nodeValue == e.oldValue,
          });
  }
}
let aw = new WeakMap(),
  uw = !1;
function zN(t) {
  if (
    !aw.has(t) &&
    (aw.set(t, null),
    ["normal", "nowrap", "pre-line"].indexOf(
      getComputedStyle(t.dom).whiteSpace
    ) !== -1)
  ) {
    if (((t.requiresGeckoHackNode = qn), uw)) return;
    console.warn(
      "ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."
    ),
      (uw = !0);
  }
}
function cw(t, e) {
  let n = e.startContainer,
    r = e.startOffset,
    o = e.endContainer,
    i = e.endOffset,
    l = t.domAtPos(t.state.selection.anchor);
  return (
    Li(l.node, l.offset, o, i) && ([n, r, o, i] = [o, i, n, r]),
    { anchorNode: n, anchorOffset: r, focusNode: o, focusOffset: i }
  );
}
function jN(t, e) {
  if (e.getComposedRanges) {
    let o = e.getComposedRanges(t.root)[0];
    if (o) return cw(t, o);
  }
  let n;
  function r(o) {
    o.preventDefault(),
      o.stopImmediatePropagation(),
      (n = o.getTargetRanges()[0]);
  }
  return (
    t.dom.addEventListener("beforeinput", r, !0),
    document.execCommand("indent"),
    t.dom.removeEventListener("beforeinput", r, !0),
    n ? cw(t, n) : null
  );
}
function BN(t, e) {
  for (let n = e.parentNode; n && n != t.dom; n = n.parentNode) {
    let r = t.docView.nearestDesc(n, !0);
    if (r && r.node.isBlock) return n;
  }
  return null;
}
function HN(t, e, n) {
  let {
      node: r,
      fromOffset: o,
      toOffset: i,
      from: l,
      to: u,
    } = t.docView.parseRange(e, n),
    c = t.domSelectionRange(),
    f,
    p = c.anchorNode;
  if (
    (p &&
      t.dom.contains(p.nodeType == 1 ? p : p.parentNode) &&
      ((f = [{ node: p, offset: c.anchorOffset }]),
      Hd(c) || f.push({ node: c.focusNode, offset: c.focusOffset })),
    It && t.input.lastKeyCode === 8)
  )
    for (let C = i; C > o; C--) {
      let E = r.childNodes[C - 1],
        N = E.pmViewDesc;
      if (E.nodeName == "BR" && !N) {
        i = C;
        break;
      }
      if (!N || N.size) break;
    }
  let m = t.state.doc,
    y = t.someProp("domParser") || _o.fromSchema(t.state.schema),
    v = m.resolve(l),
    x = null,
    S = y.parse(r, {
      topNode: v.parent,
      topMatch: v.parent.contentMatchAt(v.index()),
      topOpen: !0,
      from: o,
      to: i,
      preserveWhitespace: v.parent.type.whitespace == "pre" ? "full" : !0,
      findPositions: f,
      ruleFromNode: VN,
      context: v,
    });
  if (f && f[0].pos != null) {
    let C = f[0].pos,
      E = f[1] && f[1].pos;
    E == null && (E = C), (x = { anchor: C + l, head: E + l });
  }
  return { doc: S, sel: x, from: l, to: u };
}
function VN(t) {
  let e = t.pmViewDesc;
  if (e) return e.parseRule();
  if (t.nodeName == "BR" && t.parentNode) {
    if (jt && /^(ul|ol)$/i.test(t.parentNode.nodeName)) {
      let n = document.createElement("div");
      return n.appendChild(document.createElement("li")), { skip: n };
    } else if (
      t.parentNode.lastChild == t ||
      (jt && /^(tr|table)$/i.test(t.parentNode.nodeName))
    )
      return { ignore: !0 };
  } else if (t.nodeName == "IMG" && t.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const WN =
  /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function UN(t, e, n, r, o) {
  let i =
    t.input.compositionPendingChanges ||
    (t.composing ? t.input.compositionID : 0);
  if (((t.input.compositionPendingChanges = 0), e < 0)) {
    let U =
        t.input.lastSelectionTime > Date.now() - 50
          ? t.input.lastSelectionOrigin
          : null,
      re = lg(t, U);
    if (re && !t.state.selection.eq(re)) {
      if (
        It &&
        Vr &&
        t.input.lastKeyCode === 13 &&
        Date.now() - 100 < t.input.lastKeyCodeTime &&
        t.someProp("handleKeyDown", (ee) => ee(t, bi(13, "Enter")))
      )
        return;
      let ce = t.state.tr.setSelection(re);
      U == "pointer"
        ? ce.setMeta("pointer", !0)
        : U == "key" && ce.scrollIntoView(),
        i && ce.setMeta("composition", i),
        t.dispatch(ce);
    }
    return;
  }
  let l = t.state.doc.resolve(e),
    u = l.sharedDepth(n);
  (e = l.before(u + 1)), (n = t.state.doc.resolve(n).after(u + 1));
  let c = t.state.selection,
    f = HN(t, e, n),
    p = t.state.doc,
    m = p.slice(f.from, f.to),
    y,
    v;
  t.input.lastKeyCode === 8 && Date.now() - 100 < t.input.lastKeyCodeTime
    ? ((y = t.state.selection.to), (v = "end"))
    : ((y = t.state.selection.from), (v = "start")),
    (t.input.lastKeyCode = null);
  let x = GN(m.content, f.doc.content, f.from, y, v);
  if (
    (x && t.input.domChangeCount++,
    ((Us && t.input.lastIOSEnter > Date.now() - 225) || Vr) &&
      o.some((U) => U.nodeType == 1 && !WN.test(U.nodeName)) &&
      (!x || x.endA >= x.endB) &&
      t.someProp("handleKeyDown", (U) => U(t, bi(13, "Enter"))))
  ) {
    t.input.lastIOSEnter = 0;
    return;
  }
  if (!x)
    if (
      r &&
      c instanceof Te &&
      !c.empty &&
      c.$head.sameParent(c.$anchor) &&
      !t.composing &&
      !(f.sel && f.sel.anchor != f.sel.head)
    )
      x = { start: c.from, endA: c.to, endB: c.to };
    else {
      if (f.sel) {
        let U = dw(t, t.state.doc, f.sel);
        if (U && !U.eq(t.state.selection)) {
          let re = t.state.tr.setSelection(U);
          i && re.setMeta("composition", i), t.dispatch(re);
        }
      }
      return;
    }
  t.state.selection.from < t.state.selection.to &&
    x.start == x.endB &&
    t.state.selection instanceof Te &&
    (x.start > t.state.selection.from &&
    x.start <= t.state.selection.from + 2 &&
    t.state.selection.from >= f.from
      ? (x.start = t.state.selection.from)
      : x.endA < t.state.selection.to &&
        x.endA >= t.state.selection.to - 2 &&
        t.state.selection.to <= f.to &&
        ((x.endB += t.state.selection.to - x.endA),
        (x.endA = t.state.selection.to))),
    tn &&
      Fo <= 11 &&
      x.endB == x.start + 1 &&
      x.endA == x.start &&
      x.start > f.from &&
      f.doc.textBetween(x.start - f.from - 1, x.start - f.from + 1) == " " &&
      (x.start--, x.endA--, x.endB--);
  let S = f.doc.resolveNoCache(x.start - f.from),
    C = f.doc.resolveNoCache(x.endB - f.from),
    E = p.resolve(x.start),
    N = S.sameParent(C) && S.parent.inlineContent && E.end() >= x.endA,
    $;
  if (
    ((Us &&
      t.input.lastIOSEnter > Date.now() - 225 &&
      (!N || o.some((U) => U.nodeName == "DIV" || U.nodeName == "P"))) ||
      (!N &&
        S.pos < f.doc.content.size &&
        !S.sameParent(C) &&
        ($ = Ae.findFrom(f.doc.resolve(S.pos + 1), 1, !0)) &&
        $.head == C.pos)) &&
    t.someProp("handleKeyDown", (U) => U(t, bi(13, "Enter")))
  ) {
    t.input.lastIOSEnter = 0;
    return;
  }
  if (
    t.state.selection.anchor > x.start &&
    qN(p, x.start, x.endA, S, C) &&
    t.someProp("handleKeyDown", (U) => U(t, bi(8, "Backspace")))
  ) {
    Vr && It && t.domObserver.suppressSelectionUpdates();
    return;
  }
  It && x.endB == x.start && (t.input.lastChromeDelete = Date.now()),
    Vr &&
      !N &&
      S.start() != C.start() &&
      C.parentOffset == 0 &&
      S.depth == C.depth &&
      f.sel &&
      f.sel.anchor == f.sel.head &&
      f.sel.head == x.endA &&
      ((x.endB -= 2),
      (C = f.doc.resolveNoCache(x.endB - f.from)),
      setTimeout(() => {
        t.someProp("handleKeyDown", function (U) {
          return U(t, bi(13, "Enter"));
        });
      }, 20));
  let M = x.start,
    I = x.endA,
    R,
    F,
    H;
  if (N) {
    if (S.pos == C.pos)
      tn &&
        Fo <= 11 &&
        S.parentOffset == 0 &&
        (t.domObserver.suppressSelectionUpdates(), setTimeout(() => Ur(t), 20)),
        (R = t.state.tr.delete(M, I)),
        (F = p.resolve(x.start).marksAcross(p.resolve(x.endA)));
    else if (
      x.endA == x.endB &&
      (H = KN(
        S.parent.content.cut(S.parentOffset, C.parentOffset),
        E.parent.content.cut(E.parentOffset, x.endA - E.start())
      ))
    )
      (R = t.state.tr),
        H.type == "add" ? R.addMark(M, I, H.mark) : R.removeMark(M, I, H.mark);
    else if (
      S.parent.child(S.index()).isText &&
      S.index() == C.index() - (C.textOffset ? 0 : 1)
    ) {
      let U = S.parent.textBetween(S.parentOffset, C.parentOffset);
      if (t.someProp("handleTextInput", (re) => re(t, M, I, U))) return;
      R = t.state.tr.insertText(U, M, I);
    }
  }
  if (
    (R ||
      (R = t.state.tr.replace(
        M,
        I,
        f.doc.slice(x.start - f.from, x.endB - f.from)
      )),
    f.sel)
  ) {
    let U = dw(t, R.doc, f.sel);
    U &&
      !(
        (It &&
          t.composing &&
          U.empty &&
          (x.start != x.endB || t.input.lastChromeDelete < Date.now() - 100) &&
          (U.head == M || U.head == R.mapping.map(I) - 1)) ||
        (tn && U.empty && U.head == M)
      ) &&
      R.setSelection(U);
  }
  F && R.ensureMarks(F),
    i && R.setMeta("composition", i),
    t.dispatch(R.scrollIntoView());
}
function dw(t, e, n) {
  return Math.max(n.anchor, n.head) > e.content.size
    ? null
    : ag(t, e.resolve(n.anchor), e.resolve(n.head));
}
function KN(t, e) {
  let n = t.firstChild.marks,
    r = e.firstChild.marks,
    o = n,
    i = r,
    l,
    u,
    c;
  for (let p = 0; p < r.length; p++) o = r[p].removeFromSet(o);
  for (let p = 0; p < n.length; p++) i = n[p].removeFromSet(i);
  if (o.length == 1 && i.length == 0)
    (u = o[0]), (l = "add"), (c = (p) => p.mark(u.addToSet(p.marks)));
  else if (o.length == 0 && i.length == 1)
    (u = i[0]), (l = "remove"), (c = (p) => p.mark(u.removeFromSet(p.marks)));
  else return null;
  let f = [];
  for (let p = 0; p < e.childCount; p++) f.push(c(e.child(p)));
  if (J.from(f).eq(t)) return { mark: u, type: l };
}
function qN(t, e, n, r, o) {
  if (n - e <= o.pos - r.pos || wh(r, !0, !1) < o.pos) return !1;
  let i = t.resolve(e);
  if (!r.parent.isTextblock) {
    let u = i.nodeAfter;
    return u != null && n == e + u.nodeSize;
  }
  if (i.parentOffset < i.parent.content.size || !i.parent.isTextblock)
    return !1;
  let l = t.resolve(wh(i, !0, !0));
  return !l.parent.isTextblock || l.pos > n || wh(l, !0, !1) < n
    ? !1
    : r.parent.content.cut(r.parentOffset).eq(l.parent.content);
}
function wh(t, e, n) {
  let r = t.depth,
    o = e ? t.end() : t.pos;
  for (; r > 0 && (e || t.indexAfter(r) == t.node(r).childCount); )
    r--, o++, (e = !1);
  if (n) {
    let i = t.node(r).maybeChild(t.indexAfter(r));
    for (; i && !i.isLeaf; ) (i = i.firstChild), o++;
  }
  return o;
}
function GN(t, e, n, r, o) {
  let i = t.findDiffStart(e, n);
  if (i == null) return null;
  let { a: l, b: u } = t.findDiffEnd(e, n + t.size, n + e.size);
  if (o == "end") {
    let c = Math.max(0, i - Math.min(l, u));
    r -= l + c - i;
  }
  if (l < i && t.size < e.size) {
    let c = r <= i && r >= l ? i - r : 0;
    (i -= c),
      i && i < e.size && fw(e.textBetween(i - 1, i + 1)) && (i += c ? 1 : -1),
      (u = i + (u - l)),
      (l = i);
  } else if (u < i) {
    let c = r <= i && r >= u ? i - r : 0;
    (i -= c),
      i && i < t.size && fw(t.textBetween(i - 1, i + 1)) && (i += c ? 1 : -1),
      (l = i + (l - u)),
      (u = i);
  }
  return { start: i, endA: l, endB: u };
}
function fw(t) {
  if (t.length != 2) return !1;
  let e = t.charCodeAt(0),
    n = t.charCodeAt(1);
  return e >= 56320 && e <= 57343 && n >= 55296 && n <= 56319;
}
class JN {
  constructor(e, n) {
    (this._root = null),
      (this.focused = !1),
      (this.trackWrites = null),
      (this.mounted = !1),
      (this.markCursor = null),
      (this.cursorWrapper = null),
      (this.lastSelectedViewDesc = void 0),
      (this.input = new hN()),
      (this.prevDirectPlugins = []),
      (this.pluginViews = []),
      (this.requiresGeckoHackNode = !1),
      (this.dragging = null),
      (this._props = n),
      (this.state = n.state),
      (this.directPlugins = n.plugins || []),
      this.directPlugins.forEach(yw),
      (this.dispatch = this.dispatch.bind(this)),
      (this.dom = (e && e.mount) || document.createElement("div")),
      e &&
        (e.appendChild
          ? e.appendChild(this.dom)
          : typeof e == "function"
          ? e(this.dom)
          : e.mount && (this.mounted = !0)),
      (this.editable = mw(this)),
      hw(this),
      (this.nodeViews = gw(this)),
      (this.docView = q1(this.state.doc, pw(this), vh(this), this.dom, this)),
      (this.domObserver = new FN(this, (r, o, i, l) => UN(this, r, o, i, l))),
      this.domObserver.start(),
      mN(this),
      this.updatePluginViews();
  }
  get composing() {
    return this.input.composing;
  }
  get props() {
    if (this._props.state != this.state) {
      let e = this._props;
      this._props = {};
      for (let n in e) this._props[n] = e[n];
      this._props.state = this.state;
    }
    return this._props;
  }
  update(e) {
    e.handleDOMEvents != this._props.handleDOMEvents && wm(this);
    let n = this._props;
    (this._props = e),
      e.plugins && (e.plugins.forEach(yw), (this.directPlugins = e.plugins)),
      this.updateStateInner(e.state, n);
  }
  setProps(e) {
    let n = {};
    for (let r in this._props) n[r] = this._props[r];
    n.state = this.state;
    for (let r in e) n[r] = e[r];
    this.update(n);
  }
  updateState(e) {
    this.updateStateInner(e, this._props);
  }
  updateStateInner(e, n) {
    var r;
    let o = this.state,
      i = !1,
      l = !1;
    e.storedMarks && this.composing && (oS(this), (l = !0)), (this.state = e);
    let u = o.plugins != e.plugins || this._props.plugins != n.plugins;
    if (
      u ||
      this._props.plugins != n.plugins ||
      this._props.nodeViews != n.nodeViews
    ) {
      let v = gw(this);
      YN(v, this.nodeViews) && ((this.nodeViews = v), (i = !0));
    }
    (u || n.handleDOMEvents != this._props.handleDOMEvents) && wm(this),
      (this.editable = mw(this)),
      hw(this);
    let c = vh(this),
      f = pw(this),
      p =
        o.plugins != e.plugins && !o.doc.eq(e.doc)
          ? "reset"
          : e.scrollToSelection > o.scrollToSelection
          ? "to selection"
          : "preserve",
      m = i || !this.docView.matchesNode(e.doc, f, c);
    (m || !e.selection.eq(o.selection)) && (l = !0);
    let y =
      p == "preserve" && l && this.dom.style.overflowAnchor == null && NT(this);
    if (l) {
      this.domObserver.stop();
      let v =
        m &&
        (tn || It) &&
        !this.composing &&
        !o.selection.empty &&
        !e.selection.empty &&
        QN(o.selection, e.selection);
      if (m) {
        let x = It
          ? (this.trackWrites = this.domSelectionRange().focusNode)
          : null;
        this.composing && (this.input.compositionNode = TN(this)),
          (i || !this.docView.update(e.doc, f, c, this)) &&
            (this.docView.updateOuterDeco(f),
            this.docView.destroy(),
            (this.docView = q1(e.doc, f, c, this.dom, this))),
          x && !this.trackWrites && (v = !0);
      }
      v ||
      !(
        this.input.mouseDown &&
        this.domObserver.currentSelection.eq(this.domSelectionRange()) &&
        ZT(this)
      )
        ? Ur(this, v)
        : (Kb(this, e.selection), this.domObserver.setCurSelection()),
        this.domObserver.start();
    }
    this.updatePluginViews(o),
      !((r = this.dragging) === null || r === void 0) &&
        r.node &&
        !o.doc.eq(e.doc) &&
        this.updateDraggedNode(this.dragging, o),
      p == "reset"
        ? (this.dom.scrollTop = 0)
        : p == "to selection"
        ? this.scrollToSelection()
        : y && AT(y);
  }
  scrollToSelection() {
    let e = this.domSelectionRange().focusNode;
    if (!(!e || !this.dom.contains(e.nodeType == 1 ? e : e.parentNode))) {
      if (!this.someProp("handleScrollToSelection", (n) => n(this)))
        if (this.state.selection instanceof ke) {
          let n = this.docView.domAfterPos(this.state.selection.from);
          n.nodeType == 1 && B1(this, n.getBoundingClientRect(), e);
        } else B1(this, this.coordsAtPos(this.state.selection.head, 1), e);
    }
  }
  destroyPluginViews() {
    let e;
    for (; (e = this.pluginViews.pop()); ) e.destroy && e.destroy();
  }
  updatePluginViews(e) {
    if (
      !e ||
      e.plugins != this.state.plugins ||
      this.directPlugins != this.prevDirectPlugins
    ) {
      (this.prevDirectPlugins = this.directPlugins), this.destroyPluginViews();
      for (let n = 0; n < this.directPlugins.length; n++) {
        let r = this.directPlugins[n];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
      for (let n = 0; n < this.state.plugins.length; n++) {
        let r = this.state.plugins[n];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
    } else
      for (let n = 0; n < this.pluginViews.length; n++) {
        let r = this.pluginViews[n];
        r.update && r.update(this, e);
      }
  }
  updateDraggedNode(e, n) {
    let r = e.node,
      o = -1;
    if (this.state.doc.nodeAt(r.from) == r.node) o = r.from;
    else {
      let i = r.from + (this.state.doc.content.size - n.doc.content.size);
      (i > 0 && this.state.doc.nodeAt(i)) == r.node && (o = i);
    }
    this.dragging = new sS(
      e.slice,
      e.move,
      o < 0 ? void 0 : ke.create(this.state.doc, o)
    );
  }
  someProp(e, n) {
    let r = this._props && this._props[e],
      o;
    if (r != null && (o = n ? n(r) : r)) return o;
    for (let l = 0; l < this.directPlugins.length; l++) {
      let u = this.directPlugins[l].props[e];
      if (u != null && (o = n ? n(u) : u)) return o;
    }
    let i = this.state.plugins;
    if (i)
      for (let l = 0; l < i.length; l++) {
        let u = i[l].props[e];
        if (u != null && (o = n ? n(u) : u)) return o;
      }
  }
  hasFocus() {
    if (tn) {
      let e = this.root.activeElement;
      if (e == this.dom) return !0;
      if (!e || !this.dom.contains(e)) return !1;
      for (; e && this.dom != e && this.dom.contains(e); ) {
        if (e.contentEditable == "false") return !1;
        e = e.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  focus() {
    this.domObserver.stop(),
      this.editable && RT(this.dom),
      Ur(this),
      this.domObserver.start();
  }
  get root() {
    let e = this._root;
    if (e == null) {
      for (let n = this.dom.parentNode; n; n = n.parentNode)
        if (n.nodeType == 9 || (n.nodeType == 11 && n.host))
          return (
            n.getSelection ||
              (Object.getPrototypeOf(n).getSelection = () =>
                n.ownerDocument.getSelection()),
            (this._root = n)
          );
    }
    return e || document;
  }
  updateRoot() {
    this._root = null;
  }
  posAtCoords(e) {
    return $T(this, e);
  }
  coordsAtPos(e, n = 1) {
    return Fb(this, e, n);
  }
  domAtPos(e, n = 0) {
    return this.docView.domFromPos(e, n);
  }
  nodeDOM(e) {
    let n = this.docView.descAt(e);
    return n ? n.nodeDOM : null;
  }
  posAtDOM(e, n, r = -1) {
    let o = this.docView.posFromDOM(e, n, r);
    if (o == null) throw new RangeError("DOM position not inside the editor");
    return o;
  }
  endOfTextblock(e, n) {
    return BT(this, n || this.state, e);
  }
  pasteHTML(e, n) {
    return ba(this, "", e, !1, n || new ClipboardEvent("paste"));
  }
  pasteText(e, n) {
    return ba(this, e, null, !0, n || new ClipboardEvent("paste"));
  }
  serializeForClipboard(e) {
    return ug(this, e);
  }
  destroy() {
    this.docView &&
      (gN(this),
      this.destroyPluginViews(),
      this.mounted
        ? (this.docView.update(this.state.doc, [], vh(this), this),
          (this.dom.textContent = ""))
        : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom),
      this.docView.destroy(),
      (this.docView = null),
      vT());
  }
  get isDestroyed() {
    return this.docView == null;
  }
  dispatchEvent(e) {
    return vN(this, e);
  }
  dispatch(e) {
    let n = this._props.dispatchTransaction;
    n ? n.call(this, e) : this.updateState(this.state.apply(e));
  }
  domSelectionRange() {
    let e = this.domSelection();
    return e
      ? (jt &&
          this.root.nodeType === 11 &&
          CT(this.dom.ownerDocument) == this.dom &&
          jN(this, e)) ||
          e
      : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
  }
  domSelection() {
    return this.root.getSelection();
  }
}
function pw(t) {
  let e = Object.create(null);
  return (
    (e.class = "ProseMirror"),
    (e.contenteditable = String(t.editable)),
    t.someProp("attributes", (n) => {
      if ((typeof n == "function" && (n = n(t.state)), n))
        for (let r in n)
          r == "class"
            ? (e.class += " " + n[r])
            : r == "style"
            ? (e.style = (e.style ? e.style + ";" : "") + n[r])
            : !e[r] &&
              r != "contenteditable" &&
              r != "nodeName" &&
              (e[r] = String(n[r]));
    }),
    e.translate || (e.translate = "no"),
    [Tn.node(0, t.state.doc.content.size, e)]
  );
}
function hw(t) {
  if (t.markCursor) {
    let e = document.createElement("img");
    (e.className = "ProseMirror-separator"),
      e.setAttribute("mark-placeholder", "true"),
      e.setAttribute("alt", ""),
      (t.cursorWrapper = {
        dom: e,
        deco: Tn.widget(t.state.selection.from, e, {
          raw: !0,
          marks: t.markCursor,
        }),
      });
  } else t.cursorWrapper = null;
}
function mw(t) {
  return !t.someProp("editable", (e) => e(t.state) === !1);
}
function QN(t, e) {
  let n = Math.min(
    t.$anchor.sharedDepth(t.head),
    e.$anchor.sharedDepth(e.head)
  );
  return t.$anchor.start(n) != e.$anchor.start(n);
}
function gw(t) {
  let e = Object.create(null);
  function n(r) {
    for (let o in r)
      Object.prototype.hasOwnProperty.call(e, o) || (e[o] = r[o]);
  }
  return t.someProp("nodeViews", n), t.someProp("markViews", n), e;
}
function YN(t, e) {
  let n = 0,
    r = 0;
  for (let o in t) {
    if (t[o] != e[o]) return !0;
    n++;
  }
  for (let o in e) r++;
  return n != r;
}
function yw(t) {
  if (t.spec.state || t.spec.filterTransaction || t.spec.appendTransaction)
    throw new RangeError(
      "Plugins passed directly to the view must not have a state component"
    );
}
var Bo = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'",
  },
  Gc = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"',
  },
  XN = typeof navigator < "u" && /Mac/.test(navigator.platform),
  ZN =
    typeof navigator < "u" &&
    /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var Et = 0; Et < 10; Et++) Bo[48 + Et] = Bo[96 + Et] = String(Et);
for (var Et = 1; Et <= 24; Et++) Bo[Et + 111] = "F" + Et;
for (var Et = 65; Et <= 90; Et++)
  (Bo[Et] = String.fromCharCode(Et + 32)), (Gc[Et] = String.fromCharCode(Et));
for (var xh in Bo) Gc.hasOwnProperty(xh) || (Gc[xh] = Bo[xh]);
function eA(t) {
  var e =
      (XN && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey) ||
      (ZN && t.shiftKey && t.key && t.key.length == 1) ||
      t.key == "Unidentified",
    n =
      (!e && t.key) ||
      (t.shiftKey ? Gc : Bo)[t.keyCode] ||
      t.key ||
      "Unidentified";
  return (
    n == "Esc" && (n = "Escape"),
    n == "Del" && (n = "Delete"),
    n == "Left" && (n = "ArrowLeft"),
    n == "Up" && (n = "ArrowUp"),
    n == "Right" && (n = "ArrowRight"),
    n == "Down" && (n = "ArrowDown"),
    n
  );
}
const tA =
  typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1;
function nA(t) {
  let e = t.split(/-(?!$)/),
    n = e[e.length - 1];
  n == "Space" && (n = " ");
  let r, o, i, l;
  for (let u = 0; u < e.length - 1; u++) {
    let c = e[u];
    if (/^(cmd|meta|m)$/i.test(c)) l = !0;
    else if (/^a(lt)?$/i.test(c)) r = !0;
    else if (/^(c|ctrl|control)$/i.test(c)) o = !0;
    else if (/^s(hift)?$/i.test(c)) i = !0;
    else if (/^mod$/i.test(c)) tA ? (l = !0) : (o = !0);
    else throw new Error("Unrecognized modifier name: " + c);
  }
  return (
    r && (n = "Alt-" + n),
    o && (n = "Ctrl-" + n),
    l && (n = "Meta-" + n),
    i && (n = "Shift-" + n),
    n
  );
}
function rA(t) {
  let e = Object.create(null);
  for (let n in t) e[nA(n)] = t[n];
  return e;
}
function bh(t, e, n = !0) {
  return (
    e.altKey && (t = "Alt-" + t),
    e.ctrlKey && (t = "Ctrl-" + t),
    e.metaKey && (t = "Meta-" + t),
    n && e.shiftKey && (t = "Shift-" + t),
    t
  );
}
function oA(t) {
  return new pt({ props: { handleKeyDown: dS(t) } });
}
function dS(t) {
  let e = rA(t);
  return function (n, r) {
    let o = eA(r),
      i,
      l = e[bh(o, r)];
    if (l && l(n.state, n.dispatch, n)) return !0;
    if (o.length == 1 && o != " ") {
      if (r.shiftKey) {
        let u = e[bh(o, r, !1)];
        if (u && u(n.state, n.dispatch, n)) return !0;
      }
      if (
        (r.shiftKey || r.altKey || r.metaKey || o.charCodeAt(0) > 127) &&
        (i = Bo[r.keyCode]) &&
        i != o
      ) {
        let u = e[bh(i, r)];
        if (u && u(n.state, n.dispatch, n)) return !0;
      }
    }
    return !1;
  };
}
const iA = (t, e) =>
  t.selection.empty
    ? !1
    : (e && e(t.tr.deleteSelection().scrollIntoView()), !0);
function fS(t, e) {
  let { $cursor: n } = t.selection;
  return !n || (e ? !e.endOfTextblock("backward", t) : n.parentOffset > 0)
    ? null
    : n;
}
const sA = (t, e, n) => {
    let r = fS(t, n);
    if (!r) return !1;
    let o = mg(r);
    if (!o) {
      let l = r.blockRange(),
        u = l && tl(l);
      return u == null ? !1 : (e && e(t.tr.lift(l, u).scrollIntoView()), !0);
    }
    let i = o.nodeBefore;
    if (gS(t, o, e, -1)) return !0;
    if (r.parent.content.size == 0 && (Ks(i, "end") || ke.isSelectable(i)))
      for (let l = r.depth; ; l--) {
        let u = jd(t.doc, r.before(l), r.after(l), ae.empty);
        if (u && u.slice.size < u.to - u.from) {
          if (e) {
            let c = t.tr.step(u);
            c.setSelection(
              Ks(i, "end")
                ? Ae.findFrom(c.doc.resolve(c.mapping.map(o.pos, -1)), -1)
                : ke.create(c.doc, o.pos - i.nodeSize)
            ),
              e(c.scrollIntoView());
          }
          return !0;
        }
        if (l == 1 || r.node(l - 1).childCount > 1) break;
      }
    return i.isAtom && o.depth == r.depth - 1
      ? (e && e(t.tr.delete(o.pos - i.nodeSize, o.pos).scrollIntoView()), !0)
      : !1;
  },
  lA = (t, e, n) => {
    let r = fS(t, n);
    if (!r) return !1;
    let o = mg(r);
    return o ? pS(t, o, e) : !1;
  },
  aA = (t, e, n) => {
    let r = hS(t, n);
    if (!r) return !1;
    let o = gg(r);
    return o ? pS(t, o, e) : !1;
  };
function pS(t, e, n) {
  let r = e.nodeBefore,
    o = r,
    i = e.pos - 1;
  for (; !o.isTextblock; i--) {
    if (o.type.spec.isolating) return !1;
    let p = o.lastChild;
    if (!p) return !1;
    o = p;
  }
  let l = e.nodeAfter,
    u = l,
    c = e.pos + 1;
  for (; !u.isTextblock; c++) {
    if (u.type.spec.isolating) return !1;
    let p = u.firstChild;
    if (!p) return !1;
    u = p;
  }
  let f = jd(t.doc, i, c, ae.empty);
  if (!f || f.from != i || (f instanceof yt && f.slice.size >= c - i))
    return !1;
  if (n) {
    let p = t.tr.step(f);
    p.setSelection(Te.create(p.doc, i)), n(p.scrollIntoView());
  }
  return !0;
}
function Ks(t, e, n = !1) {
  for (let r = t; r; r = e == "start" ? r.firstChild : r.lastChild) {
    if (r.isTextblock) return !0;
    if (n && r.childCount != 1) return !1;
  }
  return !1;
}
const uA = (t, e, n) => {
  let { $head: r, empty: o } = t.selection,
    i = r;
  if (!o) return !1;
  if (r.parent.isTextblock) {
    if (n ? !n.endOfTextblock("backward", t) : r.parentOffset > 0) return !1;
    i = mg(r);
  }
  let l = i && i.nodeBefore;
  return !l || !ke.isSelectable(l)
    ? !1
    : (e &&
        e(
          t.tr
            .setSelection(ke.create(t.doc, i.pos - l.nodeSize))
            .scrollIntoView()
        ),
      !0);
};
function mg(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      if (t.index(e) > 0) return t.doc.resolve(t.before(e + 1));
      if (t.node(e).type.spec.isolating) break;
    }
  return null;
}
function hS(t, e) {
  let { $cursor: n } = t.selection;
  return !n ||
    (e
      ? !e.endOfTextblock("forward", t)
      : n.parentOffset < n.parent.content.size)
    ? null
    : n;
}
const cA = (t, e, n) => {
    let r = hS(t, n);
    if (!r) return !1;
    let o = gg(r);
    if (!o) return !1;
    let i = o.nodeAfter;
    if (gS(t, o, e, 1)) return !0;
    if (r.parent.content.size == 0 && (Ks(i, "start") || ke.isSelectable(i))) {
      let l = jd(t.doc, r.before(), r.after(), ae.empty);
      if (l && l.slice.size < l.to - l.from) {
        if (e) {
          let u = t.tr.step(l);
          u.setSelection(
            Ks(i, "start")
              ? Ae.findFrom(u.doc.resolve(u.mapping.map(o.pos)), 1)
              : ke.create(u.doc, u.mapping.map(o.pos))
          ),
            e(u.scrollIntoView());
        }
        return !0;
      }
    }
    return i.isAtom && o.depth == r.depth - 1
      ? (e && e(t.tr.delete(o.pos, o.pos + i.nodeSize).scrollIntoView()), !0)
      : !1;
  },
  dA = (t, e, n) => {
    let { $head: r, empty: o } = t.selection,
      i = r;
    if (!o) return !1;
    if (r.parent.isTextblock) {
      if (
        n
          ? !n.endOfTextblock("forward", t)
          : r.parentOffset < r.parent.content.size
      )
        return !1;
      i = gg(r);
    }
    let l = i && i.nodeAfter;
    return !l || !ke.isSelectable(l)
      ? !1
      : (e && e(t.tr.setSelection(ke.create(t.doc, i.pos)).scrollIntoView()),
        !0);
  };
function gg(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      let n = t.node(e);
      if (t.index(e) + 1 < n.childCount) return t.doc.resolve(t.after(e + 1));
      if (n.type.spec.isolating) break;
    }
  return null;
}
const fA = (t, e) => {
    let n = t.selection,
      r = n instanceof ke,
      o;
    if (r) {
      if (n.node.isTextblock || !Ko(t.doc, n.from)) return !1;
      o = n.from;
    } else if (((o = zd(t.doc, n.from, -1)), o == null)) return !1;
    if (e) {
      let i = t.tr.join(o);
      r &&
        i.setSelection(
          ke.create(i.doc, o - t.doc.resolve(o).nodeBefore.nodeSize)
        ),
        e(i.scrollIntoView());
    }
    return !0;
  },
  pA = (t, e) => {
    let n = t.selection,
      r;
    if (n instanceof ke) {
      if (n.node.isTextblock || !Ko(t.doc, n.to)) return !1;
      r = n.to;
    } else if (((r = zd(t.doc, n.to, 1)), r == null)) return !1;
    return e && e(t.tr.join(r).scrollIntoView()), !0;
  },
  hA = (t, e) => {
    let { $from: n, $to: r } = t.selection,
      o = n.blockRange(r),
      i = o && tl(o);
    return i == null ? !1 : (e && e(t.tr.lift(o, i).scrollIntoView()), !0);
  },
  mA = (t, e) => {
    let { $head: n, $anchor: r } = t.selection;
    return !n.parent.type.spec.code || !n.sameParent(r)
      ? !1
      : (e &&
          e(
            t.tr
              .insertText(
                `
`
              )
              .scrollIntoView()
          ),
        !0);
  };
function mS(t) {
  for (let e = 0; e < t.edgeCount; e++) {
    let { type: n } = t.edge(e);
    if (n.isTextblock && !n.hasRequiredAttrs()) return n;
  }
  return null;
}
const gA = (t, e) => {
    let { $head: n, $anchor: r } = t.selection;
    if (!n.parent.type.spec.code || !n.sameParent(r)) return !1;
    let o = n.node(-1),
      i = n.indexAfter(-1),
      l = mS(o.contentMatchAt(i));
    if (!l || !o.canReplaceWith(i, i, l)) return !1;
    if (e) {
      let u = n.after(),
        c = t.tr.replaceWith(u, u, l.createAndFill());
      c.setSelection(Ae.near(c.doc.resolve(u), 1)), e(c.scrollIntoView());
    }
    return !0;
  },
  yA = (t, e) => {
    let n = t.selection,
      { $from: r, $to: o } = n;
    if (n instanceof Nn || r.parent.inlineContent || o.parent.inlineContent)
      return !1;
    let i = mS(o.parent.contentMatchAt(o.indexAfter()));
    if (!i || !i.isTextblock) return !1;
    if (e) {
      let l = (!r.parentOffset && o.index() < o.parent.childCount ? r : o).pos,
        u = t.tr.insert(l, i.createAndFill());
      u.setSelection(Te.create(u.doc, l + 1)), e(u.scrollIntoView());
    }
    return !0;
  },
  vA = (t, e) => {
    let { $cursor: n } = t.selection;
    if (!n || n.parent.content.size) return !1;
    if (n.depth > 1 && n.after() != n.end(-1)) {
      let i = n.before();
      if (Ls(t.doc, i)) return e && e(t.tr.split(i).scrollIntoView()), !0;
    }
    let r = n.blockRange(),
      o = r && tl(r);
    return o == null ? !1 : (e && e(t.tr.lift(r, o).scrollIntoView()), !0);
  },
  wA = (t, e) => {
    let { $from: n, to: r } = t.selection,
      o,
      i = n.sharedDepth(r);
    return i == 0
      ? !1
      : ((o = n.before(i)), e && e(t.tr.setSelection(ke.create(t.doc, o))), !0);
  };
function xA(t, e, n) {
  let r = e.nodeBefore,
    o = e.nodeAfter,
    i = e.index();
  return !r || !o || !r.type.compatibleContent(o.type)
    ? !1
    : !r.content.size && e.parent.canReplace(i - 1, i)
    ? (n && n(t.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), !0)
    : !e.parent.canReplace(i, i + 1) || !(o.isTextblock || Ko(t.doc, e.pos))
    ? !1
    : (n && n(t.tr.join(e.pos).scrollIntoView()), !0);
}
function gS(t, e, n, r) {
  let o = e.nodeBefore,
    i = e.nodeAfter,
    l,
    u,
    c = o.type.spec.isolating || i.type.spec.isolating;
  if (!c && xA(t, e, n)) return !0;
  let f = !c && e.parent.canReplace(e.index(), e.index() + 1);
  if (
    f &&
    (l = (u = o.contentMatchAt(o.childCount)).findWrapping(i.type)) &&
    u.matchType(l[0] || i.type).validEnd
  ) {
    if (n) {
      let v = e.pos + i.nodeSize,
        x = J.empty;
      for (let E = l.length - 1; E >= 0; E--) x = J.from(l[E].create(null, x));
      x = J.from(o.copy(x));
      let S = t.tr.step(
          new vt(e.pos - 1, v, e.pos, v, new ae(x, 1, 0), l.length, !0)
        ),
        C = S.doc.resolve(v + 2 * l.length);
      C.nodeAfter &&
        C.nodeAfter.type == o.type &&
        Ko(S.doc, C.pos) &&
        S.join(C.pos),
        n(S.scrollIntoView());
    }
    return !0;
  }
  let p = i.type.spec.isolating || (r > 0 && c) ? null : Ae.findFrom(e, 1),
    m = p && p.$from.blockRange(p.$to),
    y = m && tl(m);
  if (y != null && y >= e.depth)
    return n && n(t.tr.lift(m, y).scrollIntoView()), !0;
  if (f && Ks(i, "start", !0) && Ks(o, "end")) {
    let v = o,
      x = [];
    for (; x.push(v), !v.isTextblock; ) v = v.lastChild;
    let S = i,
      C = 1;
    for (; !S.isTextblock; S = S.firstChild) C++;
    if (v.canReplace(v.childCount, v.childCount, S.content)) {
      if (n) {
        let E = J.empty;
        for (let $ = x.length - 1; $ >= 0; $--) E = J.from(x[$].copy(E));
        let N = t.tr.step(
          new vt(
            e.pos - x.length,
            e.pos + i.nodeSize,
            e.pos + C,
            e.pos + i.nodeSize - C,
            new ae(E, x.length, 0),
            0,
            !0
          )
        );
        n(N.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function yS(t) {
  return function (e, n) {
    let r = e.selection,
      o = t < 0 ? r.$from : r.$to,
      i = o.depth;
    for (; o.node(i).isInline; ) {
      if (!i) return !1;
      i--;
    }
    return o.node(i).isTextblock
      ? (n &&
          n(e.tr.setSelection(Te.create(e.doc, t < 0 ? o.start(i) : o.end(i)))),
        !0)
      : !1;
  };
}
const bA = yS(-1),
  SA = yS(1);
function CA(t, e = null) {
  return function (n, r) {
    let { $from: o, $to: i } = n.selection,
      l = o.blockRange(i),
      u = l && og(l, t, e);
    return u ? (r && r(n.tr.wrap(l, u).scrollIntoView()), !0) : !1;
  };
}
function vw(t, e = null) {
  return function (n, r) {
    let o = !1;
    for (let i = 0; i < n.selection.ranges.length && !o; i++) {
      let {
        $from: { pos: l },
        $to: { pos: u },
      } = n.selection.ranges[i];
      n.doc.nodesBetween(l, u, (c, f) => {
        if (o) return !1;
        if (!(!c.isTextblock || c.hasMarkup(t, e)))
          if (c.type == t) o = !0;
          else {
            let p = n.doc.resolve(f),
              m = p.index();
            o = p.parent.canReplaceWith(m, m + 1, t);
          }
      });
    }
    if (!o) return !1;
    if (r) {
      let i = n.tr;
      for (let l = 0; l < n.selection.ranges.length; l++) {
        let {
          $from: { pos: u },
          $to: { pos: c },
        } = n.selection.ranges[l];
        i.setBlockType(u, c, t, e);
      }
      r(i.scrollIntoView());
    }
    return !0;
  };
}
typeof navigator < "u"
  ? /Mac|iP(hone|[oa]d)/.test(navigator.platform)
  : typeof os < "u" && os.platform && os.platform() == "darwin";
function kA(t, e = null) {
  return function (n, r) {
    let { $from: o, $to: i } = n.selection,
      l = o.blockRange(i);
    if (!l) return !1;
    let u = r ? n.tr : null;
    return EA(u, l, t, e) ? (r && r(u.scrollIntoView()), !0) : !1;
  };
}
function EA(t, e, n, r = null) {
  let o = !1,
    i = e,
    l = e.$from.doc;
  if (
    e.depth >= 2 &&
    e.$from.node(e.depth - 1).type.compatibleContent(n) &&
    e.startIndex == 0
  ) {
    if (e.$from.index(e.depth - 1) == 0) return !1;
    let c = l.resolve(e.start - 2);
    (i = new Bc(c, c, e.depth)),
      e.endIndex < e.parent.childCount &&
        (e = new Bc(e.$from, l.resolve(e.$to.end(e.depth)), e.depth)),
      (o = !0);
  }
  let u = og(i, n, r, e);
  return u ? (t && MA(t, e, u, o, n), !0) : !1;
}
function MA(t, e, n, r, o) {
  let i = J.empty;
  for (let p = n.length - 1; p >= 0; p--)
    i = J.from(n[p].type.create(n[p].attrs, i));
  t.step(
    new vt(
      e.start - (r ? 2 : 0),
      e.end,
      e.start,
      e.end,
      new ae(i, 0, 0),
      n.length,
      !0
    )
  );
  let l = 0;
  for (let p = 0; p < n.length; p++) n[p].type == o && (l = p + 1);
  let u = n.length - l,
    c = e.start + n.length - (r ? 2 : 0),
    f = e.parent;
  for (let p = e.startIndex, m = e.endIndex, y = !0; p < m; p++, y = !1)
    !y && Ls(t.doc, c, u) && (t.split(c, u), (c += 2 * u)),
      (c += f.child(p).nodeSize);
  return t;
}
function OA(t) {
  return function (e, n) {
    let { $from: r, $to: o } = e.selection,
      i = r.blockRange(o, (l) => l.childCount > 0 && l.firstChild.type == t);
    return i
      ? n
        ? r.node(i.depth - 1).type == t
          ? TA(e, n, t, i)
          : NA(e, n, i)
        : !0
      : !1;
  };
}
function TA(t, e, n, r) {
  let o = t.tr,
    i = r.end,
    l = r.$to.end(r.depth);
  i < l &&
    (o.step(
      new vt(
        i - 1,
        l,
        i,
        l,
        new ae(J.from(n.create(null, r.parent.copy())), 1, 0),
        1,
        !0
      )
    ),
    (r = new Bc(o.doc.resolve(r.$from.pos), o.doc.resolve(l), r.depth)));
  const u = tl(r);
  if (u == null) return !1;
  o.lift(r, u);
  let c = o.doc.resolve(o.mapping.map(i, -1) - 1);
  return (
    Ko(o.doc, c.pos) && c.nodeBefore.type == c.nodeAfter.type && o.join(c.pos),
    e(o.scrollIntoView()),
    !0
  );
}
function NA(t, e, n) {
  let r = t.tr,
    o = n.parent;
  for (let v = n.end, x = n.endIndex - 1, S = n.startIndex; x > S; x--)
    (v -= o.child(x).nodeSize), r.delete(v - 1, v + 1);
  let i = r.doc.resolve(n.start),
    l = i.nodeAfter;
  if (r.mapping.map(n.end) != n.start + i.nodeAfter.nodeSize) return !1;
  let u = n.startIndex == 0,
    c = n.endIndex == o.childCount,
    f = i.node(-1),
    p = i.index(-1);
  if (
    !f.canReplace(
      p + (u ? 0 : 1),
      p + 1,
      l.content.append(c ? J.empty : J.from(o))
    )
  )
    return !1;
  let m = i.pos,
    y = m + l.nodeSize;
  return (
    r.step(
      new vt(
        m - (u ? 1 : 0),
        y + (c ? 1 : 0),
        m + 1,
        y - 1,
        new ae(
          (u ? J.empty : J.from(o.copy(J.empty))).append(
            c ? J.empty : J.from(o.copy(J.empty))
          ),
          u ? 0 : 1,
          c ? 0 : 1
        ),
        u ? 0 : 1
      )
    ),
    e(r.scrollIntoView()),
    !0
  );
}
function AA(t) {
  return function (e, n) {
    let { $from: r, $to: o } = e.selection,
      i = r.blockRange(o, (f) => f.childCount > 0 && f.firstChild.type == t);
    if (!i) return !1;
    let l = i.startIndex;
    if (l == 0) return !1;
    let u = i.parent,
      c = u.child(l - 1);
    if (c.type != t) return !1;
    if (n) {
      let f = c.lastChild && c.lastChild.type == u.type,
        p = J.from(f ? t.create() : null),
        m = new ae(
          J.from(t.create(null, J.from(u.type.create(null, p)))),
          f ? 3 : 1,
          0
        ),
        y = i.start,
        v = i.end;
      n(e.tr.step(new vt(y - (f ? 3 : 1), v, y, v, m, 1, !0)).scrollIntoView());
    }
    return !0;
  };
}
function Ud(t) {
  const { state: e, transaction: n } = t;
  let { selection: r } = n,
    { doc: o } = n,
    { storedMarks: i } = n;
  return {
    ...e,
    apply: e.apply.bind(e),
    applyTransaction: e.applyTransaction.bind(e),
    plugins: e.plugins,
    schema: e.schema,
    reconfigure: e.reconfigure.bind(e),
    toJSON: e.toJSON.bind(e),
    get storedMarks() {
      return i;
    },
    get selection() {
      return r;
    },
    get doc() {
      return o;
    },
    get tr() {
      return (r = n.selection), (o = n.doc), (i = n.storedMarks), n;
    },
  };
}
class Kd {
  constructor(e) {
    (this.editor = e.editor),
      (this.rawCommands = this.editor.extensionManager.commands),
      (this.customState = e.state);
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands: e, editor: n, state: r } = this,
      { view: o } = n,
      { tr: i } = r,
      l = this.buildProps(i);
    return Object.fromEntries(
      Object.entries(e).map(([u, c]) => [
        u,
        (...p) => {
          const m = c(...p)(l);
          return (
            !i.getMeta("preventDispatch") &&
              !this.hasCustomState &&
              o.dispatch(i),
            m
          );
        },
      ])
    );
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(e, n = !0) {
    const { rawCommands: r, editor: o, state: i } = this,
      { view: l } = o,
      u = [],
      c = !!e,
      f = e || i.tr,
      p = () => (
        !c &&
          n &&
          !f.getMeta("preventDispatch") &&
          !this.hasCustomState &&
          l.dispatch(f),
        u.every((y) => y === !0)
      ),
      m = {
        ...Object.fromEntries(
          Object.entries(r).map(([y, v]) => [
            y,
            (...S) => {
              const C = this.buildProps(f, n),
                E = v(...S)(C);
              return u.push(E), m;
            },
          ])
        ),
        run: p,
      };
    return m;
  }
  createCan(e) {
    const { rawCommands: n, state: r } = this,
      o = !1,
      i = e || r.tr,
      l = this.buildProps(i, o);
    return {
      ...Object.fromEntries(
        Object.entries(n).map(([c, f]) => [
          c,
          (...p) => f(...p)({ ...l, dispatch: void 0 }),
        ])
      ),
      chain: () => this.createChain(i, o),
    };
  }
  buildProps(e, n = !0) {
    const { rawCommands: r, editor: o, state: i } = this,
      { view: l } = o,
      u = {
        tr: e,
        editor: o,
        view: l,
        state: Ud({ state: i, transaction: e }),
        dispatch: n ? () => {} : void 0,
        chain: () => this.createChain(e, n),
        can: () => this.createCan(e),
        get commands() {
          return Object.fromEntries(
            Object.entries(r).map(([c, f]) => [c, (...p) => f(...p)(u)])
          );
        },
      };
    return u;
  }
}
class RA {
  constructor() {
    this.callbacks = {};
  }
  on(e, n) {
    return (
      this.callbacks[e] || (this.callbacks[e] = []),
      this.callbacks[e].push(n),
      this
    );
  }
  emit(e, ...n) {
    const r = this.callbacks[e];
    return r && r.forEach((o) => o.apply(this, n)), this;
  }
  off(e, n) {
    const r = this.callbacks[e];
    return (
      r &&
        (n
          ? (this.callbacks[e] = r.filter((o) => o !== n))
          : delete this.callbacks[e]),
      this
    );
  }
  once(e, n) {
    const r = (...o) => {
      this.off(e, r), n.apply(this, o);
    };
    return this.on(e, r);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
}
function me(t, e, n) {
  return t.config[e] === void 0 && t.parent
    ? me(t.parent, e, n)
    : typeof t.config[e] == "function"
    ? t.config[e].bind({ ...n, parent: t.parent ? me(t.parent, e, n) : null })
    : t.config[e];
}
function qd(t) {
  const e = t.filter((o) => o.type === "extension"),
    n = t.filter((o) => o.type === "node"),
    r = t.filter((o) => o.type === "mark");
  return { baseExtensions: e, nodeExtensions: n, markExtensions: r };
}
function vS(t) {
  const e = [],
    { nodeExtensions: n, markExtensions: r } = qd(t),
    o = [...n, ...r],
    i = {
      default: null,
      rendered: !0,
      renderHTML: null,
      parseHTML: null,
      keepOnSplit: !0,
      isRequired: !1,
    };
  return (
    t.forEach((l) => {
      const u = {
          name: l.name,
          options: l.options,
          storage: l.storage,
          extensions: o,
        },
        c = me(l, "addGlobalAttributes", u);
      if (!c) return;
      c().forEach((p) => {
        p.types.forEach((m) => {
          Object.entries(p.attributes).forEach(([y, v]) => {
            e.push({ type: m, name: y, attribute: { ...i, ...v } });
          });
        });
      });
    }),
    o.forEach((l) => {
      const u = { name: l.name, options: l.options, storage: l.storage },
        c = me(l, "addAttributes", u);
      if (!c) return;
      const f = c();
      Object.entries(f).forEach(([p, m]) => {
        const y = { ...i, ...m };
        typeof (y == null ? void 0 : y.default) == "function" &&
          (y.default = y.default()),
          y != null &&
            y.isRequired &&
            (y == null ? void 0 : y.default) === void 0 &&
            delete y.default,
          e.push({ type: l.name, name: p, attribute: y });
      });
    }),
    e
  );
}
function xt(t, e) {
  if (typeof t == "string") {
    if (!e.nodes[t])
      throw Error(
        `There is no node type named '${t}'. Maybe you forgot to add the extension?`
      );
    return e.nodes[t];
  }
  return t;
}
function dt(...t) {
  return t
    .filter((e) => !!e)
    .reduce((e, n) => {
      const r = { ...e };
      return (
        Object.entries(n).forEach(([o, i]) => {
          if (!r[o]) {
            r[o] = i;
            return;
          }
          if (o === "class") {
            const u = i ? String(i).split(" ") : [],
              c = r[o] ? r[o].split(" ") : [],
              f = u.filter((p) => !c.includes(p));
            r[o] = [...c, ...f].join(" ");
          } else if (o === "style") {
            const u = i
                ? i
                    .split(";")
                    .map((p) => p.trim())
                    .filter(Boolean)
                : [],
              c = r[o]
                ? r[o]
                    .split(";")
                    .map((p) => p.trim())
                    .filter(Boolean)
                : [],
              f = new Map();
            c.forEach((p) => {
              const [m, y] = p.split(":").map((v) => v.trim());
              f.set(m, y);
            }),
              u.forEach((p) => {
                const [m, y] = p.split(":").map((v) => v.trim());
                f.set(m, y);
              }),
              (r[o] = Array.from(f.entries())
                .map(([p, m]) => `${p}: ${m}`)
                .join("; "));
          } else r[o] = i;
        }),
        r
      );
    }, {});
}
function xm(t, e) {
  return e
    .filter((n) => n.type === t.type.name)
    .filter((n) => n.attribute.rendered)
    .map((n) =>
      n.attribute.renderHTML
        ? n.attribute.renderHTML(t.attrs) || {}
        : { [n.name]: t.attrs[n.name] }
    )
    .reduce((n, r) => dt(n, r), {});
}
function wS(t) {
  return typeof t == "function";
}
function Pe(t, e = void 0, ...n) {
  return wS(t) ? (e ? t.bind(e)(...n) : t(...n)) : t;
}
function PA(t = {}) {
  return Object.keys(t).length === 0 && t.constructor === Object;
}
function DA(t) {
  return typeof t != "string"
    ? t
    : t.match(/^[+-]?(?:\d*\.)?\d+$/)
    ? Number(t)
    : t === "true"
    ? !0
    : t === "false"
    ? !1
    : t;
}
function ww(t, e) {
  return "style" in t
    ? t
    : {
        ...t,
        getAttrs: (n) => {
          const r = t.getAttrs ? t.getAttrs(n) : t.attrs;
          if (r === !1) return !1;
          const o = e.reduce((i, l) => {
            const u = l.attribute.parseHTML
              ? l.attribute.parseHTML(n)
              : DA(n.getAttribute(l.name));
            return u == null ? i : { ...i, [l.name]: u };
          }, {});
          return { ...r, ...o };
        },
      };
}
function xw(t) {
  return Object.fromEntries(
    Object.entries(t).filter(([e, n]) =>
      e === "attrs" && PA(n) ? !1 : n != null
    )
  );
}
function IA(t, e) {
  var n;
  const r = vS(t),
    { nodeExtensions: o, markExtensions: i } = qd(t),
    l =
      (n = o.find((f) => me(f, "topNode"))) === null || n === void 0
        ? void 0
        : n.name,
    u = Object.fromEntries(
      o.map((f) => {
        const p = r.filter((E) => E.type === f.name),
          m = {
            name: f.name,
            options: f.options,
            storage: f.storage,
            editor: e,
          },
          y = t.reduce((E, N) => {
            const $ = me(N, "extendNodeSchema", m);
            return { ...E, ...($ ? $(f) : {}) };
          }, {}),
          v = xw({
            ...y,
            content: Pe(me(f, "content", m)),
            marks: Pe(me(f, "marks", m)),
            group: Pe(me(f, "group", m)),
            inline: Pe(me(f, "inline", m)),
            atom: Pe(me(f, "atom", m)),
            selectable: Pe(me(f, "selectable", m)),
            draggable: Pe(me(f, "draggable", m)),
            code: Pe(me(f, "code", m)),
            whitespace: Pe(me(f, "whitespace", m)),
            linebreakReplacement: Pe(me(f, "linebreakReplacement", m)),
            defining: Pe(me(f, "defining", m)),
            isolating: Pe(me(f, "isolating", m)),
            attrs: Object.fromEntries(
              p.map((E) => {
                var N;
                return [
                  E.name,
                  {
                    default:
                      (N = E == null ? void 0 : E.attribute) === null ||
                      N === void 0
                        ? void 0
                        : N.default,
                  },
                ];
              })
            ),
          }),
          x = Pe(me(f, "parseHTML", m));
        x && (v.parseDOM = x.map((E) => ww(E, p)));
        const S = me(f, "renderHTML", m);
        S && (v.toDOM = (E) => S({ node: E, HTMLAttributes: xm(E, p) }));
        const C = me(f, "renderText", m);
        return C && (v.toText = C), [f.name, v];
      })
    ),
    c = Object.fromEntries(
      i.map((f) => {
        const p = r.filter((C) => C.type === f.name),
          m = {
            name: f.name,
            options: f.options,
            storage: f.storage,
            editor: e,
          },
          y = t.reduce((C, E) => {
            const N = me(E, "extendMarkSchema", m);
            return { ...C, ...(N ? N(f) : {}) };
          }, {}),
          v = xw({
            ...y,
            inclusive: Pe(me(f, "inclusive", m)),
            excludes: Pe(me(f, "excludes", m)),
            group: Pe(me(f, "group", m)),
            spanning: Pe(me(f, "spanning", m)),
            code: Pe(me(f, "code", m)),
            attrs: Object.fromEntries(
              p.map((C) => {
                var E;
                return [
                  C.name,
                  {
                    default:
                      (E = C == null ? void 0 : C.attribute) === null ||
                      E === void 0
                        ? void 0
                        : E.default,
                  },
                ];
              })
            ),
          }),
          x = Pe(me(f, "parseHTML", m));
        x && (v.parseDOM = x.map((C) => ww(C, p)));
        const S = me(f, "renderHTML", m);
        return (
          S && (v.toDOM = (C) => S({ mark: C, HTMLAttributes: xm(C, p) })),
          [f.name, v]
        );
      })
    );
  return new pb({ topNode: l, nodes: u, marks: c });
}
function Sh(t, e) {
  return e.nodes[t] || e.marks[t] || null;
}
function bw(t, e) {
  return Array.isArray(e)
    ? e.some((n) => (typeof n == "string" ? n : n.name) === t.name)
    : e;
}
function yg(t, e) {
  const n = Wi.fromSchema(e).serializeFragment(t),
    o = document.implementation.createHTMLDocument().createElement("div");
  return o.appendChild(n), o.innerHTML;
}
const LA = (t, e = 500) => {
  let n = "";
  const r = t.parentOffset;
  return (
    t.parent.nodesBetween(Math.max(0, r - e), r, (o, i, l, u) => {
      var c, f;
      const p =
        ((f = (c = o.type.spec).toText) === null || f === void 0
          ? void 0
          : f.call(c, { node: o, pos: i, parent: l, index: u })) ||
        o.textContent ||
        "%leaf%";
      n += o.isAtom && !o.isText ? p : p.slice(0, Math.max(0, r - i));
    }),
    n
  );
};
function vg(t) {
  return Object.prototype.toString.call(t) === "[object RegExp]";
}
class Fa {
  constructor(e) {
    (this.find = e.find), (this.handler = e.handler);
  }
}
const $A = (t, e) => {
  if (vg(e)) return e.exec(t);
  const n = e(t);
  if (!n) return null;
  const r = [n.text];
  return (
    (r.index = n.index),
    (r.input = t),
    (r.data = n.data),
    n.replaceWith &&
      (n.text.includes(n.replaceWith) ||
        console.warn(
          '[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'
        ),
      r.push(n.replaceWith)),
    r
  );
};
function ac(t) {
  var e;
  const { editor: n, from: r, to: o, text: i, rules: l, plugin: u } = t,
    { view: c } = n;
  if (c.composing) return !1;
  const f = c.state.doc.resolve(r);
  if (
    f.parent.type.spec.code ||
    (!((e = f.nodeBefore || f.nodeAfter) === null || e === void 0) &&
      e.marks.find((y) => y.type.spec.code))
  )
    return !1;
  let p = !1;
  const m = LA(f) + i;
  return (
    l.forEach((y) => {
      if (p) return;
      const v = $A(m, y.find);
      if (!v) return;
      const x = c.state.tr,
        S = Ud({ state: c.state, transaction: x }),
        C = { from: r - (v[0].length - i.length), to: o },
        { commands: E, chain: N, can: $ } = new Kd({ editor: n, state: S });
      y.handler({
        state: S,
        range: C,
        match: v,
        commands: E,
        chain: N,
        can: $,
      }) === null ||
        !x.steps.length ||
        (x.setMeta(u, { transform: x, from: r, to: o, text: i }),
        c.dispatch(x),
        (p = !0));
    }),
    p
  );
}
function _A(t) {
  const { editor: e, rules: n } = t,
    r = new pt({
      state: {
        init() {
          return null;
        },
        apply(o, i, l) {
          const u = o.getMeta(r);
          if (u) return u;
          const c = o.getMeta("applyInputRules");
          return (
            !!c &&
              setTimeout(() => {
                let { text: p } = c;
                typeof p == "string" ? (p = p) : (p = yg(J.from(p), l.schema));
                const { from: m } = c,
                  y = m + p.length;
                ac({ editor: e, from: m, to: y, text: p, rules: n, plugin: r });
              }),
            o.selectionSet || o.docChanged ? null : i
          );
        },
      },
      props: {
        handleTextInput(o, i, l, u) {
          return ac({
            editor: e,
            from: i,
            to: l,
            text: u,
            rules: n,
            plugin: r,
          });
        },
        handleDOMEvents: {
          compositionend: (o) => (
            setTimeout(() => {
              const { $cursor: i } = o.state.selection;
              i &&
                ac({
                  editor: e,
                  from: i.pos,
                  to: i.pos,
                  text: "",
                  rules: n,
                  plugin: r,
                });
            }),
            !1
          ),
        },
        handleKeyDown(o, i) {
          if (i.key !== "Enter") return !1;
          const { $cursor: l } = o.state.selection;
          return l
            ? ac({
                editor: e,
                from: l.pos,
                to: l.pos,
                text: `
`,
                rules: n,
                plugin: r,
              })
            : !1;
        },
      },
      isInputRules: !0,
    });
  return r;
}
function FA(t) {
  return Object.prototype.toString.call(t).slice(8, -1);
}
function uc(t) {
  return FA(t) !== "Object"
    ? !1
    : t.constructor === Object && Object.getPrototypeOf(t) === Object.prototype;
}
function Gd(t, e) {
  const n = { ...t };
  return (
    uc(t) &&
      uc(e) &&
      Object.keys(e).forEach((r) => {
        uc(e[r]) && uc(t[r]) ? (n[r] = Gd(t[r], e[r])) : (n[r] = e[r]);
      }),
    n
  );
}
class Gn {
  constructor(e = {}) {
    (this.type = "mark"),
      (this.name = "mark"),
      (this.parent = null),
      (this.child = null),
      (this.config = { name: this.name, defaultOptions: {} }),
      (this.config = { ...this.config, ...e }),
      (this.name = this.config.name),
      e.defaultOptions &&
        Object.keys(e.defaultOptions).length > 0 &&
        console.warn(
          `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
        ),
      (this.options = this.config.defaultOptions),
      this.config.addOptions &&
        (this.options = Pe(me(this, "addOptions", { name: this.name }))),
      (this.storage =
        Pe(
          me(this, "addStorage", { name: this.name, options: this.options })
        ) || {});
  }
  static create(e = {}) {
    return new Gn(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => Gd(this.options, e),
    });
    return (n.name = this.name), (n.parent = this.parent), n;
  }
  extend(e = {}) {
    const n = new Gn(e);
    return (
      (n.parent = this),
      (this.child = n),
      (n.name = e.name ? e.name : n.parent.name),
      e.defaultOptions &&
        Object.keys(e.defaultOptions).length > 0 &&
        console.warn(
          `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`
        ),
      (n.options = Pe(me(n, "addOptions", { name: n.name }))),
      (n.storage = Pe(
        me(n, "addStorage", { name: n.name, options: n.options })
      )),
      n
    );
  }
  static handleExit({ editor: e, mark: n }) {
    const { tr: r } = e.state,
      o = e.state.selection.$from;
    if (o.pos === o.end()) {
      const l = o.marks();
      if (!!!l.find((f) => (f == null ? void 0 : f.type.name) === n.name))
        return !1;
      const c = l.find((f) => (f == null ? void 0 : f.type.name) === n.name);
      return (
        c && r.removeStoredMark(c),
        r.insertText(" ", o.pos),
        e.view.dispatch(r),
        !0
      );
    }
    return !1;
  }
}
function zA(t) {
  return typeof t == "number";
}
class jA {
  constructor(e) {
    (this.find = e.find), (this.handler = e.handler);
  }
}
const BA = (t, e, n) => {
  if (vg(e)) return [...t.matchAll(e)];
  const r = e(t, n);
  return r
    ? r.map((o) => {
        const i = [o.text];
        return (
          (i.index = o.index),
          (i.input = t),
          (i.data = o.data),
          o.replaceWith &&
            (o.text.includes(o.replaceWith) ||
              console.warn(
                '[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'
              ),
            i.push(o.replaceWith)),
          i
        );
      })
    : [];
};
function HA(t) {
  const {
      editor: e,
      state: n,
      from: r,
      to: o,
      rule: i,
      pasteEvent: l,
      dropEvent: u,
    } = t,
    { commands: c, chain: f, can: p } = new Kd({ editor: e, state: n }),
    m = [];
  return (
    n.doc.nodesBetween(r, o, (v, x) => {
      if (!v.isTextblock || v.type.spec.code) return;
      const S = Math.max(r, x),
        C = Math.min(o, x + v.content.size),
        E = v.textBetween(S - x, C - x, void 0, "");
      BA(E, i.find, l).forEach(($) => {
        if ($.index === void 0) return;
        const M = S + $.index + 1,
          I = M + $[0].length,
          R = { from: n.tr.mapping.map(M), to: n.tr.mapping.map(I) },
          F = i.handler({
            state: n,
            range: R,
            match: $,
            commands: c,
            chain: f,
            can: p,
            pasteEvent: l,
            dropEvent: u,
          });
        m.push(F);
      });
    }),
    m.every((v) => v !== null)
  );
}
let cc = null;
const VA = (t) => {
  var e;
  const n = new ClipboardEvent("paste", { clipboardData: new DataTransfer() });
  return (
    (e = n.clipboardData) === null || e === void 0 || e.setData("text/html", t),
    n
  );
};
function WA(t) {
  const { editor: e, rules: n } = t;
  let r = null,
    o = !1,
    i = !1,
    l = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null,
    u;
  try {
    u = typeof DragEvent < "u" ? new DragEvent("drop") : null;
  } catch {
    u = null;
  }
  const c = ({ state: p, from: m, to: y, rule: v, pasteEvt: x }) => {
    const S = p.tr,
      C = Ud({ state: p, transaction: S });
    if (
      !(
        !HA({
          editor: e,
          state: C,
          from: Math.max(m - 1, 0),
          to: y.b - 1,
          rule: v,
          pasteEvent: x,
          dropEvent: u,
        }) || !S.steps.length
      )
    ) {
      try {
        u = typeof DragEvent < "u" ? new DragEvent("drop") : null;
      } catch {
        u = null;
      }
      return (
        (l = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null),
        S
      );
    }
  };
  return n.map(
    (p) =>
      new pt({
        view(m) {
          const y = (x) => {
              var S;
              (r =
                !((S = m.dom.parentElement) === null || S === void 0) &&
                S.contains(x.target)
                  ? m.dom.parentElement
                  : null),
                r && (cc = e);
            },
            v = () => {
              cc && (cc = null);
            };
          return (
            window.addEventListener("dragstart", y),
            window.addEventListener("dragend", v),
            {
              destroy() {
                window.removeEventListener("dragstart", y),
                  window.removeEventListener("dragend", v);
              },
            }
          );
        },
        props: {
          handleDOMEvents: {
            drop: (m, y) => {
              if (((i = r === m.dom.parentElement), (u = y), !i)) {
                const v = cc;
                v &&
                  setTimeout(() => {
                    const x = v.state.selection;
                    x && v.commands.deleteRange({ from: x.from, to: x.to });
                  }, 10);
              }
              return !1;
            },
            paste: (m, y) => {
              var v;
              const x =
                (v = y.clipboardData) === null || v === void 0
                  ? void 0
                  : v.getData("text/html");
              return (
                (l = y), (o = !!(x != null && x.includes("data-pm-slice"))), !1
              );
            },
          },
        },
        appendTransaction: (m, y, v) => {
          const x = m[0],
            S = x.getMeta("uiEvent") === "paste" && !o,
            C = x.getMeta("uiEvent") === "drop" && !i,
            E = x.getMeta("applyPasteRules"),
            N = !!E;
          if (!S && !C && !N) return;
          if (N) {
            let { text: I } = E;
            typeof I == "string" ? (I = I) : (I = yg(J.from(I), v.schema));
            const { from: R } = E,
              F = R + I.length,
              H = VA(I);
            return c({ rule: p, state: v, from: R, to: { b: F }, pasteEvt: H });
          }
          const $ = y.doc.content.findDiffStart(v.doc.content),
            M = y.doc.content.findDiffEnd(v.doc.content);
          if (!(!zA($) || !M || $ === M.b))
            return c({ rule: p, state: v, from: $, to: M, pasteEvt: l });
        },
      })
  );
}
function UA(t) {
  const e = t.filter((n, r) => t.indexOf(n) !== r);
  return Array.from(new Set(e));
}
class Is {
  constructor(e, n) {
    (this.splittableMarks = []),
      (this.editor = n),
      (this.extensions = Is.resolve(e)),
      (this.schema = IA(this.extensions, n)),
      this.setupExtensions();
  }
  static resolve(e) {
    const n = Is.sort(Is.flatten(e)),
      r = UA(n.map((o) => o.name));
    return (
      r.length &&
        console.warn(
          `[tiptap warn]: Duplicate extension names found: [${r
            .map((o) => `'${o}'`)
            .join(", ")}]. This can lead to issues.`
        ),
      n
    );
  }
  static flatten(e) {
    return e
      .map((n) => {
        const r = { name: n.name, options: n.options, storage: n.storage },
          o = me(n, "addExtensions", r);
        return o ? [n, ...this.flatten(o())] : n;
      })
      .flat(10);
  }
  static sort(e) {
    return e.sort((r, o) => {
      const i = me(r, "priority") || 100,
        l = me(o, "priority") || 100;
      return i > l ? -1 : i < l ? 1 : 0;
    });
  }
  get commands() {
    return this.extensions.reduce((e, n) => {
      const r = {
          name: n.name,
          options: n.options,
          storage: n.storage,
          editor: this.editor,
          type: Sh(n.name, this.schema),
        },
        o = me(n, "addCommands", r);
      return o ? { ...e, ...o() } : e;
    }, {});
  }
  get plugins() {
    const { editor: e } = this,
      n = Is.sort([...this.extensions].reverse()),
      r = [],
      o = [],
      i = n
        .map((l) => {
          const u = {
              name: l.name,
              options: l.options,
              storage: l.storage,
              editor: e,
              type: Sh(l.name, this.schema),
            },
            c = [],
            f = me(l, "addKeyboardShortcuts", u);
          let p = {};
          if (
            (l.type === "mark" &&
              me(l, "exitable", u) &&
              (p.ArrowRight = () => Gn.handleExit({ editor: e, mark: l })),
            f)
          ) {
            const S = Object.fromEntries(
              Object.entries(f()).map(([C, E]) => [C, () => E({ editor: e })])
            );
            p = { ...p, ...S };
          }
          const m = oA(p);
          c.push(m);
          const y = me(l, "addInputRules", u);
          bw(l, e.options.enableInputRules) && y && r.push(...y());
          const v = me(l, "addPasteRules", u);
          bw(l, e.options.enablePasteRules) && v && o.push(...v());
          const x = me(l, "addProseMirrorPlugins", u);
          if (x) {
            const S = x();
            c.push(...S);
          }
          return c;
        })
        .flat();
    return [_A({ editor: e, rules: r }), ...WA({ editor: e, rules: o }), ...i];
  }
  get attributes() {
    return vS(this.extensions);
  }
  get nodeViews() {
    const { editor: e } = this,
      { nodeExtensions: n } = qd(this.extensions);
    return Object.fromEntries(
      n
        .filter((r) => !!me(r, "addNodeView"))
        .map((r) => {
          const o = this.attributes.filter((c) => c.type === r.name),
            i = {
              name: r.name,
              options: r.options,
              storage: r.storage,
              editor: e,
              type: xt(r.name, this.schema),
            },
            l = me(r, "addNodeView", i);
          if (!l) return [];
          const u = (c, f, p, m, y) => {
            const v = xm(c, o);
            return l()({
              node: c,
              view: f,
              getPos: p,
              decorations: m,
              innerDecorations: y,
              editor: e,
              extension: r,
              HTMLAttributes: v,
            });
          };
          return [r.name, u];
        })
    );
  }
  setupExtensions() {
    this.extensions.forEach((e) => {
      var n;
      this.editor.extensionStorage[e.name] = e.storage;
      const r = {
        name: e.name,
        options: e.options,
        storage: e.storage,
        editor: this.editor,
        type: Sh(e.name, this.schema),
      };
      e.type === "mark" &&
        (!((n = Pe(me(e, "keepOnSplit", r))) !== null && n !== void 0) || n) &&
        this.splittableMarks.push(e.name);
      const o = me(e, "onBeforeCreate", r),
        i = me(e, "onCreate", r),
        l = me(e, "onUpdate", r),
        u = me(e, "onSelectionUpdate", r),
        c = me(e, "onTransaction", r),
        f = me(e, "onFocus", r),
        p = me(e, "onBlur", r),
        m = me(e, "onDestroy", r);
      o && this.editor.on("beforeCreate", o),
        i && this.editor.on("create", i),
        l && this.editor.on("update", l),
        u && this.editor.on("selectionUpdate", u),
        c && this.editor.on("transaction", c),
        f && this.editor.on("focus", f),
        p && this.editor.on("blur", p),
        m && this.editor.on("destroy", m);
    });
  }
}
class et {
  constructor(e = {}) {
    (this.type = "extension"),
      (this.name = "extension"),
      (this.parent = null),
      (this.child = null),
      (this.config = { name: this.name, defaultOptions: {} }),
      (this.config = { ...this.config, ...e }),
      (this.name = this.config.name),
      e.defaultOptions &&
        Object.keys(e.defaultOptions).length > 0 &&
        console.warn(
          `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
        ),
      (this.options = this.config.defaultOptions),
      this.config.addOptions &&
        (this.options = Pe(me(this, "addOptions", { name: this.name }))),
      (this.storage =
        Pe(
          me(this, "addStorage", { name: this.name, options: this.options })
        ) || {});
  }
  static create(e = {}) {
    return new et(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => Gd(this.options, e),
    });
    return (n.name = this.name), (n.parent = this.parent), n;
  }
  extend(e = {}) {
    const n = new et({ ...this.config, ...e });
    return (
      (n.parent = this),
      (this.child = n),
      (n.name = e.name ? e.name : n.parent.name),
      e.defaultOptions &&
        Object.keys(e.defaultOptions).length > 0 &&
        console.warn(
          `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`
        ),
      (n.options = Pe(me(n, "addOptions", { name: n.name }))),
      (n.storage = Pe(
        me(n, "addStorage", { name: n.name, options: n.options })
      )),
      n
    );
  }
}
function xS(t, e, n) {
  const { from: r, to: o } = e,
    {
      blockSeparator: i = `

`,
      textSerializers: l = {},
    } = n || {};
  let u = "";
  return (
    t.nodesBetween(r, o, (c, f, p, m) => {
      var y;
      c.isBlock && f > r && (u += i);
      const v = l == null ? void 0 : l[c.type.name];
      if (v)
        return (
          p && (u += v({ node: c, pos: f, parent: p, index: m, range: e })), !1
        );
      c.isText &&
        (u +=
          (y = c == null ? void 0 : c.text) === null || y === void 0
            ? void 0
            : y.slice(Math.max(r, f) - f, o - f));
    }),
    u
  );
}
function wg(t) {
  return Object.fromEntries(
    Object.entries(t.nodes)
      .filter(([, e]) => e.spec.toText)
      .map(([e, n]) => [e, n.spec.toText])
  );
}
const KA = et.create({
    name: "clipboardTextSerializer",
    addOptions() {
      return { blockSeparator: void 0 };
    },
    addProseMirrorPlugins() {
      return [
        new pt({
          key: new Wt("clipboardTextSerializer"),
          props: {
            clipboardTextSerializer: () => {
              const { editor: t } = this,
                { state: e, schema: n } = t,
                { doc: r, selection: o } = e,
                { ranges: i } = o,
                l = Math.min(...i.map((p) => p.$from.pos)),
                u = Math.max(...i.map((p) => p.$to.pos)),
                c = wg(n);
              return xS(
                r,
                { from: l, to: u },
                {
                  ...(this.options.blockSeparator !== void 0
                    ? { blockSeparator: this.options.blockSeparator }
                    : {}),
                  textSerializers: c,
                }
              );
            },
          },
        }),
      ];
    },
  }),
  qA =
    () =>
    ({ editor: t, view: e }) => (
      requestAnimationFrame(() => {
        var n;
        t.isDestroyed ||
          (e.dom.blur(),
          (n = window == null ? void 0 : window.getSelection()) === null ||
            n === void 0 ||
            n.removeAllRanges());
      }),
      !0
    ),
  GA =
    (t = !1) =>
    ({ commands: e }) =>
      e.setContent("", t),
  JA =
    () =>
    ({ state: t, tr: e, dispatch: n }) => {
      const { selection: r } = e,
        { ranges: o } = r;
      return (
        n &&
          o.forEach(({ $from: i, $to: l }) => {
            t.doc.nodesBetween(i.pos, l.pos, (u, c) => {
              if (u.type.isText) return;
              const { doc: f, mapping: p } = e,
                m = f.resolve(p.map(c)),
                y = f.resolve(p.map(c + u.nodeSize)),
                v = m.blockRange(y);
              if (!v) return;
              const x = tl(v);
              if (u.type.isTextblock) {
                const { defaultType: S } = m.parent.contentMatchAt(m.index());
                e.setNodeMarkup(v.start, S);
              }
              (x || x === 0) && e.lift(v, x);
            });
          }),
        !0
      );
    },
  QA = (t) => (e) => t(e),
  YA =
    () =>
    ({ state: t, dispatch: e }) =>
      yA(t, e),
  XA =
    (t, e) =>
    ({ editor: n, tr: r }) => {
      const { state: o } = n,
        i = o.doc.slice(t.from, t.to);
      r.deleteRange(t.from, t.to);
      const l = r.mapping.map(e);
      return (
        r.insert(l, i.content), r.setSelection(new Te(r.doc.resolve(l - 1))), !0
      );
    },
  ZA =
    () =>
    ({ tr: t, dispatch: e }) => {
      const { selection: n } = t,
        r = n.$anchor.node();
      if (r.content.size > 0) return !1;
      const o = t.selection.$anchor;
      for (let i = o.depth; i > 0; i -= 1)
        if (o.node(i).type === r.type) {
          if (e) {
            const u = o.before(i),
              c = o.after(i);
            t.delete(u, c).scrollIntoView();
          }
          return !0;
        }
      return !1;
    },
  eR =
    (t) =>
    ({ tr: e, state: n, dispatch: r }) => {
      const o = xt(t, n.schema),
        i = e.selection.$anchor;
      for (let l = i.depth; l > 0; l -= 1)
        if (i.node(l).type === o) {
          if (r) {
            const c = i.before(l),
              f = i.after(l);
            e.delete(c, f).scrollIntoView();
          }
          return !0;
        }
      return !1;
    },
  tR =
    (t) =>
    ({ tr: e, dispatch: n }) => {
      const { from: r, to: o } = t;
      return n && e.delete(r, o), !0;
    },
  nR =
    () =>
    ({ state: t, dispatch: e }) =>
      iA(t, e),
  rR =
    () =>
    ({ commands: t }) =>
      t.keyboardShortcut("Enter"),
  oR =
    () =>
    ({ state: t, dispatch: e }) =>
      gA(t, e);
function Jc(t, e, n = { strict: !0 }) {
  const r = Object.keys(e);
  return r.length
    ? r.every((o) =>
        n.strict ? e[o] === t[o] : vg(e[o]) ? e[o].test(t[o]) : e[o] === t[o]
      )
    : !0;
}
function bS(t, e, n = {}) {
  return t.find(
    (r) =>
      r.type === e &&
      Jc(Object.fromEntries(Object.keys(n).map((o) => [o, r.attrs[o]])), n)
  );
}
function Sw(t, e, n = {}) {
  return !!bS(t, e, n);
}
function xg(t, e, n) {
  var r;
  if (!t || !e) return;
  let o = t.parent.childAfter(t.parentOffset);
  if (
    ((!o.node || !o.node.marks.some((p) => p.type === e)) &&
      (o = t.parent.childBefore(t.parentOffset)),
    !o.node ||
      !o.node.marks.some((p) => p.type === e) ||
      ((n =
        n ||
        ((r = o.node.marks[0]) === null || r === void 0 ? void 0 : r.attrs)),
      !bS([...o.node.marks], e, n)))
  )
    return;
  let l = o.index,
    u = t.start() + o.offset,
    c = l + 1,
    f = u + o.node.nodeSize;
  for (; l > 0 && Sw([...t.parent.child(l - 1).marks], e, n); )
    (l -= 1), (u -= t.parent.child(l).nodeSize);
  for (; c < t.parent.childCount && Sw([...t.parent.child(c).marks], e, n); )
    (f += t.parent.child(c).nodeSize), (c += 1);
  return { from: u, to: f };
}
function Go(t, e) {
  if (typeof t == "string") {
    if (!e.marks[t])
      throw Error(
        `There is no mark type named '${t}'. Maybe you forgot to add the extension?`
      );
    return e.marks[t];
  }
  return t;
}
const iR =
    (t, e = {}) =>
    ({ tr: n, state: r, dispatch: o }) => {
      const i = Go(t, r.schema),
        { doc: l, selection: u } = n,
        { $from: c, from: f, to: p } = u;
      if (o) {
        const m = xg(c, i, e);
        if (m && m.from <= f && m.to >= p) {
          const y = Te.create(l, m.from, m.to);
          n.setSelection(y);
        }
      }
      return !0;
    },
  sR = (t) => (e) => {
    const n = typeof t == "function" ? t(e) : t;
    for (let r = 0; r < n.length; r += 1) if (n[r](e)) return !0;
    return !1;
  };
function bg(t) {
  return t instanceof Te;
}
function Wr(t = 0, e = 0, n = 0) {
  return Math.min(Math.max(t, e), n);
}
function SS(t, e = null) {
  if (!e) return null;
  const n = Ae.atStart(t),
    r = Ae.atEnd(t);
  if (e === "start" || e === !0) return n;
  if (e === "end") return r;
  const o = n.from,
    i = r.to;
  return e === "all"
    ? Te.create(t, Wr(0, o, i), Wr(t.content.size, o, i))
    : Te.create(t, Wr(e, o, i), Wr(e, o, i));
}
function lR() {
  return (
    navigator.platform === "Android" || /android/i.test(navigator.userAgent)
  );
}
function Sg() {
  return (
    [
      "iPad Simulator",
      "iPhone Simulator",
      "iPod Simulator",
      "iPad",
      "iPhone",
      "iPod",
    ].includes(navigator.platform) ||
    (navigator.userAgent.includes("Mac") && "ontouchend" in document)
  );
}
const aR =
    (t = null, e = {}) =>
    ({ editor: n, view: r, tr: o, dispatch: i }) => {
      e = { scrollIntoView: !0, ...e };
      const l = () => {
        (Sg() || lR()) && r.dom.focus(),
          requestAnimationFrame(() => {
            n.isDestroyed ||
              (r.focus(),
              e != null && e.scrollIntoView && n.commands.scrollIntoView());
          });
      };
      if ((r.hasFocus() && t === null) || t === !1) return !0;
      if (i && t === null && !bg(n.state.selection)) return l(), !0;
      const u = SS(o.doc, t) || n.state.selection,
        c = n.state.selection.eq(u);
      return (
        i &&
          (c || o.setSelection(u),
          c && o.storedMarks && o.setStoredMarks(o.storedMarks),
          l()),
        !0
      );
    },
  uR = (t, e) => (n) => t.every((r, o) => e(r, { ...n, index: o })),
  cR =
    (t, e) =>
    ({ tr: n, commands: r }) =>
      r.insertContentAt({ from: n.selection.from, to: n.selection.to }, t, e),
  CS = (t) => {
    const e = t.childNodes;
    for (let n = e.length - 1; n >= 0; n -= 1) {
      const r = e[n];
      r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue)
        ? t.removeChild(r)
        : r.nodeType === 1 && CS(r);
    }
    return t;
  };
function dc(t) {
  const e = `<body>${t}</body>`,
    n = new window.DOMParser().parseFromString(e, "text/html").body;
  return CS(n);
}
function Qc(t, e, n) {
  if (t instanceof $o || t instanceof J) return t;
  n = { slice: !0, parseOptions: {}, ...n };
  const r = typeof t == "object" && t !== null,
    o = typeof t == "string";
  if (r)
    try {
      if (Array.isArray(t) && t.length > 0)
        return J.fromArray(t.map((u) => e.nodeFromJSON(u)));
      const l = e.nodeFromJSON(t);
      return n.errorOnInvalidContent && l.check(), l;
    } catch (i) {
      if (n.errorOnInvalidContent)
        throw new Error("[tiptap error]: Invalid JSON content", { cause: i });
      return (
        console.warn(
          "[tiptap warn]: Invalid content.",
          "Passed value:",
          t,
          "Error:",
          i
        ),
        Qc("", e, n)
      );
    }
  if (o) {
    if (n.errorOnInvalidContent) {
      let l = !1,
        u = "";
      const c = new pb({
        topNode: e.spec.topNode,
        marks: e.spec.marks,
        nodes: e.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (f) => (
                  (l = !0), (u = typeof f == "string" ? f : f.outerHTML), null
                ),
              },
            ],
          },
        }),
      });
      if (
        (n.slice
          ? _o.fromSchema(c).parseSlice(dc(t), n.parseOptions)
          : _o.fromSchema(c).parse(dc(t), n.parseOptions),
        n.errorOnInvalidContent && l)
      )
        throw new Error("[tiptap error]: Invalid HTML content", {
          cause: new Error(`Invalid element found: ${u}`),
        });
    }
    const i = _o.fromSchema(e);
    return n.slice
      ? i.parseSlice(dc(t), n.parseOptions).content
      : i.parse(dc(t), n.parseOptions);
  }
  return Qc("", e, n);
}
function dR(t, e, n) {
  const r = t.steps.length - 1;
  if (r < e) return;
  const o = t.steps[r];
  if (!(o instanceof yt || o instanceof vt)) return;
  const i = t.mapping.maps[r];
  let l = 0;
  i.forEach((u, c, f, p) => {
    l === 0 && (l = p);
  }),
    t.setSelection(Ae.near(t.doc.resolve(l), n));
}
const fR = (t) => !("type" in t),
  pR =
    (t, e, n) =>
    ({ tr: r, dispatch: o, editor: i }) => {
      var l;
      if (o) {
        n = {
          parseOptions: i.options.parseOptions,
          updateSelection: !0,
          applyInputRules: !1,
          applyPasteRules: !1,
          ...n,
        };
        let u;
        try {
          u = Qc(e, i.schema, {
            parseOptions: { preserveWhitespace: "full", ...n.parseOptions },
            errorOnInvalidContent:
              (l = n.errorOnInvalidContent) !== null && l !== void 0
                ? l
                : i.options.enableContentCheck,
          });
        } catch (x) {
          return (
            i.emit("contentError", {
              editor: i,
              error: x,
              disableCollaboration: () => {
                i.storage.collaboration &&
                  (i.storage.collaboration.isDisabled = !0);
              },
            }),
            !1
          );
        }
        let { from: c, to: f } =
            typeof t == "number"
              ? { from: t, to: t }
              : { from: t.from, to: t.to },
          p = !0,
          m = !0;
        if (
          ((fR(u) ? u : [u]).forEach((x) => {
            x.check(),
              (p = p ? x.isText && x.marks.length === 0 : !1),
              (m = m ? x.isBlock : !1);
          }),
          c === f && m)
        ) {
          const { parent: x } = r.doc.resolve(c);
          x.isTextblock &&
            !x.type.spec.code &&
            !x.childCount &&
            ((c -= 1), (f += 1));
        }
        let v;
        if (p) {
          if (Array.isArray(e)) v = e.map((x) => x.text || "").join("");
          else if (e instanceof J) {
            let x = "";
            e.forEach((S) => {
              S.text && (x += S.text);
            }),
              (v = x);
          } else typeof e == "object" && e && e.text ? (v = e.text) : (v = e);
          r.insertText(v, c, f);
        } else (v = u), r.replaceWith(c, f, v);
        n.updateSelection && dR(r, r.steps.length - 1, -1),
          n.applyInputRules &&
            r.setMeta("applyInputRules", { from: c, text: v }),
          n.applyPasteRules &&
            r.setMeta("applyPasteRules", { from: c, text: v });
      }
      return !0;
    },
  hR =
    () =>
    ({ state: t, dispatch: e }) =>
      fA(t, e),
  mR =
    () =>
    ({ state: t, dispatch: e }) =>
      pA(t, e),
  gR =
    () =>
    ({ state: t, dispatch: e }) =>
      sA(t, e),
  yR =
    () =>
    ({ state: t, dispatch: e }) =>
      cA(t, e),
  vR =
    () =>
    ({ state: t, dispatch: e, tr: n }) => {
      try {
        const r = zd(t.doc, t.selection.$from.pos, -1);
        return r == null ? !1 : (n.join(r, 2), e && e(n), !0);
      } catch {
        return !1;
      }
    },
  wR =
    () =>
    ({ state: t, dispatch: e, tr: n }) => {
      try {
        const r = zd(t.doc, t.selection.$from.pos, 1);
        return r == null ? !1 : (n.join(r, 2), e && e(n), !0);
      } catch {
        return !1;
      }
    },
  xR =
    () =>
    ({ state: t, dispatch: e }) =>
      lA(t, e),
  bR =
    () =>
    ({ state: t, dispatch: e }) =>
      aA(t, e);
function kS() {
  return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1;
}
function SR(t) {
  const e = t.split(/-(?!$)/);
  let n = e[e.length - 1];
  n === "Space" && (n = " ");
  let r, o, i, l;
  for (let u = 0; u < e.length - 1; u += 1) {
    const c = e[u];
    if (/^(cmd|meta|m)$/i.test(c)) l = !0;
    else if (/^a(lt)?$/i.test(c)) r = !0;
    else if (/^(c|ctrl|control)$/i.test(c)) o = !0;
    else if (/^s(hift)?$/i.test(c)) i = !0;
    else if (/^mod$/i.test(c)) Sg() || kS() ? (l = !0) : (o = !0);
    else throw new Error(`Unrecognized modifier name: ${c}`);
  }
  return (
    r && (n = `Alt-${n}`),
    o && (n = `Ctrl-${n}`),
    l && (n = `Meta-${n}`),
    i && (n = `Shift-${n}`),
    n
  );
}
const CR =
  (t) =>
  ({ editor: e, view: n, tr: r, dispatch: o }) => {
    const i = SR(t).split(/-(?!$)/),
      l = i.find((f) => !["Alt", "Ctrl", "Meta", "Shift"].includes(f)),
      u = new KeyboardEvent("keydown", {
        key: l === "Space" ? " " : l,
        altKey: i.includes("Alt"),
        ctrlKey: i.includes("Ctrl"),
        metaKey: i.includes("Meta"),
        shiftKey: i.includes("Shift"),
        bubbles: !0,
        cancelable: !0,
      }),
      c = e.captureTransaction(() => {
        n.someProp("handleKeyDown", (f) => f(n, u));
      });
    return (
      c == null ||
        c.steps.forEach((f) => {
          const p = f.map(r.mapping);
          p && o && r.maybeStep(p);
        }),
      !0
    );
  };
function Ca(t, e, n = {}) {
  const { from: r, to: o, empty: i } = t.selection,
    l = e ? xt(e, t.schema) : null,
    u = [];
  t.doc.nodesBetween(r, o, (m, y) => {
    if (m.isText) return;
    const v = Math.max(r, y),
      x = Math.min(o, y + m.nodeSize);
    u.push({ node: m, from: v, to: x });
  });
  const c = o - r,
    f = u
      .filter((m) => (l ? l.name === m.node.type.name : !0))
      .filter((m) => Jc(m.node.attrs, n, { strict: !1 }));
  return i ? !!f.length : f.reduce((m, y) => m + y.to - y.from, 0) >= c;
}
const kR =
    (t, e = {}) =>
    ({ state: n, dispatch: r }) => {
      const o = xt(t, n.schema);
      return Ca(n, o, e) ? hA(n, r) : !1;
    },
  ER =
    () =>
    ({ state: t, dispatch: e }) =>
      vA(t, e),
  MR =
    (t) =>
    ({ state: e, dispatch: n }) => {
      const r = xt(t, e.schema);
      return OA(r)(e, n);
    },
  OR =
    () =>
    ({ state: t, dispatch: e }) =>
      mA(t, e);
function Jd(t, e) {
  return e.nodes[t] ? "node" : e.marks[t] ? "mark" : null;
}
function Cw(t, e) {
  const n = typeof e == "string" ? [e] : e;
  return Object.keys(t).reduce(
    (r, o) => (n.includes(o) || (r[o] = t[o]), r),
    {}
  );
}
const TR =
    (t, e) =>
    ({ tr: n, state: r, dispatch: o }) => {
      let i = null,
        l = null;
      const u = Jd(typeof t == "string" ? t : t.name, r.schema);
      return u
        ? (u === "node" && (i = xt(t, r.schema)),
          u === "mark" && (l = Go(t, r.schema)),
          o &&
            n.selection.ranges.forEach((c) => {
              r.doc.nodesBetween(c.$from.pos, c.$to.pos, (f, p) => {
                i && i === f.type && n.setNodeMarkup(p, void 0, Cw(f.attrs, e)),
                  l &&
                    f.marks.length &&
                    f.marks.forEach((m) => {
                      l === m.type &&
                        n.addMark(p, p + f.nodeSize, l.create(Cw(m.attrs, e)));
                    });
              });
            }),
          !0)
        : !1;
    },
  NR =
    () =>
    ({ tr: t, dispatch: e }) => (e && t.scrollIntoView(), !0),
  AR =
    () =>
    ({ tr: t, dispatch: e }) => {
      if (e) {
        const n = new Nn(t.doc);
        t.setSelection(n);
      }
      return !0;
    },
  RR =
    () =>
    ({ state: t, dispatch: e }) =>
      uA(t, e),
  PR =
    () =>
    ({ state: t, dispatch: e }) =>
      dA(t, e),
  DR =
    () =>
    ({ state: t, dispatch: e }) =>
      wA(t, e),
  IR =
    () =>
    ({ state: t, dispatch: e }) =>
      SA(t, e),
  LR =
    () =>
    ({ state: t, dispatch: e }) =>
      bA(t, e);
function bm(t, e, n = {}, r = {}) {
  return Qc(t, e, {
    slice: !1,
    parseOptions: n,
    errorOnInvalidContent: r.errorOnInvalidContent,
  });
}
const $R =
  (t, e = !1, n = {}, r = {}) =>
  ({ editor: o, tr: i, dispatch: l, commands: u }) => {
    var c, f;
    const { doc: p } = i;
    if (n.preserveWhitespace !== "full") {
      const m = bm(t, o.schema, n, {
        errorOnInvalidContent:
          (c = r.errorOnInvalidContent) !== null && c !== void 0
            ? c
            : o.options.enableContentCheck,
      });
      return (
        l && i.replaceWith(0, p.content.size, m).setMeta("preventUpdate", !e),
        !0
      );
    }
    return (
      l && i.setMeta("preventUpdate", !e),
      u.insertContentAt({ from: 0, to: p.content.size }, t, {
        parseOptions: n,
        errorOnInvalidContent:
          (f = r.errorOnInvalidContent) !== null && f !== void 0
            ? f
            : o.options.enableContentCheck,
      })
    );
  };
function ES(t, e) {
  const n = Go(e, t.schema),
    { from: r, to: o, empty: i } = t.selection,
    l = [];
  i
    ? (t.storedMarks && l.push(...t.storedMarks),
      l.push(...t.selection.$head.marks()))
    : t.doc.nodesBetween(r, o, (c) => {
        l.push(...c.marks);
      });
  const u = l.find((c) => c.type.name === n.name);
  return u ? { ...u.attrs } : {};
}
function _R(t, e) {
  const n = new Nb(t);
  return (
    e.forEach((r) => {
      r.steps.forEach((o) => {
        n.step(o);
      });
    }),
    n
  );
}
function FR(t) {
  for (let e = 0; e < t.edgeCount; e += 1) {
    const { type: n } = t.edge(e);
    if (n.isTextblock && !n.hasRequiredAttrs()) return n;
  }
  return null;
}
function zR(t, e, n) {
  const r = [];
  return (
    t.nodesBetween(e.from, e.to, (o, i) => {
      n(o) && r.push({ node: o, pos: i });
    }),
    r
  );
}
function jR(t, e) {
  for (let n = t.depth; n > 0; n -= 1) {
    const r = t.node(n);
    if (e(r))
      return {
        pos: n > 0 ? t.before(n) : 0,
        start: t.start(n),
        depth: n,
        node: r,
      };
  }
}
function Cg(t) {
  return (e) => jR(e.$from, t);
}
function MS(t, e) {
  const n = { from: 0, to: t.content.size };
  return xS(t, n, e);
}
function BR(t, e) {
  const n = xt(e, t.schema),
    { from: r, to: o } = t.selection,
    i = [];
  t.doc.nodesBetween(r, o, (u) => {
    i.push(u);
  });
  const l = i.reverse().find((u) => u.type.name === n.name);
  return l ? { ...l.attrs } : {};
}
function OS(t, e) {
  const n = Jd(typeof e == "string" ? e : e.name, t.schema);
  return n === "node" ? BR(t, e) : n === "mark" ? ES(t, e) : {};
}
function HR(t, e = JSON.stringify) {
  const n = {};
  return t.filter((r) => {
    const o = e(r);
    return Object.prototype.hasOwnProperty.call(n, o) ? !1 : (n[o] = !0);
  });
}
function VR(t) {
  const e = HR(t);
  return e.length === 1
    ? e
    : e.filter(
        (n, r) =>
          !e
            .filter((i, l) => l !== r)
            .some(
              (i) =>
                n.oldRange.from >= i.oldRange.from &&
                n.oldRange.to <= i.oldRange.to &&
                n.newRange.from >= i.newRange.from &&
                n.newRange.to <= i.newRange.to
            )
      );
}
function WR(t) {
  const { mapping: e, steps: n } = t,
    r = [];
  return (
    e.maps.forEach((o, i) => {
      const l = [];
      if (o.ranges.length)
        o.forEach((u, c) => {
          l.push({ from: u, to: c });
        });
      else {
        const { from: u, to: c } = n[i];
        if (u === void 0 || c === void 0) return;
        l.push({ from: u, to: c });
      }
      l.forEach(({ from: u, to: c }) => {
        const f = e.slice(i).map(u, -1),
          p = e.slice(i).map(c),
          m = e.invert().map(f, -1),
          y = e.invert().map(p);
        r.push({ oldRange: { from: m, to: y }, newRange: { from: f, to: p } });
      });
    }),
    VR(r)
  );
}
function kg(t, e, n) {
  const r = [];
  return (
    t === e
      ? n
          .resolve(t)
          .marks()
          .forEach((o) => {
            const i = n.resolve(t),
              l = xg(i, o.type);
            l && r.push({ mark: o, ...l });
          })
      : n.nodesBetween(t, e, (o, i) => {
          !o ||
            (o == null ? void 0 : o.nodeSize) === void 0 ||
            r.push(
              ...o.marks.map((l) => ({ from: i, to: i + o.nodeSize, mark: l }))
            );
        }),
    r
  );
}
function Pc(t, e, n) {
  return Object.fromEntries(
    Object.entries(n).filter(([r]) => {
      const o = t.find((i) => i.type === e && i.name === r);
      return o ? o.attribute.keepOnSplit : !1;
    })
  );
}
function Sm(t, e, n = {}) {
  const { empty: r, ranges: o } = t.selection,
    i = e ? Go(e, t.schema) : null;
  if (r)
    return !!(t.storedMarks || t.selection.$from.marks())
      .filter((m) => (i ? i.name === m.type.name : !0))
      .find((m) => Jc(m.attrs, n, { strict: !1 }));
  let l = 0;
  const u = [];
  if (
    (o.forEach(({ $from: m, $to: y }) => {
      const v = m.pos,
        x = y.pos;
      t.doc.nodesBetween(v, x, (S, C) => {
        if (!S.isText && !S.marks.length) return;
        const E = Math.max(v, C),
          N = Math.min(x, C + S.nodeSize),
          $ = N - E;
        (l += $), u.push(...S.marks.map((M) => ({ mark: M, from: E, to: N })));
      });
    }),
    l === 0)
  )
    return !1;
  const c = u
      .filter((m) => (i ? i.name === m.mark.type.name : !0))
      .filter((m) => Jc(m.mark.attrs, n, { strict: !1 }))
      .reduce((m, y) => m + y.to - y.from, 0),
    f = u
      .filter((m) => (i ? m.mark.type !== i && m.mark.type.excludes(i) : !0))
      .reduce((m, y) => m + y.to - y.from, 0);
  return (c > 0 ? c + f : c) >= l;
}
function UR(t, e, n = {}) {
  if (!e) return Ca(t, null, n) || Sm(t, null, n);
  const r = Jd(e, t.schema);
  return r === "node" ? Ca(t, e, n) : r === "mark" ? Sm(t, e, n) : !1;
}
function kw(t, e) {
  const { nodeExtensions: n } = qd(e),
    r = n.find((l) => l.name === t);
  if (!r) return !1;
  const o = { name: r.name, options: r.options, storage: r.storage },
    i = Pe(me(r, "group", o));
  return typeof i != "string" ? !1 : i.split(" ").includes("list");
}
function Eg(t, { checkChildren: e = !0, ignoreWhitespace: n = !1 } = {}) {
  var r;
  if (n) {
    if (t.type.name === "hardBreak") return !0;
    if (t.isText)
      return /^\s*$/m.test((r = t.text) !== null && r !== void 0 ? r : "");
  }
  if (t.isText) return !t.text;
  if (t.isAtom || t.isLeaf) return !1;
  if (t.content.childCount === 0) return !0;
  if (e) {
    let o = !0;
    return (
      t.content.forEach((i) => {
        o !== !1 &&
          (Eg(i, { ignoreWhitespace: n, checkChildren: e }) || (o = !1));
      }),
      o
    );
  }
  return !1;
}
function TS(t) {
  return t instanceof ke;
}
function NS(t, e, n) {
  const o = t.state.doc.content.size,
    i = Wr(e, 0, o),
    l = Wr(n, 0, o),
    u = t.coordsAtPos(i),
    c = t.coordsAtPos(l, -1),
    f = Math.min(u.top, c.top),
    p = Math.max(u.bottom, c.bottom),
    m = Math.min(u.left, c.left),
    y = Math.max(u.right, c.right),
    v = y - m,
    x = p - f,
    E = {
      top: f,
      bottom: p,
      left: m,
      right: y,
      width: v,
      height: x,
      x: m,
      y: f,
    };
  return { ...E, toJSON: () => E };
}
function KR(t, e, n) {
  var r;
  const { selection: o } = e;
  let i = null;
  if ((bg(o) && (i = o.$cursor), i)) {
    const u = (r = t.storedMarks) !== null && r !== void 0 ? r : i.marks();
    return !!n.isInSet(u) || !u.some((c) => c.type.excludes(n));
  }
  const { ranges: l } = o;
  return l.some(({ $from: u, $to: c }) => {
    let f =
      u.depth === 0 ? t.doc.inlineContent && t.doc.type.allowsMarkType(n) : !1;
    return (
      t.doc.nodesBetween(u.pos, c.pos, (p, m, y) => {
        if (f) return !1;
        if (p.isInline) {
          const v = !y || y.type.allowsMarkType(n),
            x =
              !!n.isInSet(p.marks) || !p.marks.some((S) => S.type.excludes(n));
          f = v && x;
        }
        return !f;
      }),
      f
    );
  });
}
const qR =
    (t, e = {}) =>
    ({ tr: n, state: r, dispatch: o }) => {
      const { selection: i } = n,
        { empty: l, ranges: u } = i,
        c = Go(t, r.schema);
      if (o)
        if (l) {
          const f = ES(r, c);
          n.addStoredMark(c.create({ ...f, ...e }));
        } else
          u.forEach((f) => {
            const p = f.$from.pos,
              m = f.$to.pos;
            r.doc.nodesBetween(p, m, (y, v) => {
              const x = Math.max(v, p),
                S = Math.min(v + y.nodeSize, m);
              y.marks.find((E) => E.type === c)
                ? y.marks.forEach((E) => {
                    c === E.type &&
                      n.addMark(x, S, c.create({ ...E.attrs, ...e }));
                  })
                : n.addMark(x, S, c.create(e));
            });
          });
      return KR(r, n, c);
    },
  GR =
    (t, e) =>
    ({ tr: n }) => (n.setMeta(t, e), !0),
  JR =
    (t, e = {}) =>
    ({ state: n, dispatch: r, chain: o }) => {
      const i = xt(t, n.schema);
      let l;
      return (
        n.selection.$anchor.sameParent(n.selection.$head) &&
          (l = n.selection.$anchor.parent.attrs),
        i.isTextblock
          ? o()
              .command(({ commands: u }) =>
                vw(i, { ...l, ...e })(n) ? !0 : u.clearNodes()
              )
              .command(({ state: u }) => vw(i, { ...l, ...e })(u, r))
              .run()
          : (console.warn(
              '[tiptap warn]: Currently "setNode()" only supports text block nodes.'
            ),
            !1)
      );
    },
  QR =
    (t) =>
    ({ tr: e, dispatch: n }) => {
      if (n) {
        const { doc: r } = e,
          o = Wr(t, 0, r.content.size),
          i = ke.create(r, o);
        e.setSelection(i);
      }
      return !0;
    },
  YR =
    (t) =>
    ({ tr: e, dispatch: n }) => {
      if (n) {
        const { doc: r } = e,
          { from: o, to: i } = typeof t == "number" ? { from: t, to: t } : t,
          l = Te.atStart(r).from,
          u = Te.atEnd(r).to,
          c = Wr(o, l, u),
          f = Wr(i, l, u),
          p = Te.create(r, c, f);
        e.setSelection(p);
      }
      return !0;
    },
  XR =
    (t) =>
    ({ state: e, dispatch: n }) => {
      const r = xt(t, e.schema);
      return AA(r)(e, n);
    };
function Ew(t, e) {
  const n =
    t.storedMarks ||
    (t.selection.$to.parentOffset && t.selection.$from.marks());
  if (n) {
    const r = n.filter((o) => (e == null ? void 0 : e.includes(o.type.name)));
    t.tr.ensureMarks(r);
  }
}
const ZR =
    ({ keepMarks: t = !0 } = {}) =>
    ({ tr: e, state: n, dispatch: r, editor: o }) => {
      const { selection: i, doc: l } = e,
        { $from: u, $to: c } = i,
        f = o.extensionManager.attributes,
        p = Pc(f, u.node().type.name, u.node().attrs);
      if (i instanceof ke && i.node.isBlock)
        return !u.parentOffset || !Ls(l, u.pos)
          ? !1
          : (r &&
              (t && Ew(n, o.extensionManager.splittableMarks),
              e.split(u.pos).scrollIntoView()),
            !0);
      if (!u.parent.isBlock) return !1;
      const m = c.parentOffset === c.parent.content.size,
        y =
          u.depth === 0
            ? void 0
            : FR(u.node(-1).contentMatchAt(u.indexAfter(-1)));
      let v = m && y ? [{ type: y, attrs: p }] : void 0,
        x = Ls(e.doc, e.mapping.map(u.pos), 1, v);
      if (
        (!v &&
          !x &&
          Ls(e.doc, e.mapping.map(u.pos), 1, y ? [{ type: y }] : void 0) &&
          ((x = !0), (v = y ? [{ type: y, attrs: p }] : void 0)),
        r)
      ) {
        if (
          x &&
          (i instanceof Te && e.deleteSelection(),
          e.split(e.mapping.map(u.pos), 1, v),
          y && !m && !u.parentOffset && u.parent.type !== y)
        ) {
          const S = e.mapping.map(u.before()),
            C = e.doc.resolve(S);
          u.node(-1).canReplaceWith(C.index(), C.index() + 1, y) &&
            e.setNodeMarkup(e.mapping.map(u.before()), y);
        }
        t && Ew(n, o.extensionManager.splittableMarks), e.scrollIntoView();
      }
      return x;
    },
  e3 =
    (t, e = {}) =>
    ({ tr: n, state: r, dispatch: o, editor: i }) => {
      var l;
      const u = xt(t, r.schema),
        { $from: c, $to: f } = r.selection,
        p = r.selection.node;
      if ((p && p.isBlock) || c.depth < 2 || !c.sameParent(f)) return !1;
      const m = c.node(-1);
      if (m.type !== u) return !1;
      const y = i.extensionManager.attributes;
      if (
        c.parent.content.size === 0 &&
        c.node(-1).childCount === c.indexAfter(-1)
      ) {
        if (
          c.depth === 2 ||
          c.node(-3).type !== u ||
          c.index(-2) !== c.node(-2).childCount - 1
        )
          return !1;
        if (o) {
          let E = J.empty;
          const N = c.index(-1) ? 1 : c.index(-2) ? 2 : 3;
          for (let H = c.depth - N; H >= c.depth - 3; H -= 1)
            E = J.from(c.node(H).copy(E));
          const $ =
              c.indexAfter(-1) < c.node(-2).childCount
                ? 1
                : c.indexAfter(-2) < c.node(-3).childCount
                ? 2
                : 3,
            M = { ...Pc(y, c.node().type.name, c.node().attrs), ...e },
            I =
              ((l = u.contentMatch.defaultType) === null || l === void 0
                ? void 0
                : l.createAndFill(M)) || void 0;
          E = E.append(J.from(u.createAndFill(null, I) || void 0));
          const R = c.before(c.depth - (N - 1));
          n.replace(R, c.after(-$), new ae(E, 4 - N, 0));
          let F = -1;
          n.doc.nodesBetween(R, n.doc.content.size, (H, U) => {
            if (F > -1) return !1;
            H.isTextblock && H.content.size === 0 && (F = U + 1);
          }),
            F > -1 && n.setSelection(Te.near(n.doc.resolve(F))),
            n.scrollIntoView();
        }
        return !0;
      }
      const v = f.pos === c.end() ? m.contentMatchAt(0).defaultType : null,
        x = { ...Pc(y, m.type.name, m.attrs), ...e },
        S = { ...Pc(y, c.node().type.name, c.node().attrs), ...e };
      n.delete(c.pos, f.pos);
      const C = v
        ? [
            { type: u, attrs: x },
            { type: v, attrs: S },
          ]
        : [{ type: u, attrs: x }];
      if (!Ls(n.doc, c.pos, 2)) return !1;
      if (o) {
        const { selection: E, storedMarks: N } = r,
          { splittableMarks: $ } = i.extensionManager,
          M = N || (E.$to.parentOffset && E.$from.marks());
        if ((n.split(c.pos, 2, C).scrollIntoView(), !M || !o)) return !0;
        const I = M.filter((R) => $.includes(R.type.name));
        n.ensureMarks(I);
      }
      return !0;
    },
  Ch = (t, e) => {
    const n = Cg((l) => l.type === e)(t.selection);
    if (!n) return !0;
    const r = t.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
    if (r === void 0) return !0;
    const o = t.doc.nodeAt(r);
    return (
      n.node.type === (o == null ? void 0 : o.type) &&
        Ko(t.doc, n.pos) &&
        t.join(n.pos),
      !0
    );
  },
  kh = (t, e) => {
    const n = Cg((l) => l.type === e)(t.selection);
    if (!n) return !0;
    const r = t.doc.resolve(n.start).after(n.depth);
    if (r === void 0) return !0;
    const o = t.doc.nodeAt(r);
    return (
      n.node.type === (o == null ? void 0 : o.type) &&
        Ko(t.doc, r) &&
        t.join(r),
      !0
    );
  },
  t3 =
    (t, e, n, r = {}) =>
    ({
      editor: o,
      tr: i,
      state: l,
      dispatch: u,
      chain: c,
      commands: f,
      can: p,
    }) => {
      const { extensions: m, splittableMarks: y } = o.extensionManager,
        v = xt(t, l.schema),
        x = xt(e, l.schema),
        { selection: S, storedMarks: C } = l,
        { $from: E, $to: N } = S,
        $ = E.blockRange(N),
        M = C || (S.$to.parentOffset && S.$from.marks());
      if (!$) return !1;
      const I = Cg((R) => kw(R.type.name, m))(S);
      if ($.depth >= 1 && I && $.depth - I.depth <= 1) {
        if (I.node.type === v) return f.liftListItem(x);
        if (kw(I.node.type.name, m) && v.validContent(I.node.content) && u)
          return c()
            .command(() => (i.setNodeMarkup(I.pos, v), !0))
            .command(() => Ch(i, v))
            .command(() => kh(i, v))
            .run();
      }
      return !n || !M || !u
        ? c()
            .command(() => (p().wrapInList(v, r) ? !0 : f.clearNodes()))
            .wrapInList(v, r)
            .command(() => Ch(i, v))
            .command(() => kh(i, v))
            .run()
        : c()
            .command(() => {
              const R = p().wrapInList(v, r),
                F = M.filter((H) => y.includes(H.type.name));
              return i.ensureMarks(F), R ? !0 : f.clearNodes();
            })
            .wrapInList(v, r)
            .command(() => Ch(i, v))
            .command(() => kh(i, v))
            .run();
    },
  n3 =
    (t, e = {}, n = {}) =>
    ({ state: r, commands: o }) => {
      const { extendEmptyMarkRange: i = !1 } = n,
        l = Go(t, r.schema);
      return Sm(r, l, e)
        ? o.unsetMark(l, { extendEmptyMarkRange: i })
        : o.setMark(l, e);
    },
  r3 =
    (t, e, n = {}) =>
    ({ state: r, commands: o }) => {
      const i = xt(t, r.schema),
        l = xt(e, r.schema),
        u = Ca(r, i, n);
      let c;
      return (
        r.selection.$anchor.sameParent(r.selection.$head) &&
          (c = r.selection.$anchor.parent.attrs),
        u ? o.setNode(l, c) : o.setNode(i, { ...c, ...n })
      );
    },
  o3 =
    (t, e = {}) =>
    ({ state: n, commands: r }) => {
      const o = xt(t, n.schema);
      return Ca(n, o, e) ? r.lift(o) : r.wrapIn(o, e);
    },
  i3 =
    () =>
    ({ state: t, dispatch: e }) => {
      const n = t.plugins;
      for (let r = 0; r < n.length; r += 1) {
        const o = n[r];
        let i;
        if (o.spec.isInputRules && (i = o.getState(t))) {
          if (e) {
            const l = t.tr,
              u = i.transform;
            for (let c = u.steps.length - 1; c >= 0; c -= 1)
              l.step(u.steps[c].invert(u.docs[c]));
            if (i.text) {
              const c = l.doc.resolve(i.from).marks();
              l.replaceWith(i.from, i.to, t.schema.text(i.text, c));
            } else l.delete(i.from, i.to);
          }
          return !0;
        }
      }
      return !1;
    },
  s3 =
    () =>
    ({ tr: t, dispatch: e }) => {
      const { selection: n } = t,
        { empty: r, ranges: o } = n;
      return (
        r ||
          (e &&
            o.forEach((i) => {
              t.removeMark(i.$from.pos, i.$to.pos);
            })),
        !0
      );
    },
  l3 =
    (t, e = {}) =>
    ({ tr: n, state: r, dispatch: o }) => {
      var i;
      const { extendEmptyMarkRange: l = !1 } = e,
        { selection: u } = n,
        c = Go(t, r.schema),
        { $from: f, empty: p, ranges: m } = u;
      if (!o) return !0;
      if (p && l) {
        let { from: y, to: v } = u;
        const x =
            (i = f.marks().find((C) => C.type === c)) === null || i === void 0
              ? void 0
              : i.attrs,
          S = xg(f, c, x);
        S && ((y = S.from), (v = S.to)), n.removeMark(y, v, c);
      } else
        m.forEach((y) => {
          n.removeMark(y.$from.pos, y.$to.pos, c);
        });
      return n.removeStoredMark(c), !0;
    },
  a3 =
    (t, e = {}) =>
    ({ tr: n, state: r, dispatch: o }) => {
      let i = null,
        l = null;
      const u = Jd(typeof t == "string" ? t : t.name, r.schema);
      return u
        ? (u === "node" && (i = xt(t, r.schema)),
          u === "mark" && (l = Go(t, r.schema)),
          o &&
            n.selection.ranges.forEach((c) => {
              const f = c.$from.pos,
                p = c.$to.pos;
              let m, y, v, x;
              n.selection.empty
                ? r.doc.nodesBetween(f, p, (S, C) => {
                    i &&
                      i === S.type &&
                      ((v = Math.max(C, f)),
                      (x = Math.min(C + S.nodeSize, p)),
                      (m = C),
                      (y = S));
                  })
                : r.doc.nodesBetween(f, p, (S, C) => {
                    C < f &&
                      i &&
                      i === S.type &&
                      ((v = Math.max(C, f)),
                      (x = Math.min(C + S.nodeSize, p)),
                      (m = C),
                      (y = S)),
                      C >= f &&
                        C <= p &&
                        (i &&
                          i === S.type &&
                          n.setNodeMarkup(C, void 0, { ...S.attrs, ...e }),
                        l &&
                          S.marks.length &&
                          S.marks.forEach((E) => {
                            if (l === E.type) {
                              const N = Math.max(C, f),
                                $ = Math.min(C + S.nodeSize, p);
                              n.addMark(N, $, l.create({ ...E.attrs, ...e }));
                            }
                          }));
                  }),
                y &&
                  (m !== void 0 &&
                    n.setNodeMarkup(m, void 0, { ...y.attrs, ...e }),
                  l &&
                    y.marks.length &&
                    y.marks.forEach((S) => {
                      l === S.type &&
                        n.addMark(v, x, l.create({ ...S.attrs, ...e }));
                    }));
            }),
          !0)
        : !1;
    },
  u3 =
    (t, e = {}) =>
    ({ state: n, dispatch: r }) => {
      const o = xt(t, n.schema);
      return CA(o, e)(n, r);
    },
  c3 =
    (t, e = {}) =>
    ({ state: n, dispatch: r }) => {
      const o = xt(t, n.schema);
      return kA(o, e)(n, r);
    };
var d3 = Object.freeze({
  __proto__: null,
  blur: qA,
  clearContent: GA,
  clearNodes: JA,
  command: QA,
  createParagraphNear: YA,
  cut: XA,
  deleteCurrentNode: ZA,
  deleteNode: eR,
  deleteRange: tR,
  deleteSelection: nR,
  enter: rR,
  exitCode: oR,
  extendMarkRange: iR,
  first: sR,
  focus: aR,
  forEach: uR,
  insertContent: cR,
  insertContentAt: pR,
  joinBackward: gR,
  joinDown: mR,
  joinForward: yR,
  joinItemBackward: vR,
  joinItemForward: wR,
  joinTextblockBackward: xR,
  joinTextblockForward: bR,
  joinUp: hR,
  keyboardShortcut: CR,
  lift: kR,
  liftEmptyBlock: ER,
  liftListItem: MR,
  newlineInCode: OR,
  resetAttributes: TR,
  scrollIntoView: NR,
  selectAll: AR,
  selectNodeBackward: RR,
  selectNodeForward: PR,
  selectParentNode: DR,
  selectTextblockEnd: IR,
  selectTextblockStart: LR,
  setContent: $R,
  setMark: qR,
  setMeta: GR,
  setNode: JR,
  setNodeSelection: QR,
  setTextSelection: YR,
  sinkListItem: XR,
  splitBlock: ZR,
  splitListItem: e3,
  toggleList: t3,
  toggleMark: n3,
  toggleNode: r3,
  toggleWrap: o3,
  undoInputRule: i3,
  unsetAllMarks: s3,
  unsetMark: l3,
  updateAttributes: a3,
  wrapIn: u3,
  wrapInList: c3,
});
const f3 = et.create({
    name: "commands",
    addCommands() {
      return { ...d3 };
    },
  }),
  p3 = et.create({
    name: "drop",
    addProseMirrorPlugins() {
      return [
        new pt({
          key: new Wt("tiptapDrop"),
          props: {
            handleDrop: (t, e, n, r) => {
              this.editor.emit("drop", {
                editor: this.editor,
                event: e,
                slice: n,
                moved: r,
              });
            },
          },
        }),
      ];
    },
  }),
  h3 = et.create({
    name: "editable",
    addProseMirrorPlugins() {
      return [
        new pt({
          key: new Wt("editable"),
          props: { editable: () => this.editor.options.editable },
        }),
      ];
    },
  }),
  m3 = et.create({
    name: "focusEvents",
    addProseMirrorPlugins() {
      const { editor: t } = this;
      return [
        new pt({
          key: new Wt("focusEvents"),
          props: {
            handleDOMEvents: {
              focus: (e, n) => {
                t.isFocused = !0;
                const r = t.state.tr
                  .setMeta("focus", { event: n })
                  .setMeta("addToHistory", !1);
                return e.dispatch(r), !1;
              },
              blur: (e, n) => {
                t.isFocused = !1;
                const r = t.state.tr
                  .setMeta("blur", { event: n })
                  .setMeta("addToHistory", !1);
                return e.dispatch(r), !1;
              },
            },
          },
        }),
      ];
    },
  }),
  g3 = et.create({
    name: "keymap",
    addKeyboardShortcuts() {
      const t = () =>
          this.editor.commands.first(({ commands: l }) => [
            () => l.undoInputRule(),
            () =>
              l.command(({ tr: u }) => {
                const { selection: c, doc: f } = u,
                  { empty: p, $anchor: m } = c,
                  { pos: y, parent: v } = m,
                  x = m.parent.isTextblock && y > 0 ? u.doc.resolve(y - 1) : m,
                  S = x.parent.type.spec.isolating,
                  C = m.pos - m.parentOffset,
                  E =
                    S && x.parent.childCount === 1
                      ? C === m.pos
                      : Ae.atStart(f).from === y;
                return !p ||
                  !v.type.isTextblock ||
                  v.textContent.length ||
                  !E ||
                  (E && m.parent.type.name === "paragraph")
                  ? !1
                  : l.clearNodes();
              }),
            () => l.deleteSelection(),
            () => l.joinBackward(),
            () => l.selectNodeBackward(),
          ]),
        e = () =>
          this.editor.commands.first(({ commands: l }) => [
            () => l.deleteSelection(),
            () => l.deleteCurrentNode(),
            () => l.joinForward(),
            () => l.selectNodeForward(),
          ]),
        r = {
          Enter: () =>
            this.editor.commands.first(({ commands: l }) => [
              () => l.newlineInCode(),
              () => l.createParagraphNear(),
              () => l.liftEmptyBlock(),
              () => l.splitBlock(),
            ]),
          "Mod-Enter": () => this.editor.commands.exitCode(),
          Backspace: t,
          "Mod-Backspace": t,
          "Shift-Backspace": t,
          Delete: e,
          "Mod-Delete": e,
          "Mod-a": () => this.editor.commands.selectAll(),
        },
        o = { ...r },
        i = {
          ...r,
          "Ctrl-h": t,
          "Alt-Backspace": t,
          "Ctrl-d": e,
          "Ctrl-Alt-Backspace": e,
          "Alt-Delete": e,
          "Alt-d": e,
          "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
          "Ctrl-e": () => this.editor.commands.selectTextblockEnd(),
        };
      return Sg() || kS() ? i : o;
    },
    addProseMirrorPlugins() {
      return [
        new pt({
          key: new Wt("clearDocument"),
          appendTransaction: (t, e, n) => {
            if (t.some((S) => S.getMeta("composition"))) return;
            const r = t.some((S) => S.docChanged) && !e.doc.eq(n.doc),
              o = t.some((S) => S.getMeta("preventClearDocument"));
            if (!r || o) return;
            const { empty: i, from: l, to: u } = e.selection,
              c = Ae.atStart(e.doc).from,
              f = Ae.atEnd(e.doc).to;
            if (i || !(l === c && u === f) || !Eg(n.doc)) return;
            const y = n.tr,
              v = Ud({ state: n, transaction: y }),
              { commands: x } = new Kd({ editor: this.editor, state: v });
            if ((x.clearNodes(), !!y.steps.length)) return y;
          },
        }),
      ];
    },
  }),
  y3 = et.create({
    name: "paste",
    addProseMirrorPlugins() {
      return [
        new pt({
          key: new Wt("tiptapPaste"),
          props: {
            handlePaste: (t, e, n) => {
              this.editor.emit("paste", {
                editor: this.editor,
                event: e,
                slice: n,
              });
            },
          },
        }),
      ];
    },
  }),
  v3 = et.create({
    name: "tabindex",
    addProseMirrorPlugins() {
      return [
        new pt({
          key: new Wt("tabindex"),
          props: {
            attributes: () => (this.editor.isEditable ? { tabindex: "0" } : {}),
          },
        }),
      ];
    },
  });
class Si {
  get name() {
    return this.node.type.name;
  }
  constructor(e, n, r = !1, o = null) {
    (this.currentNode = null),
      (this.actualDepth = null),
      (this.isBlock = r),
      (this.resolvedPos = e),
      (this.editor = n),
      (this.currentNode = o);
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var e;
    return (e = this.actualDepth) !== null && e !== void 0
      ? e
      : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(e) {
    let n = this.from,
      r = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(
          `You cant set content on a block node. Tried to set content on ${this.name} at ${this.pos}`
        );
        return;
      }
      (n = this.from + 1), (r = this.to - 1);
    }
    this.editor.commands.insertContentAt({ from: n, to: r }, e);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    return this.isBlock
      ? this.pos
      : this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return { from: this.from, to: this.to };
  }
  get to() {
    return this.isBlock
      ? this.pos + this.size
      : this.resolvedPos.end(this.resolvedPos.depth) +
          (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0) return null;
    const e = this.resolvedPos.start(this.resolvedPos.depth - 1),
      n = this.resolvedPos.doc.resolve(e);
    return new Si(n, this.editor);
  }
  get before() {
    let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    return (
      e.depth !== this.depth &&
        (e = this.resolvedPos.doc.resolve(this.from - 3)),
      new Si(e, this.editor)
    );
  }
  get after() {
    let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    return (
      e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)),
      new Si(e, this.editor)
    );
  }
  get children() {
    const e = [];
    return (
      this.node.content.forEach((n, r) => {
        const o = n.isBlock && !n.isTextblock,
          i = n.isAtom && !n.isText,
          l = this.pos + r + (i ? 0 : 1),
          u = this.resolvedPos.doc.resolve(l);
        if (!o && u.depth <= this.depth) return;
        const c = new Si(u, this.editor, o, o ? n : null);
        o && (c.actualDepth = this.depth + 1),
          e.push(new Si(u, this.editor, o, o ? n : null));
      }),
      e
    );
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const e = this.children;
    return e[e.length - 1] || null;
  }
  closest(e, n = {}) {
    let r = null,
      o = this.parent;
    for (; o && !r; ) {
      if (o.node.type.name === e)
        if (Object.keys(n).length > 0) {
          const i = o.node.attrs,
            l = Object.keys(n);
          for (let u = 0; u < l.length; u += 1) {
            const c = l[u];
            if (i[c] !== n[c]) break;
          }
        } else r = o;
      o = o.parent;
    }
    return r;
  }
  querySelector(e, n = {}) {
    return this.querySelectorAll(e, n, !0)[0] || null;
  }
  querySelectorAll(e, n = {}, r = !1) {
    let o = [];
    if (!this.children || this.children.length === 0) return o;
    const i = Object.keys(n);
    return (
      this.children.forEach((l) => {
        (r && o.length > 0) ||
          (l.node.type.name === e &&
            i.every((c) => n[c] === l.node.attrs[c]) &&
            o.push(l),
          !(r && o.length > 0) && (o = o.concat(l.querySelectorAll(e, n, r))));
      }),
      o
    );
  }
  setAttribute(e) {
    const { tr: n } = this.editor.state;
    n.setNodeMarkup(this.from, void 0, { ...this.node.attrs, ...e }),
      this.editor.view.dispatch(n);
  }
}
const w3 = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function x3(t, e, n) {
  const r = document.querySelector("style[data-tiptap-style]");
  if (r !== null) return r;
  const o = document.createElement("style");
  return (
    e && o.setAttribute("nonce", e),
    o.setAttribute("data-tiptap-style", ""),
    (o.innerHTML = t),
    document.getElementsByTagName("head")[0].appendChild(o),
    o
  );
}
class b3 extends RA {
  constructor(e = {}) {
    super(),
      (this.isFocused = !1),
      (this.isInitialized = !1),
      (this.extensionStorage = {}),
      (this.options = {
        element: document.createElement("div"),
        content: "",
        injectCSS: !0,
        injectNonce: void 0,
        extensions: [],
        autofocus: !1,
        editable: !0,
        editorProps: {},
        parseOptions: {},
        coreExtensionOptions: {},
        enableInputRules: !0,
        enablePasteRules: !0,
        enableCoreExtensions: !0,
        enableContentCheck: !1,
        onBeforeCreate: () => null,
        onCreate: () => null,
        onUpdate: () => null,
        onSelectionUpdate: () => null,
        onTransaction: () => null,
        onFocus: () => null,
        onBlur: () => null,
        onDestroy: () => null,
        onContentError: ({ error: n }) => {
          throw n;
        },
        onPaste: () => null,
        onDrop: () => null,
      }),
      (this.isCapturingTransaction = !1),
      (this.capturedTransaction = null),
      this.setOptions(e),
      this.createExtensionManager(),
      this.createCommandManager(),
      this.createSchema(),
      this.on("beforeCreate", this.options.onBeforeCreate),
      this.emit("beforeCreate", { editor: this }),
      this.on("contentError", this.options.onContentError),
      this.createView(),
      this.injectCSS(),
      this.on("create", this.options.onCreate),
      this.on("update", this.options.onUpdate),
      this.on("selectionUpdate", this.options.onSelectionUpdate),
      this.on("transaction", this.options.onTransaction),
      this.on("focus", this.options.onFocus),
      this.on("blur", this.options.onBlur),
      this.on("destroy", this.options.onDestroy),
      this.on("drop", ({ event: n, slice: r, moved: o }) =>
        this.options.onDrop(n, r, o)
      ),
      this.on("paste", ({ event: n, slice: r }) => this.options.onPaste(n, r)),
      window.setTimeout(() => {
        this.isDestroyed ||
          (this.commands.focus(this.options.autofocus),
          this.emit("create", { editor: this }),
          (this.isInitialized = !0));
      }, 0);
  }
  get storage() {
    return this.extensionStorage;
  }
  get commands() {
    return this.commandManager.commands;
  }
  chain() {
    return this.commandManager.chain();
  }
  can() {
    return this.commandManager.can();
  }
  injectCSS() {
    this.options.injectCSS &&
      document &&
      (this.css = x3(w3, this.options.injectNonce));
  }
  setOptions(e = {}) {
    (this.options = { ...this.options, ...e }),
      !(!this.view || !this.state || this.isDestroyed) &&
        (this.options.editorProps &&
          this.view.setProps(this.options.editorProps),
        this.view.updateState(this.state));
  }
  setEditable(e, n = !0) {
    this.setOptions({ editable: e }),
      n && this.emit("update", { editor: this, transaction: this.state.tr });
  }
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  get state() {
    return this.view.state;
  }
  registerPlugin(e, n) {
    const r = wS(n)
        ? n(e, [...this.state.plugins])
        : [...this.state.plugins, e],
      o = this.state.reconfigure({ plugins: r });
    return this.view.updateState(o), o;
  }
  unregisterPlugin(e) {
    if (this.isDestroyed) return;
    const n = this.state.plugins;
    let r = n;
    if (
      ([].concat(e).forEach((i) => {
        const l = typeof i == "string" ? `${i}$` : i.key;
        r = n.filter((u) => !u.key.startsWith(l));
      }),
      n.length === r.length)
    )
      return;
    const o = this.state.reconfigure({ plugins: r });
    return this.view.updateState(o), o;
  }
  createExtensionManager() {
    var e, n;
    const o = [
      ...(this.options.enableCoreExtensions
        ? [
            h3,
            KA.configure({
              blockSeparator:
                (n =
                  (e = this.options.coreExtensionOptions) === null ||
                  e === void 0
                    ? void 0
                    : e.clipboardTextSerializer) === null || n === void 0
                  ? void 0
                  : n.blockSeparator,
            }),
            f3,
            m3,
            g3,
            v3,
            p3,
            y3,
          ].filter((i) =>
            typeof this.options.enableCoreExtensions == "object"
              ? this.options.enableCoreExtensions[i.name] !== !1
              : !0
          )
        : []),
      ...this.options.extensions,
    ].filter((i) =>
      ["extension", "node", "mark"].includes(i == null ? void 0 : i.type)
    );
    this.extensionManager = new Is(o, this);
  }
  createCommandManager() {
    this.commandManager = new Kd({ editor: this });
  }
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  createView() {
    var e;
    let n;
    try {
      n = bm(this.options.content, this.schema, this.options.parseOptions, {
        errorOnInvalidContent: this.options.enableContentCheck,
      });
    } catch (l) {
      if (
        !(l instanceof Error) ||
        ![
          "[tiptap error]: Invalid JSON content",
          "[tiptap error]: Invalid HTML content",
        ].includes(l.message)
      )
        throw l;
      this.emit("contentError", {
        editor: this,
        error: l,
        disableCollaboration: () => {
          this.storage.collaboration &&
            (this.storage.collaboration.isDisabled = !0),
            (this.options.extensions = this.options.extensions.filter(
              (u) => u.name !== "collaboration"
            )),
            this.createExtensionManager();
        },
      }),
        (n = bm(this.options.content, this.schema, this.options.parseOptions, {
          errorOnInvalidContent: !1,
        }));
    }
    const r = SS(n, this.options.autofocus);
    this.view = new JN(this.options.element, {
      ...this.options.editorProps,
      attributes: {
        role: "textbox",
        ...((e = this.options.editorProps) === null || e === void 0
          ? void 0
          : e.attributes),
      },
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: Ds.create({ doc: n, selection: r || void 0 }),
    });
    const o = this.state.reconfigure({
      plugins: this.extensionManager.plugins,
    });
    this.view.updateState(o), this.createNodeViews(), this.prependClass();
    const i = this.view.dom;
    i.editor = this;
  }
  createNodeViews() {
    this.view.isDestroyed ||
      this.view.setProps({ nodeViews: this.extensionManager.nodeViews });
  }
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`;
  }
  captureTransaction(e) {
    (this.isCapturingTransaction = !0), e(), (this.isCapturingTransaction = !1);
    const n = this.capturedTransaction;
    return (this.capturedTransaction = null), n;
  }
  dispatchTransaction(e) {
    if (this.view.isDestroyed) return;
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = e;
        return;
      }
      e.steps.forEach((l) => {
        var u;
        return (u = this.capturedTransaction) === null || u === void 0
          ? void 0
          : u.step(l);
      });
      return;
    }
    const n = this.state.apply(e),
      r = !this.state.selection.eq(n.selection);
    this.emit("beforeTransaction", {
      editor: this,
      transaction: e,
      nextState: n,
    }),
      this.view.updateState(n),
      this.emit("transaction", { editor: this, transaction: e }),
      r && this.emit("selectionUpdate", { editor: this, transaction: e });
    const o = e.getMeta("focus"),
      i = e.getMeta("blur");
    o && this.emit("focus", { editor: this, event: o.event, transaction: e }),
      i && this.emit("blur", { editor: this, event: i.event, transaction: e }),
      !(!e.docChanged || e.getMeta("preventUpdate")) &&
        this.emit("update", { editor: this, transaction: e });
  }
  getAttributes(e) {
    return OS(this.state, e);
  }
  isActive(e, n) {
    const r = typeof e == "string" ? e : null,
      o = typeof e == "string" ? n : e;
    return UR(this.state, r, o);
  }
  getJSON() {
    return this.state.doc.toJSON();
  }
  getHTML() {
    return yg(this.state.doc.content, this.schema);
  }
  getText(e) {
    const {
      blockSeparator: n = `

`,
      textSerializers: r = {},
    } = e || {};
    return MS(this.state.doc, {
      blockSeparator: n,
      textSerializers: { ...wg(this.schema), ...r },
    });
  }
  get isEmpty() {
    return Eg(this.state.doc);
  }
  getCharacterCount() {
    return (
      console.warn(
        '[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'
      ),
      this.state.doc.content.size - 2
    );
  }
  destroy() {
    if ((this.emit("destroy"), this.view)) {
      const e = this.view.dom;
      e && e.editor && delete e.editor, this.view.destroy();
    }
    this.removeAllListeners();
  }
  get isDestroyed() {
    var e;
    return !(!((e = this.view) === null || e === void 0) && e.docView);
  }
  $node(e, n) {
    var r;
    return (
      ((r = this.$doc) === null || r === void 0
        ? void 0
        : r.querySelector(e, n)) || null
    );
  }
  $nodes(e, n) {
    var r;
    return (
      ((r = this.$doc) === null || r === void 0
        ? void 0
        : r.querySelectorAll(e, n)) || null
    );
  }
  $pos(e) {
    const n = this.state.doc.resolve(e);
    return new Si(n, this);
  }
  get $doc() {
    return this.$pos(0);
  }
}
function qs(t) {
  return new Fa({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const o = Pe(t.getAttributes, void 0, r);
      if (o === !1 || o === null) return null;
      const { tr: i } = e,
        l = r[r.length - 1],
        u = r[0];
      if (l) {
        const c = u.search(/\S/),
          f = n.from + u.indexOf(l),
          p = f + l.length;
        if (
          kg(n.from, n.to, e.doc)
            .filter((v) =>
              v.mark.type.excluded.find(
                (S) => S === t.type && S !== v.mark.type
              )
            )
            .filter((v) => v.to > f).length
        )
          return null;
        p < n.to && i.delete(p, n.to), f > n.from && i.delete(n.from + c, f);
        const y = n.from + c + l.length;
        i.addMark(n.from + c, y, t.type.create(o || {})),
          i.removeStoredMark(t.type);
      }
    },
  });
}
function S3(t) {
  return new Fa({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const o = Pe(t.getAttributes, void 0, r) || {},
        { tr: i } = e,
        l = n.from;
      let u = n.to;
      const c = t.type.create(o);
      if (r[1]) {
        const f = r[0].lastIndexOf(r[1]);
        let p = l + f;
        p > u ? (p = u) : (u = p + r[1].length);
        const m = r[0][r[0].length - 1];
        i.insertText(m, l + r[0].length - 1), i.replaceWith(p, u, c);
      } else if (r[0]) {
        const f = t.type.isInline ? l : l - 1;
        i.insert(f, t.type.create(o)).delete(
          i.mapping.map(l),
          i.mapping.map(u)
        );
      }
      i.scrollIntoView();
    },
  });
}
function Cm(t) {
  return new Fa({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const o = e.doc.resolve(n.from),
        i = Pe(t.getAttributes, void 0, r) || {};
      if (!o.node(-1).canReplaceWith(o.index(-1), o.indexAfter(-1), t.type))
        return null;
      e.tr.delete(n.from, n.to).setBlockType(n.from, n.from, t.type, i);
    },
  });
}
function tt(t) {
  return new Fa({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      let o = t.replace,
        i = n.from;
      const l = n.to;
      if (r[1]) {
        const u = r[0].lastIndexOf(r[1]);
        (o += r[0].slice(u + r[1].length)), (i += u);
        const c = i - l;
        c > 0 && ((o = r[0].slice(u - c, u) + o), (i = l));
      }
      e.tr.insertText(o, i, l);
    },
  });
}
function ka(t) {
  return new Fa({
    find: t.find,
    handler: ({ state: e, range: n, match: r, chain: o }) => {
      const i = Pe(t.getAttributes, void 0, r) || {},
        l = e.tr.delete(n.from, n.to),
        c = l.doc.resolve(n.from).blockRange(),
        f = c && og(c, t.type, i);
      if (!f) return null;
      if ((l.wrap(c, f), t.keepMarks && t.editor)) {
        const { selection: m, storedMarks: y } = e,
          { splittableMarks: v } = t.editor.extensionManager,
          x = y || (m.$to.parentOffset && m.$from.marks());
        if (x) {
          const S = x.filter((C) => v.includes(C.type.name));
          l.ensureMarks(S);
        }
      }
      if (t.keepAttributes) {
        const m =
          t.type.name === "bulletList" || t.type.name === "orderedList"
            ? "listItem"
            : "taskList";
        o().updateAttributes(m, i).run();
      }
      const p = l.doc.resolve(n.from - 1).nodeBefore;
      p &&
        p.type === t.type &&
        Ko(l.doc, n.from - 1) &&
        (!t.joinPredicate || t.joinPredicate(r, p)) &&
        l.join(n.from - 1);
    },
  });
}
let Xn = class km {
  constructor(e = {}) {
    (this.type = "node"),
      (this.name = "node"),
      (this.parent = null),
      (this.child = null),
      (this.config = { name: this.name, defaultOptions: {} }),
      (this.config = { ...this.config, ...e }),
      (this.name = this.config.name),
      e.defaultOptions &&
        Object.keys(e.defaultOptions).length > 0 &&
        console.warn(
          `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
        ),
      (this.options = this.config.defaultOptions),
      this.config.addOptions &&
        (this.options = Pe(me(this, "addOptions", { name: this.name }))),
      (this.storage =
        Pe(
          me(this, "addStorage", { name: this.name, options: this.options })
        ) || {});
  }
  static create(e = {}) {
    return new km(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => Gd(this.options, e),
    });
    return (n.name = this.name), (n.parent = this.parent), n;
  }
  extend(e = {}) {
    const n = new km(e);
    return (
      (n.parent = this),
      (this.child = n),
      (n.name = e.name ? e.name : n.parent.name),
      e.defaultOptions &&
        Object.keys(e.defaultOptions).length > 0 &&
        console.warn(
          `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`
        ),
      (n.options = Pe(me(n, "addOptions", { name: n.name }))),
      (n.storage = Pe(
        me(n, "addStorage", { name: n.name, options: n.options })
      )),
      n
    );
  }
};
function _i(t) {
  return new jA({
    find: t.find,
    handler: ({ state: e, range: n, match: r, pasteEvent: o }) => {
      const i = Pe(t.getAttributes, void 0, r, o);
      if (i === !1 || i === null) return null;
      const { tr: l } = e,
        u = r[r.length - 1],
        c = r[0];
      let f = n.to;
      if (u) {
        const p = c.search(/\S/),
          m = n.from + c.indexOf(u),
          y = m + u.length;
        if (
          kg(n.from, n.to, e.doc)
            .filter((x) =>
              x.mark.type.excluded.find(
                (C) => C === t.type && C !== x.mark.type
              )
            )
            .filter((x) => x.to > m).length
        )
          return null;
        y < n.to && l.delete(y, n.to),
          m > n.from && l.delete(n.from + p, m),
          (f = n.from + p + u.length),
          l.addMark(n.from + p, f, t.type.create(i || {})),
          l.removeStoredMark(t.type);
      }
    },
  });
}
var nn = "top",
  Dn = "bottom",
  In = "right",
  rn = "left",
  Mg = "auto",
  za = [nn, Dn, In, rn],
  Gs = "start",
  Ea = "end",
  C3 = "clippingParents",
  AS = "viewport",
  Ul = "popper",
  k3 = "reference",
  Mw = za.reduce(function (t, e) {
    return t.concat([e + "-" + Gs, e + "-" + Ea]);
  }, []),
  RS = [].concat(za, [Mg]).reduce(function (t, e) {
    return t.concat([e, e + "-" + Gs, e + "-" + Ea]);
  }, []),
  E3 = "beforeRead",
  M3 = "read",
  O3 = "afterRead",
  T3 = "beforeMain",
  N3 = "main",
  A3 = "afterMain",
  R3 = "beforeWrite",
  P3 = "write",
  D3 = "afterWrite",
  I3 = [E3, M3, O3, T3, N3, A3, R3, P3, D3];
function vr(t) {
  return t ? (t.nodeName || "").toLowerCase() : null;
}
function yn(t) {
  if (t == null) return window;
  if (t.toString() !== "[object Window]") {
    var e = t.ownerDocument;
    return (e && e.defaultView) || window;
  }
  return t;
}
function Fi(t) {
  var e = yn(t).Element;
  return t instanceof e || t instanceof Element;
}
function Rn(t) {
  var e = yn(t).HTMLElement;
  return t instanceof e || t instanceof HTMLElement;
}
function Og(t) {
  if (typeof ShadowRoot > "u") return !1;
  var e = yn(t).ShadowRoot;
  return t instanceof e || t instanceof ShadowRoot;
}
function L3(t) {
  var e = t.state;
  Object.keys(e.elements).forEach(function (n) {
    var r = e.styles[n] || {},
      o = e.attributes[n] || {},
      i = e.elements[n];
    !Rn(i) ||
      !vr(i) ||
      (Object.assign(i.style, r),
      Object.keys(o).forEach(function (l) {
        var u = o[l];
        u === !1 ? i.removeAttribute(l) : i.setAttribute(l, u === !0 ? "" : u);
      }));
  });
}
function $3(t) {
  var e = t.state,
    n = {
      popper: {
        position: e.options.strategy,
        left: "0",
        top: "0",
        margin: "0",
      },
      arrow: { position: "absolute" },
      reference: {},
    };
  return (
    Object.assign(e.elements.popper.style, n.popper),
    (e.styles = n),
    e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow),
    function () {
      Object.keys(e.elements).forEach(function (r) {
        var o = e.elements[r],
          i = e.attributes[r] || {},
          l = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]),
          u = l.reduce(function (c, f) {
            return (c[f] = ""), c;
          }, {});
        !Rn(o) ||
          !vr(o) ||
          (Object.assign(o.style, u),
          Object.keys(i).forEach(function (c) {
            o.removeAttribute(c);
          }));
      });
    }
  );
}
const PS = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: L3,
  effect: $3,
  requires: ["computeStyles"],
};
function hr(t) {
  return t.split("-")[0];
}
var Pi = Math.max,
  Yc = Math.min,
  Js = Math.round;
function Em() {
  var t = navigator.userAgentData;
  return t != null && t.brands && Array.isArray(t.brands)
    ? t.brands
        .map(function (e) {
          return e.brand + "/" + e.version;
        })
        .join(" ")
    : navigator.userAgent;
}
function DS() {
  return !/^((?!chrome|android).)*safari/i.test(Em());
}
function Qs(t, e, n) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  var r = t.getBoundingClientRect(),
    o = 1,
    i = 1;
  e &&
    Rn(t) &&
    ((o = (t.offsetWidth > 0 && Js(r.width) / t.offsetWidth) || 1),
    (i = (t.offsetHeight > 0 && Js(r.height) / t.offsetHeight) || 1));
  var l = Fi(t) ? yn(t) : window,
    u = l.visualViewport,
    c = !DS() && n,
    f = (r.left + (c && u ? u.offsetLeft : 0)) / o,
    p = (r.top + (c && u ? u.offsetTop : 0)) / i,
    m = r.width / o,
    y = r.height / i;
  return {
    width: m,
    height: y,
    top: p,
    right: f + m,
    bottom: p + y,
    left: f,
    x: f,
    y: p,
  };
}
function Tg(t) {
  var e = Qs(t),
    n = t.offsetWidth,
    r = t.offsetHeight;
  return (
    Math.abs(e.width - n) <= 1 && (n = e.width),
    Math.abs(e.height - r) <= 1 && (r = e.height),
    { x: t.offsetLeft, y: t.offsetTop, width: n, height: r }
  );
}
function IS(t, e) {
  var n = e.getRootNode && e.getRootNode();
  if (t.contains(e)) return !0;
  if (n && Og(n)) {
    var r = e;
    do {
      if (r && t.isSameNode(r)) return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function Kr(t) {
  return yn(t).getComputedStyle(t);
}
function _3(t) {
  return ["table", "td", "th"].indexOf(vr(t)) >= 0;
}
function Jo(t) {
  return ((Fi(t) ? t.ownerDocument : t.document) || window.document)
    .documentElement;
}
function Qd(t) {
  return vr(t) === "html"
    ? t
    : t.assignedSlot || t.parentNode || (Og(t) ? t.host : null) || Jo(t);
}
function Ow(t) {
  return !Rn(t) || Kr(t).position === "fixed" ? null : t.offsetParent;
}
function F3(t) {
  var e = /firefox/i.test(Em()),
    n = /Trident/i.test(Em());
  if (n && Rn(t)) {
    var r = Kr(t);
    if (r.position === "fixed") return null;
  }
  var o = Qd(t);
  for (Og(o) && (o = o.host); Rn(o) && ["html", "body"].indexOf(vr(o)) < 0; ) {
    var i = Kr(o);
    if (
      i.transform !== "none" ||
      i.perspective !== "none" ||
      i.contain === "paint" ||
      ["transform", "perspective"].indexOf(i.willChange) !== -1 ||
      (e && i.willChange === "filter") ||
      (e && i.filter && i.filter !== "none")
    )
      return o;
    o = o.parentNode;
  }
  return null;
}
function ja(t) {
  for (var e = yn(t), n = Ow(t); n && _3(n) && Kr(n).position === "static"; )
    n = Ow(n);
  return n &&
    (vr(n) === "html" || (vr(n) === "body" && Kr(n).position === "static"))
    ? e
    : n || F3(t) || e;
}
function Ng(t) {
  return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
}
function oa(t, e, n) {
  return Pi(t, Yc(e, n));
}
function z3(t, e, n) {
  var r = oa(t, e, n);
  return r > n ? n : r;
}
function LS() {
  return { top: 0, right: 0, bottom: 0, left: 0 };
}
function $S(t) {
  return Object.assign({}, LS(), t);
}
function _S(t, e) {
  return e.reduce(function (n, r) {
    return (n[r] = t), n;
  }, {});
}
var j3 = function (e, n) {
  return (
    (e =
      typeof e == "function"
        ? e(Object.assign({}, n.rects, { placement: n.placement }))
        : e),
    $S(typeof e != "number" ? e : _S(e, za))
  );
};
function B3(t) {
  var e,
    n = t.state,
    r = t.name,
    o = t.options,
    i = n.elements.arrow,
    l = n.modifiersData.popperOffsets,
    u = hr(n.placement),
    c = Ng(u),
    f = [rn, In].indexOf(u) >= 0,
    p = f ? "height" : "width";
  if (!(!i || !l)) {
    var m = j3(o.padding, n),
      y = Tg(i),
      v = c === "y" ? nn : rn,
      x = c === "y" ? Dn : In,
      S =
        n.rects.reference[p] + n.rects.reference[c] - l[c] - n.rects.popper[p],
      C = l[c] - n.rects.reference[c],
      E = ja(i),
      N = E ? (c === "y" ? E.clientHeight || 0 : E.clientWidth || 0) : 0,
      $ = S / 2 - C / 2,
      M = m[v],
      I = N - y[p] - m[x],
      R = N / 2 - y[p] / 2 + $,
      F = oa(M, R, I),
      H = c;
    n.modifiersData[r] = ((e = {}), (e[H] = F), (e.centerOffset = F - R), e);
  }
}
function H3(t) {
  var e = t.state,
    n = t.options,
    r = n.element,
    o = r === void 0 ? "[data-popper-arrow]" : r;
  o != null &&
    ((typeof o == "string" && ((o = e.elements.popper.querySelector(o)), !o)) ||
      (IS(e.elements.popper, o) && (e.elements.arrow = o)));
}
const V3 = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: B3,
  effect: H3,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"],
};
function Ys(t) {
  return t.split("-")[1];
}
var W3 = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
function U3(t, e) {
  var n = t.x,
    r = t.y,
    o = e.devicePixelRatio || 1;
  return { x: Js(n * o) / o || 0, y: Js(r * o) / o || 0 };
}
function Tw(t) {
  var e,
    n = t.popper,
    r = t.popperRect,
    o = t.placement,
    i = t.variation,
    l = t.offsets,
    u = t.position,
    c = t.gpuAcceleration,
    f = t.adaptive,
    p = t.roundOffsets,
    m = t.isFixed,
    y = l.x,
    v = y === void 0 ? 0 : y,
    x = l.y,
    S = x === void 0 ? 0 : x,
    C = typeof p == "function" ? p({ x: v, y: S }) : { x: v, y: S };
  (v = C.x), (S = C.y);
  var E = l.hasOwnProperty("x"),
    N = l.hasOwnProperty("y"),
    $ = rn,
    M = nn,
    I = window;
  if (f) {
    var R = ja(n),
      F = "clientHeight",
      H = "clientWidth";
    if (
      (R === yn(n) &&
        ((R = Jo(n)),
        Kr(R).position !== "static" &&
          u === "absolute" &&
          ((F = "scrollHeight"), (H = "scrollWidth"))),
      (R = R),
      o === nn || ((o === rn || o === In) && i === Ea))
    ) {
      M = Dn;
      var U = m && R === I && I.visualViewport ? I.visualViewport.height : R[F];
      (S -= U - r.height), (S *= c ? 1 : -1);
    }
    if (o === rn || ((o === nn || o === Dn) && i === Ea)) {
      $ = In;
      var re = m && R === I && I.visualViewport ? I.visualViewport.width : R[H];
      (v -= re - r.width), (v *= c ? 1 : -1);
    }
  }
  var ce = Object.assign({ position: u }, f && W3),
    ee = p === !0 ? U3({ x: v, y: S }, yn(n)) : { x: v, y: S };
  if (((v = ee.x), (S = ee.y), c)) {
    var le;
    return Object.assign(
      {},
      ce,
      ((le = {}),
      (le[M] = N ? "0" : ""),
      (le[$] = E ? "0" : ""),
      (le.transform =
        (I.devicePixelRatio || 1) <= 1
          ? "translate(" + v + "px, " + S + "px)"
          : "translate3d(" + v + "px, " + S + "px, 0)"),
      le)
    );
  }
  return Object.assign(
    {},
    ce,
    ((e = {}),
    (e[M] = N ? S + "px" : ""),
    (e[$] = E ? v + "px" : ""),
    (e.transform = ""),
    e)
  );
}
function K3(t) {
  var e = t.state,
    n = t.options,
    r = n.gpuAcceleration,
    o = r === void 0 ? !0 : r,
    i = n.adaptive,
    l = i === void 0 ? !0 : i,
    u = n.roundOffsets,
    c = u === void 0 ? !0 : u,
    f = {
      placement: hr(e.placement),
      variation: Ys(e.placement),
      popper: e.elements.popper,
      popperRect: e.rects.popper,
      gpuAcceleration: o,
      isFixed: e.options.strategy === "fixed",
    };
  e.modifiersData.popperOffsets != null &&
    (e.styles.popper = Object.assign(
      {},
      e.styles.popper,
      Tw(
        Object.assign({}, f, {
          offsets: e.modifiersData.popperOffsets,
          position: e.options.strategy,
          adaptive: l,
          roundOffsets: c,
        })
      )
    )),
    e.modifiersData.arrow != null &&
      (e.styles.arrow = Object.assign(
        {},
        e.styles.arrow,
        Tw(
          Object.assign({}, f, {
            offsets: e.modifiersData.arrow,
            position: "absolute",
            adaptive: !1,
            roundOffsets: c,
          })
        )
      )),
    (e.attributes.popper = Object.assign({}, e.attributes.popper, {
      "data-popper-placement": e.placement,
    }));
}
const q3 = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: K3,
  data: {},
};
var fc = { passive: !0 };
function G3(t) {
  var e = t.state,
    n = t.instance,
    r = t.options,
    o = r.scroll,
    i = o === void 0 ? !0 : o,
    l = r.resize,
    u = l === void 0 ? !0 : l,
    c = yn(e.elements.popper),
    f = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return (
    i &&
      f.forEach(function (p) {
        p.addEventListener("scroll", n.update, fc);
      }),
    u && c.addEventListener("resize", n.update, fc),
    function () {
      i &&
        f.forEach(function (p) {
          p.removeEventListener("scroll", n.update, fc);
        }),
        u && c.removeEventListener("resize", n.update, fc);
    }
  );
}
const J3 = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function () {},
  effect: G3,
  data: {},
};
var Q3 = { left: "right", right: "left", bottom: "top", top: "bottom" };
function Dc(t) {
  return t.replace(/left|right|bottom|top/g, function (e) {
    return Q3[e];
  });
}
var Y3 = { start: "end", end: "start" };
function Nw(t) {
  return t.replace(/start|end/g, function (e) {
    return Y3[e];
  });
}
function Ag(t) {
  var e = yn(t),
    n = e.pageXOffset,
    r = e.pageYOffset;
  return { scrollLeft: n, scrollTop: r };
}
function Rg(t) {
  return Qs(Jo(t)).left + Ag(t).scrollLeft;
}
function X3(t, e) {
  var n = yn(t),
    r = Jo(t),
    o = n.visualViewport,
    i = r.clientWidth,
    l = r.clientHeight,
    u = 0,
    c = 0;
  if (o) {
    (i = o.width), (l = o.height);
    var f = DS();
    (f || (!f && e === "fixed")) && ((u = o.offsetLeft), (c = o.offsetTop));
  }
  return { width: i, height: l, x: u + Rg(t), y: c };
}
function Z3(t) {
  var e,
    n = Jo(t),
    r = Ag(t),
    o = (e = t.ownerDocument) == null ? void 0 : e.body,
    i = Pi(
      n.scrollWidth,
      n.clientWidth,
      o ? o.scrollWidth : 0,
      o ? o.clientWidth : 0
    ),
    l = Pi(
      n.scrollHeight,
      n.clientHeight,
      o ? o.scrollHeight : 0,
      o ? o.clientHeight : 0
    ),
    u = -r.scrollLeft + Rg(t),
    c = -r.scrollTop;
  return (
    Kr(o || n).direction === "rtl" &&
      (u += Pi(n.clientWidth, o ? o.clientWidth : 0) - i),
    { width: i, height: l, x: u, y: c }
  );
}
function Pg(t) {
  var e = Kr(t),
    n = e.overflow,
    r = e.overflowX,
    o = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + o + r);
}
function FS(t) {
  return ["html", "body", "#document"].indexOf(vr(t)) >= 0
    ? t.ownerDocument.body
    : Rn(t) && Pg(t)
    ? t
    : FS(Qd(t));
}
function ia(t, e) {
  var n;
  e === void 0 && (e = []);
  var r = FS(t),
    o = r === ((n = t.ownerDocument) == null ? void 0 : n.body),
    i = yn(r),
    l = o ? [i].concat(i.visualViewport || [], Pg(r) ? r : []) : r,
    u = e.concat(l);
  return o ? u : u.concat(ia(Qd(l)));
}
function Mm(t) {
  return Object.assign({}, t, {
    left: t.x,
    top: t.y,
    right: t.x + t.width,
    bottom: t.y + t.height,
  });
}
function eP(t, e) {
  var n = Qs(t, !1, e === "fixed");
  return (
    (n.top = n.top + t.clientTop),
    (n.left = n.left + t.clientLeft),
    (n.bottom = n.top + t.clientHeight),
    (n.right = n.left + t.clientWidth),
    (n.width = t.clientWidth),
    (n.height = t.clientHeight),
    (n.x = n.left),
    (n.y = n.top),
    n
  );
}
function Aw(t, e, n) {
  return e === AS ? Mm(X3(t, n)) : Fi(e) ? eP(e, n) : Mm(Z3(Jo(t)));
}
function tP(t) {
  var e = ia(Qd(t)),
    n = ["absolute", "fixed"].indexOf(Kr(t).position) >= 0,
    r = n && Rn(t) ? ja(t) : t;
  return Fi(r)
    ? e.filter(function (o) {
        return Fi(o) && IS(o, r) && vr(o) !== "body";
      })
    : [];
}
function nP(t, e, n, r) {
  var o = e === "clippingParents" ? tP(t) : [].concat(e),
    i = [].concat(o, [n]),
    l = i[0],
    u = i.reduce(function (c, f) {
      var p = Aw(t, f, r);
      return (
        (c.top = Pi(p.top, c.top)),
        (c.right = Yc(p.right, c.right)),
        (c.bottom = Yc(p.bottom, c.bottom)),
        (c.left = Pi(p.left, c.left)),
        c
      );
    }, Aw(t, l, r));
  return (
    (u.width = u.right - u.left),
    (u.height = u.bottom - u.top),
    (u.x = u.left),
    (u.y = u.top),
    u
  );
}
function zS(t) {
  var e = t.reference,
    n = t.element,
    r = t.placement,
    o = r ? hr(r) : null,
    i = r ? Ys(r) : null,
    l = e.x + e.width / 2 - n.width / 2,
    u = e.y + e.height / 2 - n.height / 2,
    c;
  switch (o) {
    case nn:
      c = { x: l, y: e.y - n.height };
      break;
    case Dn:
      c = { x: l, y: e.y + e.height };
      break;
    case In:
      c = { x: e.x + e.width, y: u };
      break;
    case rn:
      c = { x: e.x - n.width, y: u };
      break;
    default:
      c = { x: e.x, y: e.y };
  }
  var f = o ? Ng(o) : null;
  if (f != null) {
    var p = f === "y" ? "height" : "width";
    switch (i) {
      case Gs:
        c[f] = c[f] - (e[p] / 2 - n[p] / 2);
        break;
      case Ea:
        c[f] = c[f] + (e[p] / 2 - n[p] / 2);
        break;
    }
  }
  return c;
}
function Ma(t, e) {
  e === void 0 && (e = {});
  var n = e,
    r = n.placement,
    o = r === void 0 ? t.placement : r,
    i = n.strategy,
    l = i === void 0 ? t.strategy : i,
    u = n.boundary,
    c = u === void 0 ? C3 : u,
    f = n.rootBoundary,
    p = f === void 0 ? AS : f,
    m = n.elementContext,
    y = m === void 0 ? Ul : m,
    v = n.altBoundary,
    x = v === void 0 ? !1 : v,
    S = n.padding,
    C = S === void 0 ? 0 : S,
    E = $S(typeof C != "number" ? C : _S(C, za)),
    N = y === Ul ? k3 : Ul,
    $ = t.rects.popper,
    M = t.elements[x ? N : y],
    I = nP(Fi(M) ? M : M.contextElement || Jo(t.elements.popper), c, p, l),
    R = Qs(t.elements.reference),
    F = zS({ reference: R, element: $, strategy: "absolute", placement: o }),
    H = Mm(Object.assign({}, $, F)),
    U = y === Ul ? H : R,
    re = {
      top: I.top - U.top + E.top,
      bottom: U.bottom - I.bottom + E.bottom,
      left: I.left - U.left + E.left,
      right: U.right - I.right + E.right,
    },
    ce = t.modifiersData.offset;
  if (y === Ul && ce) {
    var ee = ce[o];
    Object.keys(re).forEach(function (le) {
      var de = [In, Dn].indexOf(le) >= 0 ? 1 : -1,
        xe = [nn, Dn].indexOf(le) >= 0 ? "y" : "x";
      re[le] += ee[xe] * de;
    });
  }
  return re;
}
function rP(t, e) {
  e === void 0 && (e = {});
  var n = e,
    r = n.placement,
    o = n.boundary,
    i = n.rootBoundary,
    l = n.padding,
    u = n.flipVariations,
    c = n.allowedAutoPlacements,
    f = c === void 0 ? RS : c,
    p = Ys(r),
    m = p
      ? u
        ? Mw
        : Mw.filter(function (x) {
            return Ys(x) === p;
          })
      : za,
    y = m.filter(function (x) {
      return f.indexOf(x) >= 0;
    });
  y.length === 0 && (y = m);
  var v = y.reduce(function (x, S) {
    return (
      (x[S] = Ma(t, { placement: S, boundary: o, rootBoundary: i, padding: l })[
        hr(S)
      ]),
      x
    );
  }, {});
  return Object.keys(v).sort(function (x, S) {
    return v[x] - v[S];
  });
}
function oP(t) {
  if (hr(t) === Mg) return [];
  var e = Dc(t);
  return [Nw(t), e, Nw(e)];
}
function iP(t) {
  var e = t.state,
    n = t.options,
    r = t.name;
  if (!e.modifiersData[r]._skip) {
    for (
      var o = n.mainAxis,
        i = o === void 0 ? !0 : o,
        l = n.altAxis,
        u = l === void 0 ? !0 : l,
        c = n.fallbackPlacements,
        f = n.padding,
        p = n.boundary,
        m = n.rootBoundary,
        y = n.altBoundary,
        v = n.flipVariations,
        x = v === void 0 ? !0 : v,
        S = n.allowedAutoPlacements,
        C = e.options.placement,
        E = hr(C),
        N = E === C,
        $ = c || (N || !x ? [Dc(C)] : oP(C)),
        M = [C].concat($).reduce(function (ne, Q) {
          return ne.concat(
            hr(Q) === Mg
              ? rP(e, {
                  placement: Q,
                  boundary: p,
                  rootBoundary: m,
                  padding: f,
                  flipVariations: x,
                  allowedAutoPlacements: S,
                })
              : Q
          );
        }, []),
        I = e.rects.reference,
        R = e.rects.popper,
        F = new Map(),
        H = !0,
        U = M[0],
        re = 0;
      re < M.length;
      re++
    ) {
      var ce = M[re],
        ee = hr(ce),
        le = Ys(ce) === Gs,
        de = [nn, Dn].indexOf(ee) >= 0,
        xe = de ? "width" : "height",
        oe = Ma(e, {
          placement: ce,
          boundary: p,
          rootBoundary: m,
          altBoundary: y,
          padding: f,
        }),
        se = de ? (le ? In : rn) : le ? Dn : nn;
      I[xe] > R[xe] && (se = Dc(se));
      var B = Dc(se),
        V = [];
      if (
        (i && V.push(oe[ee] <= 0),
        u && V.push(oe[se] <= 0, oe[B] <= 0),
        V.every(function (ne) {
          return ne;
        }))
      ) {
        (U = ce), (H = !1);
        break;
      }
      F.set(ce, V);
    }
    if (H)
      for (
        var K = x ? 3 : 1,
          D = function (Q) {
            var ie = M.find(function (he) {
              var we = F.get(he);
              if (we)
                return we.slice(0, Q).every(function (be) {
                  return be;
                });
            });
            if (ie) return (U = ie), "break";
          },
          A = K;
        A > 0;
        A--
      ) {
        var X = D(A);
        if (X === "break") break;
      }
    e.placement !== U &&
      ((e.modifiersData[r]._skip = !0), (e.placement = U), (e.reset = !0));
  }
}
const sP = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: iP,
  requiresIfExists: ["offset"],
  data: { _skip: !1 },
};
function Rw(t, e, n) {
  return (
    n === void 0 && (n = { x: 0, y: 0 }),
    {
      top: t.top - e.height - n.y,
      right: t.right - e.width + n.x,
      bottom: t.bottom - e.height + n.y,
      left: t.left - e.width - n.x,
    }
  );
}
function Pw(t) {
  return [nn, In, Dn, rn].some(function (e) {
    return t[e] >= 0;
  });
}
function lP(t) {
  var e = t.state,
    n = t.name,
    r = e.rects.reference,
    o = e.rects.popper,
    i = e.modifiersData.preventOverflow,
    l = Ma(e, { elementContext: "reference" }),
    u = Ma(e, { altBoundary: !0 }),
    c = Rw(l, r),
    f = Rw(u, o, i),
    p = Pw(c),
    m = Pw(f);
  (e.modifiersData[n] = {
    referenceClippingOffsets: c,
    popperEscapeOffsets: f,
    isReferenceHidden: p,
    hasPopperEscaped: m,
  }),
    (e.attributes.popper = Object.assign({}, e.attributes.popper, {
      "data-popper-reference-hidden": p,
      "data-popper-escaped": m,
    }));
}
const aP = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: lP,
};
function uP(t, e, n) {
  var r = hr(t),
    o = [rn, nn].indexOf(r) >= 0 ? -1 : 1,
    i = typeof n == "function" ? n(Object.assign({}, e, { placement: t })) : n,
    l = i[0],
    u = i[1];
  return (
    (l = l || 0),
    (u = (u || 0) * o),
    [rn, In].indexOf(r) >= 0 ? { x: u, y: l } : { x: l, y: u }
  );
}
function cP(t) {
  var e = t.state,
    n = t.options,
    r = t.name,
    o = n.offset,
    i = o === void 0 ? [0, 0] : o,
    l = RS.reduce(function (p, m) {
      return (p[m] = uP(m, e.rects, i)), p;
    }, {}),
    u = l[e.placement],
    c = u.x,
    f = u.y;
  e.modifiersData.popperOffsets != null &&
    ((e.modifiersData.popperOffsets.x += c),
    (e.modifiersData.popperOffsets.y += f)),
    (e.modifiersData[r] = l);
}
const dP = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: cP,
};
function fP(t) {
  var e = t.state,
    n = t.name;
  e.modifiersData[n] = zS({
    reference: e.rects.reference,
    element: e.rects.popper,
    strategy: "absolute",
    placement: e.placement,
  });
}
const pP = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: fP,
  data: {},
};
function hP(t) {
  return t === "x" ? "y" : "x";
}
function mP(t) {
  var e = t.state,
    n = t.options,
    r = t.name,
    o = n.mainAxis,
    i = o === void 0 ? !0 : o,
    l = n.altAxis,
    u = l === void 0 ? !1 : l,
    c = n.boundary,
    f = n.rootBoundary,
    p = n.altBoundary,
    m = n.padding,
    y = n.tether,
    v = y === void 0 ? !0 : y,
    x = n.tetherOffset,
    S = x === void 0 ? 0 : x,
    C = Ma(e, { boundary: c, rootBoundary: f, padding: m, altBoundary: p }),
    E = hr(e.placement),
    N = Ys(e.placement),
    $ = !N,
    M = Ng(E),
    I = hP(M),
    R = e.modifiersData.popperOffsets,
    F = e.rects.reference,
    H = e.rects.popper,
    U =
      typeof S == "function"
        ? S(Object.assign({}, e.rects, { placement: e.placement }))
        : S,
    re =
      typeof U == "number"
        ? { mainAxis: U, altAxis: U }
        : Object.assign({ mainAxis: 0, altAxis: 0 }, U),
    ce = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null,
    ee = { x: 0, y: 0 };
  if (R) {
    if (i) {
      var le,
        de = M === "y" ? nn : rn,
        xe = M === "y" ? Dn : In,
        oe = M === "y" ? "height" : "width",
        se = R[M],
        B = se + C[de],
        V = se - C[xe],
        K = v ? -H[oe] / 2 : 0,
        D = N === Gs ? F[oe] : H[oe],
        A = N === Gs ? -H[oe] : -F[oe],
        X = e.elements.arrow,
        ne = v && X ? Tg(X) : { width: 0, height: 0 },
        Q = e.modifiersData["arrow#persistent"]
          ? e.modifiersData["arrow#persistent"].padding
          : LS(),
        ie = Q[de],
        he = Q[xe],
        we = oa(0, F[oe], ne[oe]),
        be = $
          ? F[oe] / 2 - K - we - ie - re.mainAxis
          : D - we - ie - re.mainAxis,
        $e = $
          ? -F[oe] / 2 + K + we + he + re.mainAxis
          : A + we + he + re.mainAxis,
        Kt = e.elements.arrow && ja(e.elements.arrow),
        tr = Kt ? (M === "y" ? Kt.clientTop || 0 : Kt.clientLeft || 0) : 0,
        Mt = (le = ce == null ? void 0 : ce[M]) != null ? le : 0,
        $n = se + be - Mt - tr,
        Sr = se + $e - Mt,
        nr = oa(v ? Yc(B, $n) : B, se, v ? Pi(V, Sr) : V);
      (R[M] = nr), (ee[M] = nr - se);
    }
    if (u) {
      var _n,
        Cr = M === "x" ? nn : rn,
        sn = M === "x" ? Dn : In,
        $t = R[I],
        _t = I === "y" ? "height" : "width",
        kr = $t + C[Cr],
        rr = $t - C[sn],
        Qr = [nn, rn].indexOf(E) !== -1,
        Zo = (_n = ce == null ? void 0 : ce[I]) != null ? _n : 0,
        ei = Qr ? kr : $t - F[_t] - H[_t] - Zo + re.altAxis,
        Yr = Qr ? $t + F[_t] + H[_t] - Zo - re.altAxis : rr,
        Er = v && Qr ? z3(ei, $t, Yr) : oa(v ? ei : kr, $t, v ? Yr : rr);
      (R[I] = Er), (ee[I] = Er - $t);
    }
    e.modifiersData[r] = ee;
  }
}
const gP = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: mP,
  requiresIfExists: ["offset"],
};
function yP(t) {
  return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop };
}
function vP(t) {
  return t === yn(t) || !Rn(t) ? Ag(t) : yP(t);
}
function wP(t) {
  var e = t.getBoundingClientRect(),
    n = Js(e.width) / t.offsetWidth || 1,
    r = Js(e.height) / t.offsetHeight || 1;
  return n !== 1 || r !== 1;
}
function xP(t, e, n) {
  n === void 0 && (n = !1);
  var r = Rn(e),
    o = Rn(e) && wP(e),
    i = Jo(e),
    l = Qs(t, o, n),
    u = { scrollLeft: 0, scrollTop: 0 },
    c = { x: 0, y: 0 };
  return (
    (r || (!r && !n)) &&
      ((vr(e) !== "body" || Pg(i)) && (u = vP(e)),
      Rn(e)
        ? ((c = Qs(e, !0)), (c.x += e.clientLeft), (c.y += e.clientTop))
        : i && (c.x = Rg(i))),
    {
      x: l.left + u.scrollLeft - c.x,
      y: l.top + u.scrollTop - c.y,
      width: l.width,
      height: l.height,
    }
  );
}
function bP(t) {
  var e = new Map(),
    n = new Set(),
    r = [];
  t.forEach(function (i) {
    e.set(i.name, i);
  });
  function o(i) {
    n.add(i.name);
    var l = [].concat(i.requires || [], i.requiresIfExists || []);
    l.forEach(function (u) {
      if (!n.has(u)) {
        var c = e.get(u);
        c && o(c);
      }
    }),
      r.push(i);
  }
  return (
    t.forEach(function (i) {
      n.has(i.name) || o(i);
    }),
    r
  );
}
function SP(t) {
  var e = bP(t);
  return I3.reduce(function (n, r) {
    return n.concat(
      e.filter(function (o) {
        return o.phase === r;
      })
    );
  }, []);
}
function CP(t) {
  var e;
  return function () {
    return (
      e ||
        (e = new Promise(function (n) {
          Promise.resolve().then(function () {
            (e = void 0), n(t());
          });
        })),
      e
    );
  };
}
function kP(t) {
  var e = t.reduce(function (n, r) {
    var o = n[r.name];
    return (
      (n[r.name] = o
        ? Object.assign({}, o, r, {
            options: Object.assign({}, o.options, r.options),
            data: Object.assign({}, o.data, r.data),
          })
        : r),
      n
    );
  }, {});
  return Object.keys(e).map(function (n) {
    return e[n];
  });
}
var Dw = { placement: "bottom", modifiers: [], strategy: "absolute" };
function Iw() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  return !e.some(function (r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function EP(t) {
  t === void 0 && (t = {});
  var e = t,
    n = e.defaultModifiers,
    r = n === void 0 ? [] : n,
    o = e.defaultOptions,
    i = o === void 0 ? Dw : o;
  return function (u, c, f) {
    f === void 0 && (f = i);
    var p = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, Dw, i),
        modifiersData: {},
        elements: { reference: u, popper: c },
        attributes: {},
        styles: {},
      },
      m = [],
      y = !1,
      v = {
        state: p,
        setOptions: function (E) {
          var N = typeof E == "function" ? E(p.options) : E;
          S(),
            (p.options = Object.assign({}, i, p.options, N)),
            (p.scrollParents = {
              reference: Fi(u)
                ? ia(u)
                : u.contextElement
                ? ia(u.contextElement)
                : [],
              popper: ia(c),
            });
          var $ = SP(kP([].concat(r, p.options.modifiers)));
          return (
            (p.orderedModifiers = $.filter(function (M) {
              return M.enabled;
            })),
            x(),
            v.update()
          );
        },
        forceUpdate: function () {
          if (!y) {
            var E = p.elements,
              N = E.reference,
              $ = E.popper;
            if (Iw(N, $)) {
              (p.rects = {
                reference: xP(N, ja($), p.options.strategy === "fixed"),
                popper: Tg($),
              }),
                (p.reset = !1),
                (p.placement = p.options.placement),
                p.orderedModifiers.forEach(function (re) {
                  return (p.modifiersData[re.name] = Object.assign(
                    {},
                    re.data
                  ));
                });
              for (var M = 0; M < p.orderedModifiers.length; M++) {
                if (p.reset === !0) {
                  (p.reset = !1), (M = -1);
                  continue;
                }
                var I = p.orderedModifiers[M],
                  R = I.fn,
                  F = I.options,
                  H = F === void 0 ? {} : F,
                  U = I.name;
                typeof R == "function" &&
                  (p = R({ state: p, options: H, name: U, instance: v }) || p);
              }
            }
          }
        },
        update: CP(function () {
          return new Promise(function (C) {
            v.forceUpdate(), C(p);
          });
        }),
        destroy: function () {
          S(), (y = !0);
        },
      };
    if (!Iw(u, c)) return v;
    v.setOptions(f).then(function (C) {
      !y && f.onFirstUpdate && f.onFirstUpdate(C);
    });
    function x() {
      p.orderedModifiers.forEach(function (C) {
        var E = C.name,
          N = C.options,
          $ = N === void 0 ? {} : N,
          M = C.effect;
        if (typeof M == "function") {
          var I = M({ state: p, name: E, instance: v, options: $ }),
            R = function () {};
          m.push(I || R);
        }
      });
    }
    function S() {
      m.forEach(function (C) {
        return C();
      }),
        (m = []);
    }
    return v;
  };
}
var MP = [J3, pP, q3, PS, dP, sP, gP, V3, aP],
  OP = EP({ defaultModifiers: MP }),
  TP = "tippy-box",
  jS = "tippy-content",
  NP = "tippy-backdrop",
  BS = "tippy-arrow",
  HS = "tippy-svg-arrow",
  xi = { passive: !0, capture: !0 },
  VS = function () {
    return document.body;
  };
function Eh(t, e, n) {
  if (Array.isArray(t)) {
    var r = t[e];
    return r ?? (Array.isArray(n) ? n[e] : n);
  }
  return t;
}
function Dg(t, e) {
  var n = {}.toString.call(t);
  return n.indexOf("[object") === 0 && n.indexOf(e + "]") > -1;
}
function WS(t, e) {
  return typeof t == "function" ? t.apply(void 0, e) : t;
}
function Lw(t, e) {
  if (e === 0) return t;
  var n;
  return function (r) {
    clearTimeout(n),
      (n = setTimeout(function () {
        t(r);
      }, e));
  };
}
function AP(t) {
  return t.split(/\s+/).filter(Boolean);
}
function As(t) {
  return [].concat(t);
}
function $w(t, e) {
  t.indexOf(e) === -1 && t.push(e);
}
function RP(t) {
  return t.filter(function (e, n) {
    return t.indexOf(e) === n;
  });
}
function PP(t) {
  return t.split("-")[0];
}
function Xc(t) {
  return [].slice.call(t);
}
function _w(t) {
  return Object.keys(t).reduce(function (e, n) {
    return t[n] !== void 0 && (e[n] = t[n]), e;
  }, {});
}
function sa() {
  return document.createElement("div");
}
function Yd(t) {
  return ["Element", "Fragment"].some(function (e) {
    return Dg(t, e);
  });
}
function DP(t) {
  return Dg(t, "NodeList");
}
function IP(t) {
  return Dg(t, "MouseEvent");
}
function LP(t) {
  return !!(t && t._tippy && t._tippy.reference === t);
}
function $P(t) {
  return Yd(t)
    ? [t]
    : DP(t)
    ? Xc(t)
    : Array.isArray(t)
    ? t
    : Xc(document.querySelectorAll(t));
}
function Mh(t, e) {
  t.forEach(function (n) {
    n && (n.style.transitionDuration = e + "ms");
  });
}
function Fw(t, e) {
  t.forEach(function (n) {
    n && n.setAttribute("data-state", e);
  });
}
function _P(t) {
  var e,
    n = As(t),
    r = n[0];
  return r != null && (e = r.ownerDocument) != null && e.body
    ? r.ownerDocument
    : document;
}
function FP(t, e) {
  var n = e.clientX,
    r = e.clientY;
  return t.every(function (o) {
    var i = o.popperRect,
      l = o.popperState,
      u = o.props,
      c = u.interactiveBorder,
      f = PP(l.placement),
      p = l.modifiersData.offset;
    if (!p) return !0;
    var m = f === "bottom" ? p.top.y : 0,
      y = f === "top" ? p.bottom.y : 0,
      v = f === "right" ? p.left.x : 0,
      x = f === "left" ? p.right.x : 0,
      S = i.top - r + m > c,
      C = r - i.bottom - y > c,
      E = i.left - n + v > c,
      N = n - i.right - x > c;
    return S || C || E || N;
  });
}
function Oh(t, e, n) {
  var r = e + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function (o) {
    t[r](o, n);
  });
}
function zw(t, e) {
  for (var n = e; n; ) {
    var r;
    if (t.contains(n)) return !0;
    n =
      n.getRootNode == null || (r = n.getRootNode()) == null ? void 0 : r.host;
  }
  return !1;
}
var fr = { isTouch: !1 },
  jw = 0;
function zP() {
  fr.isTouch ||
    ((fr.isTouch = !0),
    window.performance && document.addEventListener("mousemove", US));
}
function US() {
  var t = performance.now();
  t - jw < 20 &&
    ((fr.isTouch = !1), document.removeEventListener("mousemove", US)),
    (jw = t);
}
function jP() {
  var t = document.activeElement;
  if (LP(t)) {
    var e = t._tippy;
    t.blur && !e.state.isVisible && t.blur();
  }
}
function BP() {
  document.addEventListener("touchstart", zP, xi),
    window.addEventListener("blur", jP);
}
var HP = typeof window < "u" && typeof document < "u",
  VP = HP ? !!window.msCrypto : !1,
  WP = { animateFill: !1, followCursor: !1, inlinePositioning: !1, sticky: !1 },
  UP = {
    allowHTML: !1,
    animation: "fade",
    arrow: !0,
    content: "",
    inertia: !1,
    maxWidth: 350,
    role: "tooltip",
    theme: "",
    zIndex: 9999,
  },
  Kn = Object.assign(
    {
      appendTo: VS,
      aria: { content: "auto", expanded: "auto" },
      delay: 0,
      duration: [300, 250],
      getReferenceClientRect: null,
      hideOnClick: !0,
      ignoreAttributes: !1,
      interactive: !1,
      interactiveBorder: 2,
      interactiveDebounce: 0,
      moveTransition: "",
      offset: [0, 10],
      onAfterUpdate: function () {},
      onBeforeUpdate: function () {},
      onCreate: function () {},
      onDestroy: function () {},
      onHidden: function () {},
      onHide: function () {},
      onMount: function () {},
      onShow: function () {},
      onShown: function () {},
      onTrigger: function () {},
      onUntrigger: function () {},
      onClickOutside: function () {},
      placement: "top",
      plugins: [],
      popperOptions: {},
      render: null,
      showOnCreate: !1,
      touch: !0,
      trigger: "mouseenter focus",
      triggerTarget: null,
    },
    WP,
    UP
  ),
  KP = Object.keys(Kn),
  qP = function (e) {
    var n = Object.keys(e);
    n.forEach(function (r) {
      Kn[r] = e[r];
    });
  };
function KS(t) {
  var e = t.plugins || [],
    n = e.reduce(function (r, o) {
      var i = o.name,
        l = o.defaultValue;
      if (i) {
        var u;
        r[i] = t[i] !== void 0 ? t[i] : (u = Kn[i]) != null ? u : l;
      }
      return r;
    }, {});
  return Object.assign({}, t, n);
}
function GP(t, e) {
  var n = e ? Object.keys(KS(Object.assign({}, Kn, { plugins: e }))) : KP,
    r = n.reduce(function (o, i) {
      var l = (t.getAttribute("data-tippy-" + i) || "").trim();
      if (!l) return o;
      if (i === "content") o[i] = l;
      else
        try {
          o[i] = JSON.parse(l);
        } catch {
          o[i] = l;
        }
      return o;
    }, {});
  return r;
}
function Bw(t, e) {
  var n = Object.assign(
    {},
    e,
    { content: WS(e.content, [t]) },
    e.ignoreAttributes ? {} : GP(t, e.plugins)
  );
  return (
    (n.aria = Object.assign({}, Kn.aria, n.aria)),
    (n.aria = {
      expanded: n.aria.expanded === "auto" ? e.interactive : n.aria.expanded,
      content:
        n.aria.content === "auto"
          ? e.interactive
            ? null
            : "describedby"
          : n.aria.content,
    }),
    n
  );
}
var JP = function () {
  return "innerHTML";
};
function Om(t, e) {
  t[JP()] = e;
}
function Hw(t) {
  var e = sa();
  return (
    t === !0
      ? (e.className = BS)
      : ((e.className = HS), Yd(t) ? e.appendChild(t) : Om(e, t)),
    e
  );
}
function Vw(t, e) {
  Yd(e.content)
    ? (Om(t, ""), t.appendChild(e.content))
    : typeof e.content != "function" &&
      (e.allowHTML ? Om(t, e.content) : (t.textContent = e.content));
}
function Tm(t) {
  var e = t.firstElementChild,
    n = Xc(e.children);
  return {
    box: e,
    content: n.find(function (r) {
      return r.classList.contains(jS);
    }),
    arrow: n.find(function (r) {
      return r.classList.contains(BS) || r.classList.contains(HS);
    }),
    backdrop: n.find(function (r) {
      return r.classList.contains(NP);
    }),
  };
}
function qS(t) {
  var e = sa(),
    n = sa();
  (n.className = TP),
    n.setAttribute("data-state", "hidden"),
    n.setAttribute("tabindex", "-1");
  var r = sa();
  (r.className = jS),
    r.setAttribute("data-state", "hidden"),
    Vw(r, t.props),
    e.appendChild(n),
    n.appendChild(r),
    o(t.props, t.props);
  function o(i, l) {
    var u = Tm(e),
      c = u.box,
      f = u.content,
      p = u.arrow;
    l.theme
      ? c.setAttribute("data-theme", l.theme)
      : c.removeAttribute("data-theme"),
      typeof l.animation == "string"
        ? c.setAttribute("data-animation", l.animation)
        : c.removeAttribute("data-animation"),
      l.inertia
        ? c.setAttribute("data-inertia", "")
        : c.removeAttribute("data-inertia"),
      (c.style.maxWidth =
        typeof l.maxWidth == "number" ? l.maxWidth + "px" : l.maxWidth),
      l.role ? c.setAttribute("role", l.role) : c.removeAttribute("role"),
      (i.content !== l.content || i.allowHTML !== l.allowHTML) &&
        Vw(f, t.props),
      l.arrow
        ? p
          ? i.arrow !== l.arrow &&
            (c.removeChild(p), c.appendChild(Hw(l.arrow)))
          : c.appendChild(Hw(l.arrow))
        : p && c.removeChild(p);
  }
  return { popper: e, onUpdate: o };
}
qS.$$tippy = !0;
var QP = 1,
  pc = [],
  Th = [];
function YP(t, e) {
  var n = Bw(t, Object.assign({}, Kn, KS(_w(e)))),
    r,
    o,
    i,
    l = !1,
    u = !1,
    c = !1,
    f = !1,
    p,
    m,
    y,
    v = [],
    x = Lw($n, n.interactiveDebounce),
    S,
    C = QP++,
    E = null,
    N = RP(n.plugins),
    $ = {
      isEnabled: !0,
      isVisible: !1,
      isDestroyed: !1,
      isMounted: !1,
      isShown: !1,
    },
    M = {
      id: C,
      reference: t,
      popper: sa(),
      popperInstance: E,
      props: n,
      state: $,
      plugins: N,
      clearDelayTimeouts: ei,
      setProps: Yr,
      setContent: Er,
      show: Ja,
      hide: ti,
      hideWithInteractivity: ni,
      enable: Qr,
      disable: Zo,
      unmount: wf,
      destroy: Qa,
    };
  if (!n.render) return M;
  var I = n.render(M),
    R = I.popper,
    F = I.onUpdate;
  R.setAttribute("data-tippy-root", ""),
    (R.id = "tippy-" + M.id),
    (M.popper = R),
    (t._tippy = M),
    (R._tippy = M);
  var H = N.map(function (W) {
      return W.fn(M);
    }),
    U = t.hasAttribute("aria-expanded");
  return (
    Kt(),
    K(),
    se(),
    B("onCreate", [M]),
    n.showOnCreate && kr(),
    R.addEventListener("mouseenter", function () {
      M.props.interactive && M.state.isVisible && M.clearDelayTimeouts();
    }),
    R.addEventListener("mouseleave", function () {
      M.props.interactive &&
        M.props.trigger.indexOf("mouseenter") >= 0 &&
        de().addEventListener("mousemove", x);
    }),
    M
  );
  function re() {
    var W = M.props.touch;
    return Array.isArray(W) ? W : [W, 0];
  }
  function ce() {
    return re()[0] === "hold";
  }
  function ee() {
    var W;
    return !!((W = M.props.render) != null && W.$$tippy);
  }
  function le() {
    return S || t;
  }
  function de() {
    var W = le().parentNode;
    return W ? _P(W) : document;
  }
  function xe() {
    return Tm(R);
  }
  function oe(W) {
    return (M.state.isMounted && !M.state.isVisible) ||
      fr.isTouch ||
      (p && p.type === "focus")
      ? 0
      : Eh(M.props.delay, W ? 0 : 1, Kn.delay);
  }
  function se(W) {
    W === void 0 && (W = !1),
      (R.style.pointerEvents = M.props.interactive && !W ? "" : "none"),
      (R.style.zIndex = "" + M.props.zIndex);
  }
  function B(W, ge, Ee) {
    if (
      (Ee === void 0 && (Ee = !0),
      H.forEach(function (Ie) {
        Ie[W] && Ie[W].apply(Ie, ge);
      }),
      Ee)
    ) {
      var _e;
      (_e = M.props)[W].apply(_e, ge);
    }
  }
  function V() {
    var W = M.props.aria;
    if (W.content) {
      var ge = "aria-" + W.content,
        Ee = R.id,
        _e = As(M.props.triggerTarget || t);
      _e.forEach(function (Ie) {
        var lt = Ie.getAttribute(ge);
        if (M.state.isVisible) Ie.setAttribute(ge, lt ? lt + " " + Ee : Ee);
        else {
          var Ot = lt && lt.replace(Ee, "").trim();
          Ot ? Ie.setAttribute(ge, Ot) : Ie.removeAttribute(ge);
        }
      });
    }
  }
  function K() {
    if (!(U || !M.props.aria.expanded)) {
      var W = As(M.props.triggerTarget || t);
      W.forEach(function (ge) {
        M.props.interactive
          ? ge.setAttribute(
              "aria-expanded",
              M.state.isVisible && ge === le() ? "true" : "false"
            )
          : ge.removeAttribute("aria-expanded");
      });
    }
  }
  function D() {
    de().removeEventListener("mousemove", x),
      (pc = pc.filter(function (W) {
        return W !== x;
      }));
  }
  function A(W) {
    if (!(fr.isTouch && (c || W.type === "mousedown"))) {
      var ge = (W.composedPath && W.composedPath()[0]) || W.target;
      if (!(M.props.interactive && zw(R, ge))) {
        if (
          As(M.props.triggerTarget || t).some(function (Ee) {
            return zw(Ee, ge);
          })
        ) {
          if (
            fr.isTouch ||
            (M.state.isVisible && M.props.trigger.indexOf("click") >= 0)
          )
            return;
        } else B("onClickOutside", [M, W]);
        M.props.hideOnClick === !0 &&
          (M.clearDelayTimeouts(),
          M.hide(),
          (u = !0),
          setTimeout(function () {
            u = !1;
          }),
          M.state.isMounted || ie());
      }
    }
  }
  function X() {
    c = !0;
  }
  function ne() {
    c = !1;
  }
  function Q() {
    var W = de();
    W.addEventListener("mousedown", A, !0),
      W.addEventListener("touchend", A, xi),
      W.addEventListener("touchstart", ne, xi),
      W.addEventListener("touchmove", X, xi);
  }
  function ie() {
    var W = de();
    W.removeEventListener("mousedown", A, !0),
      W.removeEventListener("touchend", A, xi),
      W.removeEventListener("touchstart", ne, xi),
      W.removeEventListener("touchmove", X, xi);
  }
  function he(W, ge) {
    be(W, function () {
      !M.state.isVisible && R.parentNode && R.parentNode.contains(R) && ge();
    });
  }
  function we(W, ge) {
    be(W, ge);
  }
  function be(W, ge) {
    var Ee = xe().box;
    function _e(Ie) {
      Ie.target === Ee && (Oh(Ee, "remove", _e), ge());
    }
    if (W === 0) return ge();
    Oh(Ee, "remove", m), Oh(Ee, "add", _e), (m = _e);
  }
  function $e(W, ge, Ee) {
    Ee === void 0 && (Ee = !1);
    var _e = As(M.props.triggerTarget || t);
    _e.forEach(function (Ie) {
      Ie.addEventListener(W, ge, Ee),
        v.push({ node: Ie, eventType: W, handler: ge, options: Ee });
    });
  }
  function Kt() {
    ce() &&
      ($e("touchstart", Mt, { passive: !0 }),
      $e("touchend", Sr, { passive: !0 })),
      AP(M.props.trigger).forEach(function (W) {
        if (W !== "manual")
          switch (($e(W, Mt), W)) {
            case "mouseenter":
              $e("mouseleave", Sr);
              break;
            case "focus":
              $e(VP ? "focusout" : "blur", nr);
              break;
            case "focusin":
              $e("focusout", nr);
              break;
          }
      });
  }
  function tr() {
    v.forEach(function (W) {
      var ge = W.node,
        Ee = W.eventType,
        _e = W.handler,
        Ie = W.options;
      ge.removeEventListener(Ee, _e, Ie);
    }),
      (v = []);
  }
  function Mt(W) {
    var ge,
      Ee = !1;
    if (!(!M.state.isEnabled || _n(W) || u)) {
      var _e = ((ge = p) == null ? void 0 : ge.type) === "focus";
      (p = W),
        (S = W.currentTarget),
        K(),
        !M.state.isVisible &&
          IP(W) &&
          pc.forEach(function (Ie) {
            return Ie(W);
          }),
        W.type === "click" &&
        (M.props.trigger.indexOf("mouseenter") < 0 || l) &&
        M.props.hideOnClick !== !1 &&
        M.state.isVisible
          ? (Ee = !0)
          : kr(W),
        W.type === "click" && (l = !Ee),
        Ee && !_e && rr(W);
    }
  }
  function $n(W) {
    var ge = W.target,
      Ee = le().contains(ge) || R.contains(ge);
    if (!(W.type === "mousemove" && Ee)) {
      var _e = _t()
        .concat(R)
        .map(function (Ie) {
          var lt,
            Ot = Ie._tippy,
            ln = (lt = Ot.popperInstance) == null ? void 0 : lt.state;
          return ln
            ? {
                popperRect: Ie.getBoundingClientRect(),
                popperState: ln,
                props: n,
              }
            : null;
        })
        .filter(Boolean);
      FP(_e, W) && (D(), rr(W));
    }
  }
  function Sr(W) {
    var ge = _n(W) || (M.props.trigger.indexOf("click") >= 0 && l);
    if (!ge) {
      if (M.props.interactive) {
        M.hideWithInteractivity(W);
        return;
      }
      rr(W);
    }
  }
  function nr(W) {
    (M.props.trigger.indexOf("focusin") < 0 && W.target !== le()) ||
      (M.props.interactive && W.relatedTarget && R.contains(W.relatedTarget)) ||
      rr(W);
  }
  function _n(W) {
    return fr.isTouch ? ce() !== W.type.indexOf("touch") >= 0 : !1;
  }
  function Cr() {
    sn();
    var W = M.props,
      ge = W.popperOptions,
      Ee = W.placement,
      _e = W.offset,
      Ie = W.getReferenceClientRect,
      lt = W.moveTransition,
      Ot = ee() ? Tm(R).arrow : null,
      ln = Ie
        ? {
            getBoundingClientRect: Ie,
            contextElement: Ie.contextElement || le(),
          }
        : t,
      Mr = {
        name: "$$tippy",
        enabled: !0,
        phase: "beforeWrite",
        requires: ["computeStyles"],
        fn: function (ri) {
          var Or = ri.state;
          if (ee()) {
            var Ya = xe(),
              oi = Ya.box;
            ["placement", "reference-hidden", "escaped"].forEach(function (ii) {
              ii === "placement"
                ? oi.setAttribute("data-placement", Or.placement)
                : Or.attributes.popper["data-popper-" + ii]
                ? oi.setAttribute("data-" + ii, "")
                : oi.removeAttribute("data-" + ii);
            }),
              (Or.attributes.popper = {});
          }
        },
      },
      or = [
        { name: "offset", options: { offset: _e } },
        {
          name: "preventOverflow",
          options: { padding: { top: 2, bottom: 2, left: 5, right: 5 } },
        },
        { name: "flip", options: { padding: 5 } },
        { name: "computeStyles", options: { adaptive: !lt } },
        Mr,
      ];
    ee() &&
      Ot &&
      or.push({ name: "arrow", options: { element: Ot, padding: 3 } }),
      or.push.apply(or, (ge == null ? void 0 : ge.modifiers) || []),
      (M.popperInstance = OP(
        ln,
        R,
        Object.assign({}, ge, {
          placement: Ee,
          onFirstUpdate: y,
          modifiers: or,
        })
      ));
  }
  function sn() {
    M.popperInstance && (M.popperInstance.destroy(), (M.popperInstance = null));
  }
  function $t() {
    var W = M.props.appendTo,
      ge,
      Ee = le();
    (M.props.interactive && W === VS) || W === "parent"
      ? (ge = Ee.parentNode)
      : (ge = WS(W, [Ee])),
      ge.contains(R) || ge.appendChild(R),
      (M.state.isMounted = !0),
      Cr();
  }
  function _t() {
    return Xc(R.querySelectorAll("[data-tippy-root]"));
  }
  function kr(W) {
    M.clearDelayTimeouts(), W && B("onTrigger", [M, W]), Q();
    var ge = oe(!0),
      Ee = re(),
      _e = Ee[0],
      Ie = Ee[1];
    fr.isTouch && _e === "hold" && Ie && (ge = Ie),
      ge
        ? (r = setTimeout(function () {
            M.show();
          }, ge))
        : M.show();
  }
  function rr(W) {
    if (
      (M.clearDelayTimeouts(), B("onUntrigger", [M, W]), !M.state.isVisible)
    ) {
      ie();
      return;
    }
    if (
      !(
        M.props.trigger.indexOf("mouseenter") >= 0 &&
        M.props.trigger.indexOf("click") >= 0 &&
        ["mouseleave", "mousemove"].indexOf(W.type) >= 0 &&
        l
      )
    ) {
      var ge = oe(!1);
      ge
        ? (o = setTimeout(function () {
            M.state.isVisible && M.hide();
          }, ge))
        : (i = requestAnimationFrame(function () {
            M.hide();
          }));
    }
  }
  function Qr() {
    M.state.isEnabled = !0;
  }
  function Zo() {
    M.hide(), (M.state.isEnabled = !1);
  }
  function ei() {
    clearTimeout(r), clearTimeout(o), cancelAnimationFrame(i);
  }
  function Yr(W) {
    if (!M.state.isDestroyed) {
      B("onBeforeUpdate", [M, W]), tr();
      var ge = M.props,
        Ee = Bw(t, Object.assign({}, ge, _w(W), { ignoreAttributes: !0 }));
      (M.props = Ee),
        Kt(),
        ge.interactiveDebounce !== Ee.interactiveDebounce &&
          (D(), (x = Lw($n, Ee.interactiveDebounce))),
        ge.triggerTarget && !Ee.triggerTarget
          ? As(ge.triggerTarget).forEach(function (_e) {
              _e.removeAttribute("aria-expanded");
            })
          : Ee.triggerTarget && t.removeAttribute("aria-expanded"),
        K(),
        se(),
        F && F(ge, Ee),
        M.popperInstance &&
          (Cr(),
          _t().forEach(function (_e) {
            requestAnimationFrame(_e._tippy.popperInstance.forceUpdate);
          })),
        B("onAfterUpdate", [M, W]);
    }
  }
  function Er(W) {
    M.setProps({ content: W });
  }
  function Ja() {
    var W = M.state.isVisible,
      ge = M.state.isDestroyed,
      Ee = !M.state.isEnabled,
      _e = fr.isTouch && !M.props.touch,
      Ie = Eh(M.props.duration, 0, Kn.duration);
    if (
      !(W || ge || Ee || _e) &&
      !le().hasAttribute("disabled") &&
      (B("onShow", [M], !1), M.props.onShow(M) !== !1)
    ) {
      if (
        ((M.state.isVisible = !0),
        ee() && (R.style.visibility = "visible"),
        se(),
        Q(),
        M.state.isMounted || (R.style.transition = "none"),
        ee())
      ) {
        var lt = xe(),
          Ot = lt.box,
          ln = lt.content;
        Mh([Ot, ln], 0);
      }
      (y = function () {
        var or;
        if (!(!M.state.isVisible || f)) {
          if (
            ((f = !0),
            R.offsetHeight,
            (R.style.transition = M.props.moveTransition),
            ee() && M.props.animation)
          ) {
            var Qi = xe(),
              ri = Qi.box,
              Or = Qi.content;
            Mh([ri, Or], Ie), Fw([ri, Or], "visible");
          }
          V(),
            K(),
            $w(Th, M),
            (or = M.popperInstance) == null || or.forceUpdate(),
            B("onMount", [M]),
            M.props.animation &&
              ee() &&
              we(Ie, function () {
                (M.state.isShown = !0), B("onShown", [M]);
              });
        }
      }),
        $t();
    }
  }
  function ti() {
    var W = !M.state.isVisible,
      ge = M.state.isDestroyed,
      Ee = !M.state.isEnabled,
      _e = Eh(M.props.duration, 1, Kn.duration);
    if (!(W || ge || Ee) && (B("onHide", [M], !1), M.props.onHide(M) !== !1)) {
      if (
        ((M.state.isVisible = !1),
        (M.state.isShown = !1),
        (f = !1),
        (l = !1),
        ee() && (R.style.visibility = "hidden"),
        D(),
        ie(),
        se(!0),
        ee())
      ) {
        var Ie = xe(),
          lt = Ie.box,
          Ot = Ie.content;
        M.props.animation && (Mh([lt, Ot], _e), Fw([lt, Ot], "hidden"));
      }
      V(), K(), M.props.animation ? ee() && he(_e, M.unmount) : M.unmount();
    }
  }
  function ni(W) {
    de().addEventListener("mousemove", x), $w(pc, x), x(W);
  }
  function wf() {
    M.state.isVisible && M.hide(),
      M.state.isMounted &&
        (sn(),
        _t().forEach(function (W) {
          W._tippy.unmount();
        }),
        R.parentNode && R.parentNode.removeChild(R),
        (Th = Th.filter(function (W) {
          return W !== M;
        })),
        (M.state.isMounted = !1),
        B("onHidden", [M]));
  }
  function Qa() {
    M.state.isDestroyed ||
      (M.clearDelayTimeouts(),
      M.unmount(),
      tr(),
      delete t._tippy,
      (M.state.isDestroyed = !0),
      B("onDestroy", [M]));
  }
}
function nl(t, e) {
  e === void 0 && (e = {});
  var n = Kn.plugins.concat(e.plugins || []);
  BP();
  var r = Object.assign({}, e, { plugins: n }),
    o = $P(t),
    i = o.reduce(function (l, u) {
      var c = u && YP(u, r);
      return c && l.push(c), l;
    }, []);
  return Yd(t) ? i[0] : i;
}
nl.defaultProps = Kn;
nl.setDefaultProps = qP;
nl.currentInput = fr;
Object.assign({}, PS, {
  effect: function (e) {
    var n = e.state,
      r = {
        popper: {
          position: n.options.strategy,
          left: "0",
          top: "0",
          margin: "0",
        },
        arrow: { position: "absolute" },
        reference: {},
      };
    Object.assign(n.elements.popper.style, r.popper),
      (n.styles = r),
      n.elements.arrow && Object.assign(n.elements.arrow.style, r.arrow);
  },
});
nl.setDefaultProps({ render: qS });
class XP {
  constructor({
    editor: e,
    element: n,
    view: r,
    tippyOptions: o = {},
    updateDelay: i = 250,
    shouldShow: l,
  }) {
    (this.preventHide = !1),
      (this.shouldShow = ({ view: u, state: c, from: f, to: p }) => {
        const { doc: m, selection: y } = c,
          { empty: v } = y,
          x = !m.textBetween(f, p).length && bg(c.selection),
          S = this.element.contains(document.activeElement);
        return !(!(u.hasFocus() || S) || v || x || !this.editor.isEditable);
      }),
      (this.mousedownHandler = () => {
        this.preventHide = !0;
      }),
      (this.dragstartHandler = () => {
        this.hide();
      }),
      (this.focusHandler = () => {
        setTimeout(() => this.update(this.editor.view));
      }),
      (this.blurHandler = ({ event: u }) => {
        var c;
        if (this.preventHide) {
          this.preventHide = !1;
          return;
        }
        (u != null &&
          u.relatedTarget &&
          !((c = this.element.parentNode) === null || c === void 0) &&
          c.contains(u.relatedTarget)) ||
          ((u == null ? void 0 : u.relatedTarget) !== this.editor.view.dom &&
            this.hide());
      }),
      (this.tippyBlurHandler = (u) => {
        this.blurHandler({ event: u });
      }),
      (this.handleDebouncedUpdate = (u, c) => {
        const f = !(c != null && c.selection.eq(u.state.selection)),
          p = !(c != null && c.doc.eq(u.state.doc));
        (!f && !p) ||
          (this.updateDebounceTimer && clearTimeout(this.updateDebounceTimer),
          (this.updateDebounceTimer = window.setTimeout(() => {
            this.updateHandler(u, f, p, c);
          }, this.updateDelay)));
      }),
      (this.updateHandler = (u, c, f, p) => {
        var m, y, v;
        const { state: x, composing: S } = u,
          { selection: C } = x;
        if (S || (!c && !f)) return;
        this.createTooltip();
        const { ranges: N } = C,
          $ = Math.min(...N.map((R) => R.$from.pos)),
          M = Math.max(...N.map((R) => R.$to.pos));
        if (
          !((m = this.shouldShow) === null || m === void 0
            ? void 0
            : m.call(this, {
                editor: this.editor,
                element: this.element,
                view: u,
                state: x,
                oldState: p,
                from: $,
                to: M,
              }))
        ) {
          this.hide();
          return;
        }
        (y = this.tippy) === null ||
          y === void 0 ||
          y.setProps({
            getReferenceClientRect:
              ((v = this.tippyOptions) === null || v === void 0
                ? void 0
                : v.getReferenceClientRect) ||
              (() => {
                if (TS(x.selection)) {
                  let R = u.nodeDOM($);
                  if (R) {
                    const F = R.dataset.nodeViewWrapper
                      ? R
                      : R.querySelector("[data-node-view-wrapper]");
                    if ((F && (R = F.firstChild), R))
                      return R.getBoundingClientRect();
                  }
                }
                return NS(u, $, M);
              }),
          }),
          this.show();
      }),
      (this.editor = e),
      (this.element = n),
      (this.view = r),
      (this.updateDelay = i),
      l && (this.shouldShow = l),
      this.element.addEventListener("mousedown", this.mousedownHandler, {
        capture: !0,
      }),
      this.view.dom.addEventListener("dragstart", this.dragstartHandler),
      this.editor.on("focus", this.focusHandler),
      this.editor.on("blur", this.blurHandler),
      (this.tippyOptions = o),
      this.element.remove(),
      (this.element.style.visibility = "visible");
  }
  createTooltip() {
    const { element: e } = this.editor.options,
      n = !!e.parentElement;
    this.tippy ||
      !n ||
      ((this.tippy = nl(e, {
        duration: 0,
        getReferenceClientRect: null,
        content: this.element,
        interactive: !0,
        trigger: "manual",
        placement: "top",
        hideOnClick: "toggle",
        ...this.tippyOptions,
      })),
      this.tippy.popper.firstChild &&
        this.tippy.popper.firstChild.addEventListener(
          "blur",
          this.tippyBlurHandler
        ));
  }
  update(e, n) {
    const { state: r } = e,
      o = r.selection.from !== r.selection.to;
    if (this.updateDelay > 0 && o) {
      this.handleDebouncedUpdate(e, n);
      return;
    }
    const i = !(n != null && n.selection.eq(e.state.selection)),
      l = !(n != null && n.doc.eq(e.state.doc));
    this.updateHandler(e, i, l, n);
  }
  show() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.show();
  }
  hide() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.hide();
  }
  destroy() {
    var e, n;
    !((e = this.tippy) === null || e === void 0) &&
      e.popper.firstChild &&
      this.tippy.popper.firstChild.removeEventListener(
        "blur",
        this.tippyBlurHandler
      ),
      (n = this.tippy) === null || n === void 0 || n.destroy(),
      this.element.removeEventListener("mousedown", this.mousedownHandler, {
        capture: !0,
      }),
      this.view.dom.removeEventListener("dragstart", this.dragstartHandler),
      this.editor.off("focus", this.focusHandler),
      this.editor.off("blur", this.blurHandler);
  }
}
const GS = (t) =>
  new pt({
    key: typeof t.pluginKey == "string" ? new Wt(t.pluginKey) : t.pluginKey,
    view: (e) => new XP({ view: e, ...t }),
  });
et.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "bubbleMenu",
      updateDelay: void 0,
      shouldShow: null,
    };
  },
  addProseMirrorPlugins() {
    return this.options.element
      ? [
          GS({
            pluginKey: this.options.pluginKey,
            editor: this.editor,
            element: this.options.element,
            tippyOptions: this.options.tippyOptions,
            updateDelay: this.options.updateDelay,
            shouldShow: this.options.shouldShow,
          }),
        ]
      : [];
  },
});
var Ba = Qx();
const Ig = Jx(Ba);
class ZP {
  getTextContent(e) {
    return MS(e, { textSerializers: wg(this.editor.schema) });
  }
  constructor({
    editor: e,
    element: n,
    view: r,
    tippyOptions: o = {},
    shouldShow: i,
  }) {
    (this.preventHide = !1),
      (this.shouldShow = ({ view: l, state: u }) => {
        const { selection: c } = u,
          { $anchor: f, empty: p } = c,
          m = f.depth === 1,
          y =
            f.parent.isTextblock &&
            !f.parent.type.spec.code &&
            !f.parent.textContent &&
            f.parent.childCount === 0 &&
            !this.getTextContent(f.parent);
        return !(!l.hasFocus() || !p || !m || !y || !this.editor.isEditable);
      }),
      (this.mousedownHandler = () => {
        this.preventHide = !0;
      }),
      (this.focusHandler = () => {
        setTimeout(() => this.update(this.editor.view));
      }),
      (this.blurHandler = ({ event: l }) => {
        var u;
        if (this.preventHide) {
          this.preventHide = !1;
          return;
        }
        (l != null &&
          l.relatedTarget &&
          !((u = this.element.parentNode) === null || u === void 0) &&
          u.contains(l.relatedTarget)) ||
          ((l == null ? void 0 : l.relatedTarget) !== this.editor.view.dom &&
            this.hide());
      }),
      (this.tippyBlurHandler = (l) => {
        this.blurHandler({ event: l });
      }),
      (this.editor = e),
      (this.element = n),
      (this.view = r),
      i && (this.shouldShow = i),
      this.element.addEventListener("mousedown", this.mousedownHandler, {
        capture: !0,
      }),
      this.editor.on("focus", this.focusHandler),
      this.editor.on("blur", this.blurHandler),
      (this.tippyOptions = o),
      this.element.remove(),
      (this.element.style.visibility = "visible");
  }
  createTooltip() {
    const { element: e } = this.editor.options,
      n = !!e.parentElement;
    this.tippy ||
      !n ||
      ((this.tippy = nl(e, {
        duration: 0,
        getReferenceClientRect: null,
        content: this.element,
        interactive: !0,
        trigger: "manual",
        placement: "right",
        hideOnClick: "toggle",
        ...this.tippyOptions,
      })),
      this.tippy.popper.firstChild &&
        this.tippy.popper.firstChild.addEventListener(
          "blur",
          this.tippyBlurHandler
        ));
  }
  update(e, n) {
    var r, o, i;
    const { state: l } = e,
      { doc: u, selection: c } = l,
      { from: f, to: p } = c;
    if (n && n.doc.eq(u) && n.selection.eq(c)) return;
    if (
      (this.createTooltip(),
      !((r = this.shouldShow) === null || r === void 0
        ? void 0
        : r.call(this, {
            editor: this.editor,
            view: e,
            state: l,
            oldState: n,
          })))
    ) {
      this.hide();
      return;
    }
    (o = this.tippy) === null ||
      o === void 0 ||
      o.setProps({
        getReferenceClientRect:
          ((i = this.tippyOptions) === null || i === void 0
            ? void 0
            : i.getReferenceClientRect) || (() => NS(e, f, p)),
      }),
      this.show();
  }
  show() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.show();
  }
  hide() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.hide();
  }
  destroy() {
    var e, n;
    !((e = this.tippy) === null || e === void 0) &&
      e.popper.firstChild &&
      this.tippy.popper.firstChild.removeEventListener(
        "blur",
        this.tippyBlurHandler
      ),
      (n = this.tippy) === null || n === void 0 || n.destroy(),
      this.element.removeEventListener("mousedown", this.mousedownHandler, {
        capture: !0,
      }),
      this.editor.off("focus", this.focusHandler),
      this.editor.off("blur", this.blurHandler);
  }
}
const JS = (t) =>
  new pt({
    key: typeof t.pluginKey == "string" ? new Wt(t.pluginKey) : t.pluginKey,
    view: (e) => new ZP({ view: e, ...t }),
  });
et.create({
  name: "floatingMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "floatingMenu",
      shouldShow: null,
    };
  },
  addProseMirrorPlugins() {
    return this.options.element
      ? [
          JS({
            pluginKey: this.options.pluginKey,
            editor: this.editor,
            element: this.options.element,
            tippyOptions: this.options.tippyOptions,
            shouldShow: this.options.shouldShow,
          }),
        ]
      : [];
  },
});
function eD(t) {
  return t.__esModule && Object.prototype.hasOwnProperty.call(t, "default")
    ? t.default
    : t;
}
var QS = { exports: {} },
  Nh = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Ww;
function tD() {
  if (Ww) return Nh;
  Ww = 1;
  var t = Le;
  function e(m, y) {
    return (m === y && (m !== 0 || 1 / m === 1 / y)) || (m !== m && y !== y);
  }
  var n = typeof Object.is == "function" ? Object.is : e,
    r = t.useState,
    o = t.useEffect,
    i = t.useLayoutEffect,
    l = t.useDebugValue;
  function u(m, y) {
    var v = y(),
      x = r({ inst: { value: v, getSnapshot: y } }),
      S = x[0].inst,
      C = x[1];
    return (
      i(
        function () {
          (S.value = v), (S.getSnapshot = y), c(S) && C({ inst: S });
        },
        [m, v, y]
      ),
      o(
        function () {
          return (
            c(S) && C({ inst: S }),
            m(function () {
              c(S) && C({ inst: S });
            })
          );
        },
        [m]
      ),
      l(v),
      v
    );
  }
  function c(m) {
    var y = m.getSnapshot;
    m = m.value;
    try {
      var v = y();
      return !n(m, v);
    } catch {
      return !0;
    }
  }
  function f(m, y) {
    return y();
  }
  var p =
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
      ? f
      : u;
  return (
    (Nh.useSyncExternalStore =
      t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : p),
    Nh
  );
}
QS.exports = tD();
var Lg = QS.exports;
const nD =
    (...t) =>
    (e) => {
      t.forEach((n) => {
        typeof n == "function" ? n(e) : n && (n.current = e);
      });
    },
  rD = ({ contentComponent: t }) => {
    const e = Lg.useSyncExternalStore(
      t.subscribe,
      t.getSnapshot,
      t.getServerSnapshot
    );
    return Le.createElement(Le.Fragment, null, Object.values(e));
  };
function oD() {
  const t = new Set();
  let e = {};
  return {
    subscribe(n) {
      return (
        t.add(n),
        () => {
          t.delete(n);
        }
      );
    },
    getSnapshot() {
      return e;
    },
    getServerSnapshot() {
      return e;
    },
    setRenderer(n, r) {
      (e = { ...e, [n]: Ig.createPortal(r.reactElement, r.element, n) }),
        t.forEach((o) => o());
    },
    removeRenderer(n) {
      const r = { ...e };
      delete r[n], (e = r), t.forEach((o) => o());
    },
  };
}
class iD extends Le.Component {
  constructor(e) {
    var n;
    super(e),
      (this.editorContentRef = Le.createRef()),
      (this.initialized = !1),
      (this.state = {
        hasContentComponentInitialized: !!(
          !((n = e.editor) === null || n === void 0) && n.contentComponent
        ),
      });
  }
  componentDidMount() {
    this.init();
  }
  componentDidUpdate() {
    this.init();
  }
  init() {
    const e = this.props.editor;
    if (e && !e.isDestroyed && e.options.element) {
      if (e.contentComponent) return;
      const n = this.editorContentRef.current;
      n.append(...e.options.element.childNodes),
        e.setOptions({ element: n }),
        (e.contentComponent = oD()),
        this.state.hasContentComponentInitialized ||
          (this.unsubscribeToContentComponent = e.contentComponent.subscribe(
            () => {
              this.setState((r) =>
                r.hasContentComponentInitialized
                  ? r
                  : { hasContentComponentInitialized: !0 }
              ),
                this.unsubscribeToContentComponent &&
                  this.unsubscribeToContentComponent();
            }
          )),
        e.createNodeViews(),
        (this.initialized = !0);
    }
  }
  componentWillUnmount() {
    const e = this.props.editor;
    if (
      !e ||
      ((this.initialized = !1),
      e.isDestroyed || e.view.setProps({ nodeViews: {} }),
      this.unsubscribeToContentComponent &&
        this.unsubscribeToContentComponent(),
      (e.contentComponent = null),
      !e.options.element.firstChild)
    )
      return;
    const n = document.createElement("div");
    n.append(...e.options.element.childNodes), e.setOptions({ element: n });
  }
  render() {
    const { editor: e, innerRef: n, ...r } = this.props;
    return Le.createElement(
      Le.Fragment,
      null,
      Le.createElement("div", { ref: nD(n, this.editorContentRef), ...r }),
      (e == null ? void 0 : e.contentComponent) &&
        Le.createElement(rD, { contentComponent: e.contentComponent })
    );
  }
}
const sD = b.forwardRef((t, e) => {
    const n = Le.useMemo(
      () => Math.floor(Math.random() * 4294967295).toString(),
      [t.editor]
    );
    return Le.createElement(iD, { key: n, innerRef: e, ...t });
  }),
  lD = Le.memo(sD);
var aD = function t(e, n) {
    if (e === n) return !0;
    if (e && n && typeof e == "object" && typeof n == "object") {
      if (e.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(e)) {
        if (((r = e.length), r != n.length)) return !1;
        for (o = r; o-- !== 0; ) if (!t(e[o], n[o])) return !1;
        return !0;
      }
      if (e instanceof Map && n instanceof Map) {
        if (e.size !== n.size) return !1;
        for (o of e.entries()) if (!n.has(o[0])) return !1;
        for (o of e.entries()) if (!t(o[1], n.get(o[0]))) return !1;
        return !0;
      }
      if (e instanceof Set && n instanceof Set) {
        if (e.size !== n.size) return !1;
        for (o of e.entries()) if (!n.has(o[0])) return !1;
        return !0;
      }
      if (ArrayBuffer.isView(e) && ArrayBuffer.isView(n)) {
        if (((r = e.length), r != n.length)) return !1;
        for (o = r; o-- !== 0; ) if (e[o] !== n[o]) return !1;
        return !0;
      }
      if (e.constructor === RegExp)
        return e.source === n.source && e.flags === n.flags;
      if (e.valueOf !== Object.prototype.valueOf)
        return e.valueOf() === n.valueOf();
      if (e.toString !== Object.prototype.toString)
        return e.toString() === n.toString();
      if (((i = Object.keys(e)), (r = i.length), r !== Object.keys(n).length))
        return !1;
      for (o = r; o-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var l = i[o];
        if (!(l === "_owner" && e.$$typeof) && !t(e[l], n[l])) return !1;
      }
      return !0;
    }
    return e !== e && n !== n;
  },
  uD = eD(aD),
  YS = { exports: {} },
  Ah = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Uw;
function cD() {
  if (Uw) return Ah;
  Uw = 1;
  var t = Le,
    e = Lg;
  function n(f, p) {
    return (f === p && (f !== 0 || 1 / f === 1 / p)) || (f !== f && p !== p);
  }
  var r = typeof Object.is == "function" ? Object.is : n,
    o = e.useSyncExternalStore,
    i = t.useRef,
    l = t.useEffect,
    u = t.useMemo,
    c = t.useDebugValue;
  return (
    (Ah.useSyncExternalStoreWithSelector = function (f, p, m, y, v) {
      var x = i(null);
      if (x.current === null) {
        var S = { hasValue: !1, value: null };
        x.current = S;
      } else S = x.current;
      x = u(
        function () {
          function E(R) {
            if (!N) {
              if (((N = !0), ($ = R), (R = y(R)), v !== void 0 && S.hasValue)) {
                var F = S.value;
                if (v(F, R)) return (M = F);
              }
              return (M = R);
            }
            if (((F = M), r($, R))) return F;
            var H = y(R);
            return v !== void 0 && v(F, H) ? F : (($ = R), (M = H));
          }
          var N = !1,
            $,
            M,
            I = m === void 0 ? null : m;
          return [
            function () {
              return E(p());
            },
            I === null
              ? void 0
              : function () {
                  return E(I());
                },
          ];
        },
        [p, m, y, v]
      );
      var C = o(f, x[0], x[1]);
      return (
        l(
          function () {
            (S.hasValue = !0), (S.value = C);
          },
          [C]
        ),
        c(C),
        C
      );
    }),
    Ah
  );
}
YS.exports = cD();
var dD = YS.exports;
const fD = typeof window < "u" ? b.useLayoutEffect : b.useEffect;
class pD {
  constructor(e) {
    (this.transactionNumber = 0),
      (this.lastTransactionNumber = 0),
      (this.subscribers = new Set()),
      (this.editor = e),
      (this.lastSnapshot = { editor: e, transactionNumber: 0 }),
      (this.getSnapshot = this.getSnapshot.bind(this)),
      (this.getServerSnapshot = this.getServerSnapshot.bind(this)),
      (this.watch = this.watch.bind(this)),
      (this.subscribe = this.subscribe.bind(this));
  }
  getSnapshot() {
    return this.transactionNumber === this.lastTransactionNumber
      ? this.lastSnapshot
      : ((this.lastTransactionNumber = this.transactionNumber),
        (this.lastSnapshot = {
          editor: this.editor,
          transactionNumber: this.transactionNumber,
        }),
        this.lastSnapshot);
  }
  getServerSnapshot() {
    return { editor: null, transactionNumber: 0 };
  }
  subscribe(e) {
    return (
      this.subscribers.add(e),
      () => {
        this.subscribers.delete(e);
      }
    );
  }
  watch(e) {
    if (((this.editor = e), this.editor)) {
      const n = () => {
          (this.transactionNumber += 1), this.subscribers.forEach((o) => o());
        },
        r = this.editor;
      return (
        r.on("transaction", n),
        () => {
          r.off("transaction", n);
        }
      );
    }
  }
}
function hD(t) {
  var e;
  const [n] = b.useState(() => new pD(t.editor)),
    r = dD.useSyncExternalStoreWithSelector(
      n.subscribe,
      n.getSnapshot,
      n.getServerSnapshot,
      t.selector,
      (e = t.equalityFn) !== null && e !== void 0 ? e : uD
    );
  return fD(() => n.watch(t.editor), [t.editor, n]), b.useDebugValue(r), r;
}
const mD = !1,
  Nm = typeof window > "u",
  gD = Nm || !!(typeof window < "u" && window.next);
class $g {
  constructor(e) {
    (this.editor = null),
      (this.subscriptions = new Set()),
      (this.isComponentMounted = !1),
      (this.previousDeps = null),
      (this.instanceId = ""),
      (this.options = e),
      (this.subscriptions = new Set()),
      this.setEditor(this.getInitialEditor()),
      this.scheduleDestroy(),
      (this.getEditor = this.getEditor.bind(this)),
      (this.getServerSnapshot = this.getServerSnapshot.bind(this)),
      (this.subscribe = this.subscribe.bind(this)),
      (this.refreshEditorInstance = this.refreshEditorInstance.bind(this)),
      (this.scheduleDestroy = this.scheduleDestroy.bind(this)),
      (this.onRender = this.onRender.bind(this)),
      (this.createEditor = this.createEditor.bind(this));
  }
  setEditor(e) {
    (this.editor = e),
      (this.instanceId = Math.random().toString(36).slice(2, 9)),
      this.subscriptions.forEach((n) => n());
  }
  getInitialEditor() {
    return this.options.current.immediatelyRender === void 0
      ? Nm || gD
        ? null
        : this.createEditor()
      : (this.options.current.immediatelyRender,
        this.options.current.immediatelyRender ? this.createEditor() : null);
  }
  createEditor() {
    const e = {
      ...this.options.current,
      onBeforeCreate: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onBeforeCreate) === null ||
          i === void 0
          ? void 0
          : i.call(o, ...r);
      },
      onBlur: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onBlur) === null || i === void 0
          ? void 0
          : i.call(o, ...r);
      },
      onCreate: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onCreate) === null ||
          i === void 0
          ? void 0
          : i.call(o, ...r);
      },
      onDestroy: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onDestroy) === null ||
          i === void 0
          ? void 0
          : i.call(o, ...r);
      },
      onFocus: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onFocus) === null || i === void 0
          ? void 0
          : i.call(o, ...r);
      },
      onSelectionUpdate: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onSelectionUpdate) === null ||
          i === void 0
          ? void 0
          : i.call(o, ...r);
      },
      onTransaction: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onTransaction) === null ||
          i === void 0
          ? void 0
          : i.call(o, ...r);
      },
      onUpdate: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onUpdate) === null ||
          i === void 0
          ? void 0
          : i.call(o, ...r);
      },
      onContentError: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onContentError) === null ||
          i === void 0
          ? void 0
          : i.call(o, ...r);
      },
      onDrop: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onDrop) === null || i === void 0
          ? void 0
          : i.call(o, ...r);
      },
      onPaste: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onPaste) === null || i === void 0
          ? void 0
          : i.call(o, ...r);
      },
    };
    return new b3(e);
  }
  getEditor() {
    return this.editor;
  }
  getServerSnapshot() {
    return null;
  }
  subscribe(e) {
    return (
      this.subscriptions.add(e),
      () => {
        this.subscriptions.delete(e);
      }
    );
  }
  static compareOptions(e, n) {
    return Object.keys(e).every((r) =>
      [
        "onCreate",
        "onBeforeCreate",
        "onDestroy",
        "onUpdate",
        "onTransaction",
        "onFocus",
        "onBlur",
        "onSelectionUpdate",
        "onContentError",
        "onDrop",
        "onPaste",
      ].includes(r)
        ? !0
        : r === "extensions" && e.extensions && n.extensions
        ? e.extensions.length !== n.extensions.length
          ? !1
          : e.extensions.every((o, i) => {
              var l;
              return (
                o ===
                ((l = n.extensions) === null || l === void 0 ? void 0 : l[i])
              );
            })
        : e[r] === n[r]
    );
  }
  onRender(e) {
    return () => (
      (this.isComponentMounted = !0),
      clearTimeout(this.scheduledDestructionTimeout),
      this.editor && !this.editor.isDestroyed && e.length === 0
        ? $g.compareOptions(this.options.current, this.editor.options) ||
          this.editor.setOptions({
            ...this.options.current,
            editable: this.editor.isEditable,
          })
        : this.refreshEditorInstance(e),
      () => {
        (this.isComponentMounted = !1), this.scheduleDestroy();
      }
    );
  }
  refreshEditorInstance(e) {
    if (this.editor && !this.editor.isDestroyed) {
      if (this.previousDeps === null) {
        this.previousDeps = e;
        return;
      }
      if (
        this.previousDeps.length === e.length &&
        this.previousDeps.every((r, o) => r === e[o])
      )
        return;
    }
    this.editor && !this.editor.isDestroyed && this.editor.destroy(),
      this.setEditor(this.createEditor()),
      (this.previousDeps = e);
  }
  scheduleDestroy() {
    const e = this.instanceId,
      n = this.editor;
    this.scheduledDestructionTimeout = setTimeout(() => {
      if (this.isComponentMounted && this.instanceId === e) {
        n && n.setOptions(this.options.current);
        return;
      }
      n &&
        !n.isDestroyed &&
        (n.destroy(), this.instanceId === e && this.setEditor(null));
    }, 1);
  }
}
function yD(t = {}, e = []) {
  const n = b.useRef(t);
  n.current = t;
  const [r] = b.useState(() => new $g(n)),
    o = Lg.useSyncExternalStore(r.subscribe, r.getEditor, r.getServerSnapshot);
  return (
    b.useDebugValue(o),
    b.useEffect(r.onRender(e)),
    hD({
      editor: o,
      selector: ({ transactionNumber: i }) =>
        t.shouldRerenderOnTransaction === !1
          ? null
          : t.immediatelyRender && i === 0
          ? 0
          : i + 1,
    }),
    o
  );
}
const _g = b.createContext({ editor: null }),
  vD = _g.Consumer,
  Qo = () => b.useContext(_g);
function wD({
  children: t,
  slotAfter: e,
  slotBefore: n,
  editorContainerProps: r = {},
  ...o
}) {
  const i = yD(o);
  return i
    ? Le.createElement(
        _g.Provider,
        { value: { editor: i } },
        n,
        Le.createElement(vD, null, ({ editor: l }) =>
          Le.createElement(lD, { editor: l, ...r })
        ),
        t,
        e
      )
    : null;
}
const xD = (t) => {
    const [e, n] = b.useState(null),
      { editor: r } = Qo();
    return (
      b.useEffect(() => {
        var o;
        if (
          !e ||
          (!((o = t.editor) === null || o === void 0) && o.isDestroyed) ||
          (r != null && r.isDestroyed)
        )
          return;
        const {
            pluginKey: i = "bubbleMenu",
            editor: l,
            tippyOptions: u = {},
            updateDelay: c,
            shouldShow: f = null,
          } = t,
          p = l || r;
        if (!p) {
          console.warn(
            "BubbleMenu component is not rendered inside of an editor component or does not have editor prop."
          );
          return;
        }
        const m = GS({
          updateDelay: c,
          editor: p,
          element: e,
          pluginKey: i,
          shouldShow: f,
          tippyOptions: u,
        });
        return (
          p.registerPlugin(m),
          () => {
            p.unregisterPlugin(i);
          }
        );
      }, [t.editor, r, e]),
      Le.createElement(
        "div",
        { ref: n, className: t.className, style: { visibility: "hidden" } },
        t.children
      )
    );
  },
  bD = (t) => {
    const [e, n] = b.useState(null),
      { editor: r } = Qo();
    return (
      b.useEffect(() => {
        var o;
        if (
          !e ||
          (!((o = t.editor) === null || o === void 0) && o.isDestroyed) ||
          (r != null && r.isDestroyed)
        )
          return;
        const {
            pluginKey: i = "floatingMenu",
            editor: l,
            tippyOptions: u = {},
            shouldShow: c = null,
          } = t,
          f = l || r;
        if (!f) {
          console.warn(
            "FloatingMenu component is not rendered inside of an editor component or does not have editor prop."
          );
          return;
        }
        const p = JS({
          pluginKey: i,
          editor: f,
          element: e,
          tippyOptions: u,
          shouldShow: c,
        });
        return (
          f.registerPlugin(p),
          () => {
            f.unregisterPlugin(i);
          }
        );
      }, [t.editor, r, e]),
      Le.createElement(
        "div",
        { ref: n, className: t.className, style: { visibility: "hidden" } },
        t.children
      )
    );
  },
  SD = b.createContext({ onDragStart: void 0 }),
  CD = () => b.useContext(SD);
Le.forwardRef((t, e) => {
  const { onDragStart: n } = CD(),
    r = t.as || "div";
  return Le.createElement(r, {
    ...t,
    ref: e,
    "data-node-view-wrapper": "",
    onDragStart: n,
    style: { whiteSpace: "normal", ...t.style },
  });
});
const kD = /^\s*>\s$/,
  ED = Xn.create({
    name: "blockquote",
    addOptions() {
      return { HTMLAttributes: {} };
    },
    content: "block+",
    group: "block",
    defining: !0,
    parseHTML() {
      return [{ tag: "blockquote" }];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["blockquote", dt(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
      return {
        setBlockquote:
          () =>
          ({ commands: t }) =>
            t.wrapIn(this.name),
        toggleBlockquote:
          () =>
          ({ commands: t }) =>
            t.toggleWrap(this.name),
        unsetBlockquote:
          () =>
          ({ commands: t }) =>
            t.lift(this.name),
      };
    },
    addKeyboardShortcuts() {
      return { "Mod-Shift-b": () => this.editor.commands.toggleBlockquote() };
    },
    addInputRules() {
      return [ka({ find: kD, type: this.type })];
    },
  }),
  MD = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/,
  OD = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g,
  TD = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/,
  ND = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g,
  AD = Gn.create({
    name: "bold",
    addOptions() {
      return { HTMLAttributes: {} };
    },
    parseHTML() {
      return [
        { tag: "strong" },
        { tag: "b", getAttrs: (t) => t.style.fontWeight !== "normal" && null },
        {
          style: "font-weight=400",
          clearMark: (t) => t.type.name === this.name,
        },
        {
          style: "font-weight",
          getAttrs: (t) => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null,
        },
      ];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["strong", dt(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
      return {
        setBold:
          () =>
          ({ commands: t }) =>
            t.setMark(this.name),
        toggleBold:
          () =>
          ({ commands: t }) =>
            t.toggleMark(this.name),
        unsetBold:
          () =>
          ({ commands: t }) =>
            t.unsetMark(this.name),
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-b": () => this.editor.commands.toggleBold(),
        "Mod-B": () => this.editor.commands.toggleBold(),
      };
    },
    addInputRules() {
      return [
        qs({ find: MD, type: this.type }),
        qs({ find: TD, type: this.type }),
      ];
    },
    addPasteRules() {
      return [
        _i({ find: OD, type: this.type }),
        _i({ find: ND, type: this.type }),
      ];
    },
  }),
  RD = "listItem",
  Kw = "textStyle",
  qw = /^\s*([-+*])\s$/,
  PD = Xn.create({
    name: "bulletList",
    addOptions() {
      return {
        itemTypeName: "listItem",
        HTMLAttributes: {},
        keepMarks: !1,
        keepAttributes: !1,
      };
    },
    group: "block list",
    content() {
      return `${this.options.itemTypeName}+`;
    },
    parseHTML() {
      return [{ tag: "ul" }];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["ul", dt(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
      return {
        toggleBulletList:
          () =>
          ({ commands: t, chain: e }) =>
            this.options.keepAttributes
              ? e()
                  .toggleList(
                    this.name,
                    this.options.itemTypeName,
                    this.options.keepMarks
                  )
                  .updateAttributes(RD, this.editor.getAttributes(Kw))
                  .run()
              : t.toggleList(
                  this.name,
                  this.options.itemTypeName,
                  this.options.keepMarks
                ),
      };
    },
    addKeyboardShortcuts() {
      return { "Mod-Shift-8": () => this.editor.commands.toggleBulletList() };
    },
    addInputRules() {
      let t = ka({ find: qw, type: this.type });
      return (
        (this.options.keepMarks || this.options.keepAttributes) &&
          (t = ka({
            find: qw,
            type: this.type,
            keepMarks: this.options.keepMarks,
            keepAttributes: this.options.keepAttributes,
            getAttributes: () => this.editor.getAttributes(Kw),
            editor: this.editor,
          })),
        [t]
      );
    },
  }),
  DD = /(^|[^`])`([^`]+)`(?!`)/,
  ID = /(^|[^`])`([^`]+)`(?!`)/g,
  LD = Gn.create({
    name: "code",
    addOptions() {
      return { HTMLAttributes: {} };
    },
    excludes: "_",
    code: !0,
    exitable: !0,
    parseHTML() {
      return [{ tag: "code" }];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["code", dt(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
      return {
        setCode:
          () =>
          ({ commands: t }) =>
            t.setMark(this.name),
        toggleCode:
          () =>
          ({ commands: t }) =>
            t.toggleMark(this.name),
        unsetCode:
          () =>
          ({ commands: t }) =>
            t.unsetMark(this.name),
      };
    },
    addKeyboardShortcuts() {
      return { "Mod-e": () => this.editor.commands.toggleCode() };
    },
    addInputRules() {
      return [qs({ find: DD, type: this.type })];
    },
    addPasteRules() {
      return [_i({ find: ID, type: this.type })];
    },
  }),
  $D = /^```([a-z]+)?[\s\n]$/,
  _D = /^~~~([a-z]+)?[\s\n]$/,
  FD = Xn.create({
    name: "codeBlock",
    addOptions() {
      return {
        languageClassPrefix: "language-",
        exitOnTripleEnter: !0,
        exitOnArrowDown: !0,
        defaultLanguage: null,
        HTMLAttributes: {},
      };
    },
    content: "text*",
    marks: "",
    group: "block",
    code: !0,
    defining: !0,
    addAttributes() {
      return {
        language: {
          default: this.options.defaultLanguage,
          parseHTML: (t) => {
            var e;
            const { languageClassPrefix: n } = this.options,
              i = [
                ...(((e = t.firstElementChild) === null || e === void 0
                  ? void 0
                  : e.classList) || []),
              ]
                .filter((l) => l.startsWith(n))
                .map((l) => l.replace(n, ""))[0];
            return i || null;
          },
          rendered: !1,
        },
      };
    },
    parseHTML() {
      return [{ tag: "pre", preserveWhitespace: "full" }];
    },
    renderHTML({ node: t, HTMLAttributes: e }) {
      return [
        "pre",
        dt(this.options.HTMLAttributes, e),
        [
          "code",
          {
            class: t.attrs.language
              ? this.options.languageClassPrefix + t.attrs.language
              : null,
          },
          0,
        ],
      ];
    },
    addCommands() {
      return {
        setCodeBlock:
          (t) =>
          ({ commands: e }) =>
            e.setNode(this.name, t),
        toggleCodeBlock:
          (t) =>
          ({ commands: e }) =>
            e.toggleNode(this.name, "paragraph", t),
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
        Backspace: () => {
          const { empty: t, $anchor: e } = this.editor.state.selection,
            n = e.pos === 1;
          return !t || e.parent.type.name !== this.name
            ? !1
            : n || !e.parent.textContent.length
            ? this.editor.commands.clearNodes()
            : !1;
        },
        Enter: ({ editor: t }) => {
          if (!this.options.exitOnTripleEnter) return !1;
          const { state: e } = t,
            { selection: n } = e,
            { $from: r, empty: o } = n;
          if (!o || r.parent.type !== this.type) return !1;
          const i = r.parentOffset === r.parent.nodeSize - 2,
            l = r.parent.textContent.endsWith(`

`);
          return !i || !l
            ? !1
            : t
                .chain()
                .command(({ tr: u }) => (u.delete(r.pos - 2, r.pos), !0))
                .exitCode()
                .run();
        },
        ArrowDown: ({ editor: t }) => {
          if (!this.options.exitOnArrowDown) return !1;
          const { state: e } = t,
            { selection: n, doc: r } = e,
            { $from: o, empty: i } = n;
          if (
            !i ||
            o.parent.type !== this.type ||
            !(o.parentOffset === o.parent.nodeSize - 2)
          )
            return !1;
          const u = o.after();
          return u === void 0
            ? !1
            : r.nodeAt(u)
            ? t.commands.command(
                ({ tr: f }) => (f.setSelection(Ae.near(r.resolve(u))), !0)
              )
            : t.commands.exitCode();
        },
      };
    },
    addInputRules() {
      return [
        Cm({
          find: $D,
          type: this.type,
          getAttributes: (t) => ({ language: t[1] }),
        }),
        Cm({
          find: _D,
          type: this.type,
          getAttributes: (t) => ({ language: t[1] }),
        }),
      ];
    },
    addProseMirrorPlugins() {
      return [
        new pt({
          key: new Wt("codeBlockVSCodeHandler"),
          props: {
            handlePaste: (t, e) => {
              if (!e.clipboardData || this.editor.isActive(this.type.name))
                return !1;
              const n = e.clipboardData.getData("text/plain"),
                r = e.clipboardData.getData("vscode-editor-data"),
                o = r ? JSON.parse(r) : void 0,
                i = o == null ? void 0 : o.mode;
              if (!n || !i) return !1;
              const { tr: l, schema: u } = t.state,
                c = u.text(
                  n.replace(
                    /\r\n?/g,
                    `
`
                  )
                );
              return (
                l.replaceSelectionWith(this.type.create({ language: i }, c)),
                l.selection.$from.parent.type !== this.type &&
                  l.setSelection(
                    Te.near(l.doc.resolve(Math.max(0, l.selection.from - 2)))
                  ),
                l.setMeta("paste", !0),
                t.dispatch(l),
                !0
              );
            },
          },
        }),
      ];
    },
  }),
  zD = Xn.create({ name: "doc", topNode: !0, content: "block+" });
function jD(t = {}) {
  return new pt({
    view(e) {
      return new BD(e, t);
    },
  });
}
class BD {
  constructor(e, n) {
    var r;
    (this.editorView = e),
      (this.cursorPos = null),
      (this.element = null),
      (this.timeout = -1),
      (this.width = (r = n.width) !== null && r !== void 0 ? r : 1),
      (this.color = n.color === !1 ? void 0 : n.color || "black"),
      (this.class = n.class),
      (this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((o) => {
        let i = (l) => {
          this[o](l);
        };
        return e.dom.addEventListener(o, i), { name: o, handler: i };
      }));
  }
  destroy() {
    this.handlers.forEach(({ name: e, handler: n }) =>
      this.editorView.dom.removeEventListener(e, n)
    );
  }
  update(e, n) {
    this.cursorPos != null &&
      n.doc != e.state.doc &&
      (this.cursorPos > e.state.doc.content.size
        ? this.setCursor(null)
        : this.updateOverlay());
  }
  setCursor(e) {
    e != this.cursorPos &&
      ((this.cursorPos = e),
      e == null
        ? (this.element.parentNode.removeChild(this.element),
          (this.element = null))
        : this.updateOverlay());
  }
  updateOverlay() {
    let e = this.editorView.state.doc.resolve(this.cursorPos),
      n = !e.parent.inlineContent,
      r;
    if (n) {
      let u = e.nodeBefore,
        c = e.nodeAfter;
      if (u || c) {
        let f = this.editorView.nodeDOM(this.cursorPos - (u ? u.nodeSize : 0));
        if (f) {
          let p = f.getBoundingClientRect(),
            m = u ? p.bottom : p.top;
          u &&
            c &&
            (m =
              (m +
                this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect()
                  .top) /
              2),
            (r = {
              left: p.left,
              right: p.right,
              top: m - this.width / 2,
              bottom: m + this.width / 2,
            });
        }
      }
    }
    if (!r) {
      let u = this.editorView.coordsAtPos(this.cursorPos);
      r = {
        left: u.left - this.width / 2,
        right: u.left + this.width / 2,
        top: u.top,
        bottom: u.bottom,
      };
    }
    let o = this.editorView.dom.offsetParent;
    this.element ||
      ((this.element = o.appendChild(document.createElement("div"))),
      this.class && (this.element.className = this.class),
      (this.element.style.cssText =
        "position: absolute; z-index: 50; pointer-events: none;"),
      this.color && (this.element.style.backgroundColor = this.color)),
      this.element.classList.toggle("prosemirror-dropcursor-block", n),
      this.element.classList.toggle("prosemirror-dropcursor-inline", !n);
    let i, l;
    if (!o || (o == document.body && getComputedStyle(o).position == "static"))
      (i = -pageXOffset), (l = -pageYOffset);
    else {
      let u = o.getBoundingClientRect();
      (i = u.left - o.scrollLeft), (l = u.top - o.scrollTop);
    }
    (this.element.style.left = r.left - i + "px"),
      (this.element.style.top = r.top - l + "px"),
      (this.element.style.width = r.right - r.left + "px"),
      (this.element.style.height = r.bottom - r.top + "px");
  }
  scheduleRemoval(e) {
    clearTimeout(this.timeout),
      (this.timeout = setTimeout(() => this.setCursor(null), e));
  }
  dragover(e) {
    if (!this.editorView.editable) return;
    let n = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }),
      r = n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside),
      o = r && r.type.spec.disableDropCursor,
      i = typeof o == "function" ? o(this.editorView, n, e) : o;
    if (n && !i) {
      let l = n.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let u = kb(
          this.editorView.state.doc,
          l,
          this.editorView.dragging.slice
        );
        u != null && (l = u);
      }
      this.setCursor(l), this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(e) {
    (e.target == this.editorView.dom ||
      !this.editorView.dom.contains(e.relatedTarget)) &&
      this.setCursor(null);
  }
}
const HD = et.create({
  name: "dropCursor",
  addOptions() {
    return { color: "currentColor", width: 1, class: void 0 };
  },
  addProseMirrorPlugins() {
    return [jD(this.options)];
  },
});
class Ze extends Ae {
  constructor(e) {
    super(e, e);
  }
  map(e, n) {
    let r = e.resolve(n.map(this.head));
    return Ze.valid(r) ? new Ze(r) : Ae.near(r);
  }
  content() {
    return ae.empty;
  }
  eq(e) {
    return e instanceof Ze && e.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new Ze(e.resolve(n.pos));
  }
  getBookmark() {
    return new Fg(this.anchor);
  }
  static valid(e) {
    let n = e.parent;
    if (n.isTextblock || !VD(e) || !WD(e)) return !1;
    let r = n.type.spec.allowGapCursor;
    if (r != null) return r;
    let o = n.contentMatchAt(e.index()).defaultType;
    return o && o.isTextblock;
  }
  static findGapCursorFrom(e, n, r = !1) {
    e: for (;;) {
      if (!r && Ze.valid(e)) return e;
      let o = e.pos,
        i = null;
      for (let l = e.depth; ; l--) {
        let u = e.node(l);
        if (n > 0 ? e.indexAfter(l) < u.childCount : e.index(l) > 0) {
          i = u.child(n > 0 ? e.indexAfter(l) : e.index(l) - 1);
          break;
        } else if (l == 0) return null;
        o += n;
        let c = e.doc.resolve(o);
        if (Ze.valid(c)) return c;
      }
      for (;;) {
        let l = n > 0 ? i.firstChild : i.lastChild;
        if (!l) {
          if (i.isAtom && !i.isText && !ke.isSelectable(i)) {
            (e = e.doc.resolve(o + i.nodeSize * n)), (r = !1);
            continue e;
          }
          break;
        }
        (i = l), (o += n);
        let u = e.doc.resolve(o);
        if (Ze.valid(u)) return u;
      }
      return null;
    }
  }
}
Ze.prototype.visible = !1;
Ze.findFrom = Ze.findGapCursorFrom;
Ae.jsonID("gapcursor", Ze);
class Fg {
  constructor(e) {
    this.pos = e;
  }
  map(e) {
    return new Fg(e.map(this.pos));
  }
  resolve(e) {
    let n = e.resolve(this.pos);
    return Ze.valid(n) ? new Ze(n) : Ae.near(n);
  }
}
function VD(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.index(e),
      r = t.node(e);
    if (n == 0) {
      if (r.type.spec.isolating) return !0;
      continue;
    }
    for (let o = r.child(n - 1); ; o = o.lastChild) {
      if (
        (o.childCount == 0 && !o.inlineContent) ||
        o.isAtom ||
        o.type.spec.isolating
      )
        return !0;
      if (o.inlineContent) return !1;
    }
  }
  return !0;
}
function WD(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.indexAfter(e),
      r = t.node(e);
    if (n == r.childCount) {
      if (r.type.spec.isolating) return !0;
      continue;
    }
    for (let o = r.child(n); ; o = o.firstChild) {
      if (
        (o.childCount == 0 && !o.inlineContent) ||
        o.isAtom ||
        o.type.spec.isolating
      )
        return !0;
      if (o.inlineContent) return !1;
    }
  }
  return !0;
}
function UD() {
  return new pt({
    props: {
      decorations: JD,
      createSelectionBetween(t, e, n) {
        return e.pos == n.pos && Ze.valid(n) ? new Ze(n) : null;
      },
      handleClick: qD,
      handleKeyDown: KD,
      handleDOMEvents: { beforeinput: GD },
    },
  });
}
const KD = dS({
  ArrowLeft: hc("horiz", -1),
  ArrowRight: hc("horiz", 1),
  ArrowUp: hc("vert", -1),
  ArrowDown: hc("vert", 1),
});
function hc(t, e) {
  const n = t == "vert" ? (e > 0 ? "down" : "up") : e > 0 ? "right" : "left";
  return function (r, o, i) {
    let l = r.selection,
      u = e > 0 ? l.$to : l.$from,
      c = l.empty;
    if (l instanceof Te) {
      if (!i.endOfTextblock(n) || u.depth == 0) return !1;
      (c = !1), (u = r.doc.resolve(e > 0 ? u.after() : u.before()));
    }
    let f = Ze.findGapCursorFrom(u, e, c);
    return f ? (o && o(r.tr.setSelection(new Ze(f))), !0) : !1;
  };
}
function qD(t, e, n) {
  if (!t || !t.editable) return !1;
  let r = t.state.doc.resolve(e);
  if (!Ze.valid(r)) return !1;
  let o = t.posAtCoords({ left: n.clientX, top: n.clientY });
  return o && o.inside > -1 && ke.isSelectable(t.state.doc.nodeAt(o.inside))
    ? !1
    : (t.dispatch(t.state.tr.setSelection(new Ze(r))), !0);
}
function GD(t, e) {
  if (
    e.inputType != "insertCompositionText" ||
    !(t.state.selection instanceof Ze)
  )
    return !1;
  let { $from: n } = t.state.selection,
    r = n.parent
      .contentMatchAt(n.index())
      .findWrapping(t.state.schema.nodes.text);
  if (!r) return !1;
  let o = J.empty;
  for (let l = r.length - 1; l >= 0; l--)
    o = J.from(r[l].createAndFill(null, o));
  let i = t.state.tr.replace(n.pos, n.pos, new ae(o, 0, 0));
  return i.setSelection(Te.near(i.doc.resolve(n.pos + 1))), t.dispatch(i), !1;
}
function JD(t) {
  if (!(t.selection instanceof Ze)) return null;
  let e = document.createElement("div");
  return (
    (e.className = "ProseMirror-gapcursor"),
    ct.create(t.doc, [Tn.widget(t.selection.head, e, { key: "gapcursor" })])
  );
}
const QD = et.create({
    name: "gapCursor",
    addProseMirrorPlugins() {
      return [UD()];
    },
    extendNodeSchema(t) {
      var e;
      const n = { name: t.name, options: t.options, storage: t.storage };
      return {
        allowGapCursor:
          (e = Pe(me(t, "allowGapCursor", n))) !== null && e !== void 0
            ? e
            : null,
      };
    },
  }),
  YD = Xn.create({
    name: "hardBreak",
    addOptions() {
      return { keepMarks: !0, HTMLAttributes: {} };
    },
    inline: !0,
    group: "inline",
    selectable: !1,
    linebreakReplacement: !0,
    parseHTML() {
      return [{ tag: "br" }];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["br", dt(this.options.HTMLAttributes, t)];
    },
    renderText() {
      return `
`;
    },
    addCommands() {
      return {
        setHardBreak:
          () =>
          ({ commands: t, chain: e, state: n, editor: r }) =>
            t.first([
              () => t.exitCode(),
              () =>
                t.command(() => {
                  const { selection: o, storedMarks: i } = n;
                  if (o.$from.parent.type.spec.isolating) return !1;
                  const { keepMarks: l } = this.options,
                    { splittableMarks: u } = r.extensionManager,
                    c = i || (o.$to.parentOffset && o.$from.marks());
                  return e()
                    .insertContent({ type: this.name })
                    .command(({ tr: f, dispatch: p }) => {
                      if (p && c && l) {
                        const m = c.filter((y) => u.includes(y.type.name));
                        f.ensureMarks(m);
                      }
                      return !0;
                    })
                    .run();
                }),
            ]),
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Enter": () => this.editor.commands.setHardBreak(),
        "Shift-Enter": () => this.editor.commands.setHardBreak(),
      };
    },
  }),
  XD = Xn.create({
    name: "heading",
    addOptions() {
      return { levels: [1, 2, 3, 4, 5, 6], HTMLAttributes: {} };
    },
    content: "inline*",
    group: "block",
    defining: !0,
    addAttributes() {
      return { level: { default: 1, rendered: !1 } };
    },
    parseHTML() {
      return this.options.levels.map((t) => ({
        tag: `h${t}`,
        attrs: { level: t },
      }));
    },
    renderHTML({ node: t, HTMLAttributes: e }) {
      return [
        `h${
          this.options.levels.includes(t.attrs.level)
            ? t.attrs.level
            : this.options.levels[0]
        }`,
        dt(this.options.HTMLAttributes, e),
        0,
      ];
    },
    addCommands() {
      return {
        setHeading:
          (t) =>
          ({ commands: e }) =>
            this.options.levels.includes(t.level)
              ? e.setNode(this.name, t)
              : !1,
        toggleHeading:
          (t) =>
          ({ commands: e }) =>
            this.options.levels.includes(t.level)
              ? e.toggleNode(this.name, "paragraph", t)
              : !1,
      };
    },
    addKeyboardShortcuts() {
      return this.options.levels.reduce(
        (t, e) => ({
          ...t,
          [`Mod-Alt-${e}`]: () =>
            this.editor.commands.toggleHeading({ level: e }),
        }),
        {}
      );
    },
    addInputRules() {
      return this.options.levels.map((t) =>
        Cm({
          find: new RegExp(
            `^(#{${Math.min(...this.options.levels)},${t}})\\s$`
          ),
          type: this.type,
          getAttributes: { level: t },
        })
      );
    },
  });
var Zc = 200,
  wt = function () {};
wt.prototype.append = function (e) {
  return e.length
    ? ((e = wt.from(e)),
      (!this.length && e) ||
        (e.length < Zc && this.leafAppend(e)) ||
        (this.length < Zc && e.leafPrepend(this)) ||
        this.appendInner(e))
    : this;
};
wt.prototype.prepend = function (e) {
  return e.length ? wt.from(e).append(this) : this;
};
wt.prototype.appendInner = function (e) {
  return new ZD(this, e);
};
wt.prototype.slice = function (e, n) {
  return (
    e === void 0 && (e = 0),
    n === void 0 && (n = this.length),
    e >= n
      ? wt.empty
      : this.sliceInner(Math.max(0, e), Math.min(this.length, n))
  );
};
wt.prototype.get = function (e) {
  if (!(e < 0 || e >= this.length)) return this.getInner(e);
};
wt.prototype.forEach = function (e, n, r) {
  n === void 0 && (n = 0),
    r === void 0 && (r = this.length),
    n <= r
      ? this.forEachInner(e, n, r, 0)
      : this.forEachInvertedInner(e, n, r, 0);
};
wt.prototype.map = function (e, n, r) {
  n === void 0 && (n = 0), r === void 0 && (r = this.length);
  var o = [];
  return (
    this.forEach(
      function (i, l) {
        return o.push(e(i, l));
      },
      n,
      r
    ),
    o
  );
};
wt.from = function (e) {
  return e instanceof wt ? e : e && e.length ? new XS(e) : wt.empty;
};
var XS = (function (t) {
  function e(r) {
    t.call(this), (this.values = r);
  }
  (e.__proto__ = t),
    (e.prototype = Object.create(t.prototype)),
    (e.prototype.constructor = e);
  var n = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return (
    (e.prototype.flatten = function () {
      return this.values;
    }),
    (e.prototype.sliceInner = function (o, i) {
      return o == 0 && i == this.length ? this : new e(this.values.slice(o, i));
    }),
    (e.prototype.getInner = function (o) {
      return this.values[o];
    }),
    (e.prototype.forEachInner = function (o, i, l, u) {
      for (var c = i; c < l; c++)
        if (o(this.values[c], u + c) === !1) return !1;
    }),
    (e.prototype.forEachInvertedInner = function (o, i, l, u) {
      for (var c = i - 1; c >= l; c--)
        if (o(this.values[c], u + c) === !1) return !1;
    }),
    (e.prototype.leafAppend = function (o) {
      if (this.length + o.length <= Zc)
        return new e(this.values.concat(o.flatten()));
    }),
    (e.prototype.leafPrepend = function (o) {
      if (this.length + o.length <= Zc)
        return new e(o.flatten().concat(this.values));
    }),
    (n.length.get = function () {
      return this.values.length;
    }),
    (n.depth.get = function () {
      return 0;
    }),
    Object.defineProperties(e.prototype, n),
    e
  );
})(wt);
wt.empty = new XS([]);
var ZD = (function (t) {
  function e(n, r) {
    t.call(this),
      (this.left = n),
      (this.right = r),
      (this.length = n.length + r.length),
      (this.depth = Math.max(n.depth, r.depth) + 1);
  }
  return (
    (e.__proto__ = t),
    (e.prototype = Object.create(t.prototype)),
    (e.prototype.constructor = e),
    (e.prototype.flatten = function () {
      return this.left.flatten().concat(this.right.flatten());
    }),
    (e.prototype.getInner = function (r) {
      return r < this.left.length
        ? this.left.get(r)
        : this.right.get(r - this.left.length);
    }),
    (e.prototype.forEachInner = function (r, o, i, l) {
      var u = this.left.length;
      if (
        (o < u && this.left.forEachInner(r, o, Math.min(i, u), l) === !1) ||
        (i > u &&
          this.right.forEachInner(
            r,
            Math.max(o - u, 0),
            Math.min(this.length, i) - u,
            l + u
          ) === !1)
      )
        return !1;
    }),
    (e.prototype.forEachInvertedInner = function (r, o, i, l) {
      var u = this.left.length;
      if (
        (o > u &&
          this.right.forEachInvertedInner(
            r,
            o - u,
            Math.max(i, u) - u,
            l + u
          ) === !1) ||
        (i < u &&
          this.left.forEachInvertedInner(r, Math.min(o, u), i, l) === !1)
      )
        return !1;
    }),
    (e.prototype.sliceInner = function (r, o) {
      if (r == 0 && o == this.length) return this;
      var i = this.left.length;
      return o <= i
        ? this.left.slice(r, o)
        : r >= i
        ? this.right.slice(r - i, o - i)
        : this.left.slice(r, i).append(this.right.slice(0, o - i));
    }),
    (e.prototype.leafAppend = function (r) {
      var o = this.right.leafAppend(r);
      if (o) return new e(this.left, o);
    }),
    (e.prototype.leafPrepend = function (r) {
      var o = this.left.leafPrepend(r);
      if (o) return new e(o, this.right);
    }),
    (e.prototype.appendInner = function (r) {
      return this.left.depth >= Math.max(this.right.depth, r.depth) + 1
        ? new e(this.left, new e(this.right, r))
        : new e(this, r);
    }),
    e
  );
})(wt);
const eI = 500;
class Un {
  constructor(e, n) {
    (this.items = e), (this.eventCount = n);
  }
  popEvent(e, n) {
    if (this.eventCount == 0) return null;
    let r = this.items.length;
    for (; ; r--)
      if (this.items.get(r - 1).selection) {
        --r;
        break;
      }
    let o, i;
    n && ((o = this.remapping(r, this.items.length)), (i = o.maps.length));
    let l = e.tr,
      u,
      c,
      f = [],
      p = [];
    return (
      this.items.forEach(
        (m, y) => {
          if (!m.step) {
            o || ((o = this.remapping(r, y + 1)), (i = o.maps.length)),
              i--,
              p.push(m);
            return;
          }
          if (o) {
            p.push(new vo(m.map));
            let v = m.step.map(o.slice(i)),
              x;
            v &&
              l.maybeStep(v).doc &&
              ((x = l.mapping.maps[l.mapping.maps.length - 1]),
              f.push(new vo(x, void 0, void 0, f.length + p.length))),
              i--,
              x && o.appendMap(x, i);
          } else l.maybeStep(m.step);
          if (m.selection)
            return (
              (u = o ? m.selection.map(o.slice(i)) : m.selection),
              (c = new Un(
                this.items.slice(0, r).append(p.reverse().concat(f)),
                this.eventCount - 1
              )),
              !1
            );
        },
        this.items.length,
        0
      ),
      { remaining: c, transform: l, selection: u }
    );
  }
  addTransform(e, n, r, o) {
    let i = [],
      l = this.eventCount,
      u = this.items,
      c = !o && u.length ? u.get(u.length - 1) : null;
    for (let p = 0; p < e.steps.length; p++) {
      let m = e.steps[p].invert(e.docs[p]),
        y = new vo(e.mapping.maps[p], m, n),
        v;
      (v = c && c.merge(y)) &&
        ((y = v), p ? i.pop() : (u = u.slice(0, u.length - 1))),
        i.push(y),
        n && (l++, (n = void 0)),
        o || (c = y);
    }
    let f = l - r.depth;
    return f > nI && ((u = tI(u, f)), (l -= f)), new Un(u.append(i), l);
  }
  remapping(e, n) {
    let r = new va();
    return (
      this.items.forEach(
        (o, i) => {
          let l =
            o.mirrorOffset != null && i - o.mirrorOffset >= e
              ? r.maps.length - o.mirrorOffset
              : void 0;
          r.appendMap(o.map, l);
        },
        e,
        n
      ),
      r
    );
  }
  addMaps(e) {
    return this.eventCount == 0
      ? this
      : new Un(this.items.append(e.map((n) => new vo(n))), this.eventCount);
  }
  rebased(e, n) {
    if (!this.eventCount) return this;
    let r = [],
      o = Math.max(0, this.items.length - n),
      i = e.mapping,
      l = e.steps.length,
      u = this.eventCount;
    this.items.forEach((y) => {
      y.selection && u--;
    }, o);
    let c = n;
    this.items.forEach((y) => {
      let v = i.getMirror(--c);
      if (v == null) return;
      l = Math.min(l, v);
      let x = i.maps[v];
      if (y.step) {
        let S = e.steps[v].invert(e.docs[v]),
          C = y.selection && y.selection.map(i.slice(c + 1, v));
        C && u++, r.push(new vo(x, S, C));
      } else r.push(new vo(x));
    }, o);
    let f = [];
    for (let y = n; y < l; y++) f.push(new vo(i.maps[y]));
    let p = this.items.slice(0, o).append(f).append(r),
      m = new Un(p, u);
    return (
      m.emptyItemCount() > eI && (m = m.compress(this.items.length - r.length)),
      m
    );
  }
  emptyItemCount() {
    let e = 0;
    return (
      this.items.forEach((n) => {
        n.step || e++;
      }),
      e
    );
  }
  compress(e = this.items.length) {
    let n = this.remapping(0, e),
      r = n.maps.length,
      o = [],
      i = 0;
    return (
      this.items.forEach(
        (l, u) => {
          if (u >= e) o.push(l), l.selection && i++;
          else if (l.step) {
            let c = l.step.map(n.slice(r)),
              f = c && c.getMap();
            if ((r--, f && n.appendMap(f, r), c)) {
              let p = l.selection && l.selection.map(n.slice(r));
              p && i++;
              let m = new vo(f.invert(), c, p),
                y,
                v = o.length - 1;
              (y = o.length && o[v].merge(m)) ? (o[v] = y) : o.push(m);
            }
          } else l.map && r--;
        },
        this.items.length,
        0
      ),
      new Un(wt.from(o.reverse()), i)
    );
  }
}
Un.empty = new Un(wt.empty, 0);
function tI(t, e) {
  let n;
  return (
    t.forEach((r, o) => {
      if (r.selection && e-- == 0) return (n = o), !1;
    }),
    t.slice(n)
  );
}
let vo = class ZS {
  constructor(e, n, r, o) {
    (this.map = e),
      (this.step = n),
      (this.selection = r),
      (this.mirrorOffset = o);
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let n = e.step.merge(this.step);
      if (n) return new ZS(n.getMap().invert(), n, this.selection);
    }
  }
};
class Mo {
  constructor(e, n, r, o, i) {
    (this.done = e),
      (this.undone = n),
      (this.prevRanges = r),
      (this.prevTime = o),
      (this.prevComposition = i);
  }
}
const nI = 20;
function rI(t, e, n, r) {
  let o = n.getMeta(Di),
    i;
  if (o) return o.historyState;
  n.getMeta(sI) && (t = new Mo(t.done, t.undone, null, 0, -1));
  let l = n.getMeta("appendedTransaction");
  if (n.steps.length == 0) return t;
  if (l && l.getMeta(Di))
    return l.getMeta(Di).redo
      ? new Mo(
          t.done.addTransform(n, void 0, r, Ic(e)),
          t.undone,
          Gw(n.mapping.maps),
          t.prevTime,
          t.prevComposition
        )
      : new Mo(
          t.done,
          t.undone.addTransform(n, void 0, r, Ic(e)),
          null,
          t.prevTime,
          t.prevComposition
        );
  if (
    n.getMeta("addToHistory") !== !1 &&
    !(l && l.getMeta("addToHistory") === !1)
  ) {
    let u = n.getMeta("composition"),
      c =
        t.prevTime == 0 ||
        (!l &&
          t.prevComposition != u &&
          (t.prevTime < (n.time || 0) - r.newGroupDelay ||
            !oI(n, t.prevRanges))),
      f = l ? Rh(t.prevRanges, n.mapping) : Gw(n.mapping.maps);
    return new Mo(
      t.done.addTransform(n, c ? e.selection.getBookmark() : void 0, r, Ic(e)),
      Un.empty,
      f,
      n.time,
      u ?? t.prevComposition
    );
  } else
    return (i = n.getMeta("rebased"))
      ? new Mo(
          t.done.rebased(n, i),
          t.undone.rebased(n, i),
          Rh(t.prevRanges, n.mapping),
          t.prevTime,
          t.prevComposition
        )
      : new Mo(
          t.done.addMaps(n.mapping.maps),
          t.undone.addMaps(n.mapping.maps),
          Rh(t.prevRanges, n.mapping),
          t.prevTime,
          t.prevComposition
        );
}
function oI(t, e) {
  if (!e) return !1;
  if (!t.docChanged) return !0;
  let n = !1;
  return (
    t.mapping.maps[0].forEach((r, o) => {
      for (let i = 0; i < e.length; i += 2)
        r <= e[i + 1] && o >= e[i] && (n = !0);
    }),
    n
  );
}
function Gw(t) {
  let e = [];
  for (let n = t.length - 1; n >= 0 && e.length == 0; n--)
    t[n].forEach((r, o, i, l) => e.push(i, l));
  return e;
}
function Rh(t, e) {
  if (!t) return null;
  let n = [];
  for (let r = 0; r < t.length; r += 2) {
    let o = e.map(t[r], 1),
      i = e.map(t[r + 1], -1);
    o <= i && n.push(o, i);
  }
  return n;
}
function iI(t, e, n) {
  let r = Ic(e),
    o = Di.get(e).spec.config,
    i = (n ? t.undone : t.done).popEvent(e, r);
  if (!i) return null;
  let l = i.selection.resolve(i.transform.doc),
    u = (n ? t.done : t.undone).addTransform(
      i.transform,
      e.selection.getBookmark(),
      o,
      r
    ),
    c = new Mo(n ? u : i.remaining, n ? i.remaining : u, null, 0, -1);
  return i.transform.setSelection(l).setMeta(Di, { redo: n, historyState: c });
}
let Ph = !1,
  Jw = null;
function Ic(t) {
  let e = t.plugins;
  if (Jw != e) {
    (Ph = !1), (Jw = e);
    for (let n = 0; n < e.length; n++)
      if (e[n].spec.historyPreserveItems) {
        Ph = !0;
        break;
      }
  }
  return Ph;
}
const Di = new Wt("history"),
  sI = new Wt("closeHistory");
function lI(t = {}) {
  return (
    (t = { depth: t.depth || 100, newGroupDelay: t.newGroupDelay || 500 }),
    new pt({
      key: Di,
      state: {
        init() {
          return new Mo(Un.empty, Un.empty, null, 0, -1);
        },
        apply(e, n, r) {
          return rI(n, r, e, t);
        },
      },
      config: t,
      props: {
        handleDOMEvents: {
          beforeinput(e, n) {
            let r = n.inputType,
              o = r == "historyUndo" ? tC : r == "historyRedo" ? nC : null;
            return o ? (n.preventDefault(), o(e.state, e.dispatch)) : !1;
          },
        },
      },
    })
  );
}
function eC(t, e) {
  return (n, r) => {
    let o = Di.getState(n);
    if (!o || (t ? o.undone : o.done).eventCount == 0) return !1;
    if (r) {
      let i = iI(o, n, t);
      i && r(e ? i.scrollIntoView() : i);
    }
    return !0;
  };
}
const tC = eC(!1, !0),
  nC = eC(!0, !0),
  aI = et.create({
    name: "history",
    addOptions() {
      return { depth: 100, newGroupDelay: 500 };
    },
    addCommands() {
      return {
        undo:
          () =>
          ({ state: t, dispatch: e }) =>
            tC(t, e),
        redo:
          () =>
          ({ state: t, dispatch: e }) =>
            nC(t, e),
      };
    },
    addProseMirrorPlugins() {
      return [lI(this.options)];
    },
    addKeyboardShortcuts() {
      return {
        "Mod-z": () => this.editor.commands.undo(),
        "Shift-Mod-z": () => this.editor.commands.redo(),
        "Mod-y": () => this.editor.commands.redo(),
        "Mod-": () => this.editor.commands.undo(),
        "Shift-Mod-": () => this.editor.commands.redo(),
      };
    },
  }),
  uI = Xn.create({
    name: "horizontalRule",
    addOptions() {
      return { HTMLAttributes: {} };
    },
    group: "block",
    parseHTML() {
      return [{ tag: "hr" }];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["hr", dt(this.options.HTMLAttributes, t)];
    },
    addCommands() {
      return {
        setHorizontalRule:
          () =>
          ({ chain: t, state: e }) => {
            const { selection: n } = e,
              { $from: r, $to: o } = n,
              i = t();
            return (
              r.parentOffset === 0
                ? i.insertContentAt(
                    { from: Math.max(r.pos - 1, 0), to: o.pos },
                    { type: this.name }
                  )
                : TS(n)
                ? i.insertContentAt(o.pos, { type: this.name })
                : i.insertContent({ type: this.name }),
              i
                .command(({ tr: l, dispatch: u }) => {
                  var c;
                  if (u) {
                    const { $to: f } = l.selection,
                      p = f.end();
                    if (f.nodeAfter)
                      f.nodeAfter.isTextblock
                        ? l.setSelection(Te.create(l.doc, f.pos + 1))
                        : f.nodeAfter.isBlock
                        ? l.setSelection(ke.create(l.doc, f.pos))
                        : l.setSelection(Te.create(l.doc, f.pos));
                    else {
                      const m =
                        (c = f.parent.type.contentMatch.defaultType) === null ||
                        c === void 0
                          ? void 0
                          : c.create();
                      m &&
                        (l.insert(p, m),
                        l.setSelection(Te.create(l.doc, p + 1)));
                    }
                    l.scrollIntoView();
                  }
                  return !0;
                })
                .run()
            );
          },
      };
    },
    addInputRules() {
      return [S3({ find: /^(?:---|-|___\s|\*\*\*\s)$/, type: this.type })];
    },
  }),
  cI = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/,
  dI = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g,
  fI = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/,
  pI = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g,
  hI = Gn.create({
    name: "italic",
    addOptions() {
      return { HTMLAttributes: {} };
    },
    parseHTML() {
      return [
        { tag: "em" },
        { tag: "i", getAttrs: (t) => t.style.fontStyle !== "normal" && null },
        {
          style: "font-style=normal",
          clearMark: (t) => t.type.name === this.name,
        },
        { style: "font-style=italic" },
      ];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["em", dt(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
      return {
        setItalic:
          () =>
          ({ commands: t }) =>
            t.setMark(this.name),
        toggleItalic:
          () =>
          ({ commands: t }) =>
            t.toggleMark(this.name),
        unsetItalic:
          () =>
          ({ commands: t }) =>
            t.unsetMark(this.name),
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-i": () => this.editor.commands.toggleItalic(),
        "Mod-I": () => this.editor.commands.toggleItalic(),
      };
    },
    addInputRules() {
      return [
        qs({ find: cI, type: this.type }),
        qs({ find: fI, type: this.type }),
      ];
    },
    addPasteRules() {
      return [
        _i({ find: dI, type: this.type }),
        _i({ find: pI, type: this.type }),
      ];
    },
  }),
  mI = Xn.create({
    name: "listItem",
    addOptions() {
      return {
        HTMLAttributes: {},
        bulletListTypeName: "bulletList",
        orderedListTypeName: "orderedList",
      };
    },
    content: "paragraph block*",
    defining: !0,
    parseHTML() {
      return [{ tag: "li" }];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["li", dt(this.options.HTMLAttributes, t), 0];
    },
    addKeyboardShortcuts() {
      return {
        Enter: () => this.editor.commands.splitListItem(this.name),
        Tab: () => this.editor.commands.sinkListItem(this.name),
        "Shift-Tab": () => this.editor.commands.liftListItem(this.name),
      };
    },
  }),
  gI = "listItem",
  Qw = "textStyle",
  Yw = /^(\d+)\.\s$/,
  yI = Xn.create({
    name: "orderedList",
    addOptions() {
      return {
        itemTypeName: "listItem",
        HTMLAttributes: {},
        keepMarks: !1,
        keepAttributes: !1,
      };
    },
    group: "block list",
    content() {
      return `${this.options.itemTypeName}+`;
    },
    addAttributes() {
      return {
        start: {
          default: 1,
          parseHTML: (t) =>
            t.hasAttribute("start")
              ? parseInt(t.getAttribute("start") || "", 10)
              : 1,
        },
        type: { default: void 0, parseHTML: (t) => t.getAttribute("type") },
      };
    },
    parseHTML() {
      return [{ tag: "ol" }];
    },
    renderHTML({ HTMLAttributes: t }) {
      const { start: e, ...n } = t;
      return e === 1
        ? ["ol", dt(this.options.HTMLAttributes, n), 0]
        : ["ol", dt(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
      return {
        toggleOrderedList:
          () =>
          ({ commands: t, chain: e }) =>
            this.options.keepAttributes
              ? e()
                  .toggleList(
                    this.name,
                    this.options.itemTypeName,
                    this.options.keepMarks
                  )
                  .updateAttributes(gI, this.editor.getAttributes(Qw))
                  .run()
              : t.toggleList(
                  this.name,
                  this.options.itemTypeName,
                  this.options.keepMarks
                ),
      };
    },
    addKeyboardShortcuts() {
      return { "Mod-Shift-7": () => this.editor.commands.toggleOrderedList() };
    },
    addInputRules() {
      let t = ka({
        find: Yw,
        type: this.type,
        getAttributes: (e) => ({ start: +e[1] }),
        joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1],
      });
      return (
        (this.options.keepMarks || this.options.keepAttributes) &&
          (t = ka({
            find: Yw,
            type: this.type,
            keepMarks: this.options.keepMarks,
            keepAttributes: this.options.keepAttributes,
            getAttributes: (e) => ({
              start: +e[1],
              ...this.editor.getAttributes(Qw),
            }),
            joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1],
            editor: this.editor,
          })),
        [t]
      );
    },
  }),
  vI = Xn.create({
    name: "paragraph",
    priority: 1e3,
    addOptions() {
      return { HTMLAttributes: {} };
    },
    group: "block",
    content: "inline*",
    parseHTML() {
      return [{ tag: "p" }];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["p", dt(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
      return {
        setParagraph:
          () =>
          ({ commands: t }) =>
            t.setNode(this.name),
      };
    },
    addKeyboardShortcuts() {
      return { "Mod-Alt-0": () => this.editor.commands.setParagraph() };
    },
  }),
  wI = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/,
  xI = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g,
  bI = Gn.create({
    name: "strike",
    addOptions() {
      return { HTMLAttributes: {} };
    },
    parseHTML() {
      return [
        { tag: "s" },
        { tag: "del" },
        { tag: "strike" },
        {
          style: "text-decoration",
          consuming: !1,
          getAttrs: (t) => (t.includes("line-through") ? {} : !1),
        },
      ];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["s", dt(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
      return {
        setStrike:
          () =>
          ({ commands: t }) =>
            t.setMark(this.name),
        toggleStrike:
          () =>
          ({ commands: t }) =>
            t.toggleMark(this.name),
        unsetStrike:
          () =>
          ({ commands: t }) =>
            t.unsetMark(this.name),
      };
    },
    addKeyboardShortcuts() {
      return { "Mod-Shift-s": () => this.editor.commands.toggleStrike() };
    },
    addInputRules() {
      return [qs({ find: wI, type: this.type })];
    },
    addPasteRules() {
      return [_i({ find: xI, type: this.type })];
    },
  }),
  SI = Xn.create({ name: "text", group: "inline" }),
  CI = et.create({
    name: "starterKit",
    addExtensions() {
      var t, e, n, r, o, i, l, u, c, f, p, m, y, v, x, S, C, E;
      const N = [];
      return (
        this.options.bold !== !1 &&
          N.push(
            AD.configure(
              (t = this.options) === null || t === void 0 ? void 0 : t.bold
            )
          ),
        this.options.blockquote !== !1 &&
          N.push(
            ED.configure(
              (e = this.options) === null || e === void 0
                ? void 0
                : e.blockquote
            )
          ),
        this.options.bulletList !== !1 &&
          N.push(
            PD.configure(
              (n = this.options) === null || n === void 0
                ? void 0
                : n.bulletList
            )
          ),
        this.options.code !== !1 &&
          N.push(
            LD.configure(
              (r = this.options) === null || r === void 0 ? void 0 : r.code
            )
          ),
        this.options.codeBlock !== !1 &&
          N.push(
            FD.configure(
              (o = this.options) === null || o === void 0 ? void 0 : o.codeBlock
            )
          ),
        this.options.document !== !1 &&
          N.push(
            zD.configure(
              (i = this.options) === null || i === void 0 ? void 0 : i.document
            )
          ),
        this.options.dropcursor !== !1 &&
          N.push(
            HD.configure(
              (l = this.options) === null || l === void 0
                ? void 0
                : l.dropcursor
            )
          ),
        this.options.gapcursor !== !1 &&
          N.push(
            QD.configure(
              (u = this.options) === null || u === void 0 ? void 0 : u.gapcursor
            )
          ),
        this.options.hardBreak !== !1 &&
          N.push(
            YD.configure(
              (c = this.options) === null || c === void 0 ? void 0 : c.hardBreak
            )
          ),
        this.options.heading !== !1 &&
          N.push(
            XD.configure(
              (f = this.options) === null || f === void 0 ? void 0 : f.heading
            )
          ),
        this.options.history !== !1 &&
          N.push(
            aI.configure(
              (p = this.options) === null || p === void 0 ? void 0 : p.history
            )
          ),
        this.options.horizontalRule !== !1 &&
          N.push(
            uI.configure(
              (m = this.options) === null || m === void 0
                ? void 0
                : m.horizontalRule
            )
          ),
        this.options.italic !== !1 &&
          N.push(
            hI.configure(
              (y = this.options) === null || y === void 0 ? void 0 : y.italic
            )
          ),
        this.options.listItem !== !1 &&
          N.push(
            mI.configure(
              (v = this.options) === null || v === void 0 ? void 0 : v.listItem
            )
          ),
        this.options.orderedList !== !1 &&
          N.push(
            yI.configure(
              (x = this.options) === null || x === void 0
                ? void 0
                : x.orderedList
            )
          ),
        this.options.paragraph !== !1 &&
          N.push(
            vI.configure(
              (S = this.options) === null || S === void 0 ? void 0 : S.paragraph
            )
          ),
        this.options.strike !== !1 &&
          N.push(
            bI.configure(
              (C = this.options) === null || C === void 0 ? void 0 : C.strike
            )
          ),
        this.options.text !== !1 &&
          N.push(
            SI.configure(
              (E = this.options) === null || E === void 0 ? void 0 : E.text
            )
          ),
        N
      );
    },
  }),
  kI = Gn.create({
    name: "underline",
    addOptions() {
      return { HTMLAttributes: {} };
    },
    parseHTML() {
      return [
        { tag: "u" },
        {
          style: "text-decoration",
          consuming: !1,
          getAttrs: (t) => (t.includes("underline") ? {} : !1),
        },
      ];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["u", dt(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
      return {
        setUnderline:
          () =>
          ({ commands: t }) =>
            t.setMark(this.name),
        toggleUnderline:
          () =>
          ({ commands: t }) =>
            t.toggleMark(this.name),
        unsetUnderline:
          () =>
          ({ commands: t }) =>
            t.unsetMark(this.name),
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-u": () => this.editor.commands.toggleUnderline(),
        "Mod-U": () => this.editor.commands.toggleUnderline(),
      };
    },
  }),
  EI =
    "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mgensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2",
  MI =
    "121342632165322333335355455655552435435422463632574574330355524444661154543332344423364211133222221212112052232222232212222223222241112222224322321222",
  Xs = (t, e) => {
    for (const n in e) t[n] = e[n];
    return t;
  },
  Am = "numeric",
  Rm = "ascii",
  Pm = "alpha",
  la = "asciinumeric",
  Zl = "alphanumeric",
  Dm = "domain",
  rC = "emoji",
  OI = "scheme",
  TI = "slashscheme",
  Dh = "whitespace";
function NI(t, e) {
  return t in e || (e[t] = []), e[t];
}
function Mi(t, e, n) {
  e[Am] && ((e[la] = !0), (e[Zl] = !0)),
    e[Rm] && ((e[la] = !0), (e[Pm] = !0)),
    e[la] && (e[Zl] = !0),
    e[Pm] && (e[Zl] = !0),
    e[Zl] && (e[Dm] = !0),
    e[rC] && (e[Dm] = !0);
  for (const r in e) {
    const o = NI(r, n);
    o.indexOf(t) < 0 && o.push(t);
  }
}
function AI(t, e) {
  const n = {};
  for (const r in e) e[r].indexOf(t) >= 0 && (n[r] = !0);
  return n;
}
function Zt(t = null) {
  (this.j = {}), (this.jr = []), (this.jd = null), (this.t = t);
}
Zt.groups = {};
Zt.prototype = {
  accepts() {
    return !!this.t;
  },
  go(t) {
    const e = this,
      n = e.j[t];
    if (n) return n;
    for (let r = 0; r < e.jr.length; r++) {
      const o = e.jr[r][0],
        i = e.jr[r][1];
      if (i && o.test(t)) return i;
    }
    return e.jd;
  },
  has(t, e = !1) {
    return e ? t in this.j : !!this.go(t);
  },
  ta(t, e, n, r) {
    for (let o = 0; o < t.length; o++) this.tt(t[o], e, n, r);
  },
  tr(t, e, n, r) {
    r = r || Zt.groups;
    let o;
    return (
      e && e.j ? (o = e) : ((o = new Zt(e)), n && r && Mi(e, n, r)),
      this.jr.push([t, o]),
      o
    );
  },
  ts(t, e, n, r) {
    let o = this;
    const i = t.length;
    if (!i) return o;
    for (let l = 0; l < i - 1; l++) o = o.tt(t[l]);
    return o.tt(t[i - 1], e, n, r);
  },
  tt(t, e, n, r) {
    r = r || Zt.groups;
    const o = this;
    if (e && e.j) return (o.j[t] = e), e;
    const i = e;
    let l,
      u = o.go(t);
    if (
      (u
        ? ((l = new Zt()),
          Xs(l.j, u.j),
          l.jr.push.apply(l.jr, u.jr),
          (l.jd = u.jd),
          (l.t = u.t))
        : (l = new Zt()),
      i)
    ) {
      if (r)
        if (l.t && typeof l.t == "string") {
          const c = Xs(AI(l.t, r), n);
          Mi(i, c, r);
        } else n && Mi(i, n, r);
      l.t = i;
    }
    return (o.j[t] = l), l;
  },
};
const Re = (t, e, n, r, o) => t.ta(e, n, r, o),
  Xe = (t, e, n, r, o) => t.tr(e, n, r, o),
  Xw = (t, e, n, r, o) => t.ts(e, n, r, o),
  Z = (t, e, n, r, o) => t.tt(e, n, r, o),
  Br = "WORD",
  Im = "UWORD",
  oC = "ASCIINUMERICAL",
  iC = "ALPHANUMERICAL",
  Oa = "LOCALHOST",
  Lm = "TLD",
  $m = "UTLD",
  Lc = "SCHEME",
  Rs = "SLASH_SCHEME",
  zg = "NUM",
  _m = "WS",
  jg = "NL",
  aa = "OPENBRACE",
  ua = "CLOSEBRACE",
  ed = "OPENBRACKET",
  td = "CLOSEBRACKET",
  nd = "OPENPAREN",
  rd = "CLOSEPAREN",
  od = "OPENANGLEBRACKET",
  id = "CLOSEANGLEBRACKET",
  sd = "FULLWIDTHLEFTPAREN",
  ld = "FULLWIDTHRIGHTPAREN",
  ad = "LEFTCORNERBRACKET",
  ud = "RIGHTCORNERBRACKET",
  cd = "LEFTWHITECORNERBRACKET",
  dd = "RIGHTWHITECORNERBRACKET",
  fd = "FULLWIDTHLESSTHAN",
  pd = "FULLWIDTHGREATERTHAN",
  hd = "AMPERSAND",
  Bg = "APOSTROPHE",
  md = "ASTERISK",
  Oo = "AT",
  gd = "BACKSLASH",
  yd = "BACKTICK",
  vd = "CARET",
  Ao = "COLON",
  Hg = "COMMA",
  wd = "DOLLAR",
  cr = "DOT",
  xd = "EQUALS",
  Vg = "EXCLAMATION",
  En = "HYPHEN",
  ca = "PERCENT",
  bd = "PIPE",
  Sd = "PLUS",
  Cd = "POUND",
  da = "QUERY",
  Wg = "QUOTE",
  sC = "FULLWIDTHMIDDLEDOT",
  Ug = "SEMI",
  dr = "SLASH",
  fa = "TILDE",
  kd = "UNDERSCORE",
  lC = "EMOJI",
  Ed = "SYM";
var aC = Object.freeze({
  __proto__: null,
  WORD: Br,
  UWORD: Im,
  ASCIINUMERICAL: oC,
  ALPHANUMERICAL: iC,
  LOCALHOST: Oa,
  TLD: Lm,
  UTLD: $m,
  SCHEME: Lc,
  SLASH_SCHEME: Rs,
  NUM: zg,
  WS: _m,
  NL: jg,
  OPENBRACE: aa,
  CLOSEBRACE: ua,
  OPENBRACKET: ed,
  CLOSEBRACKET: td,
  OPENPAREN: nd,
  CLOSEPAREN: rd,
  OPENANGLEBRACKET: od,
  CLOSEANGLEBRACKET: id,
  FULLWIDTHLEFTPAREN: sd,
  FULLWIDTHRIGHTPAREN: ld,
  LEFTCORNERBRACKET: ad,
  RIGHTCORNERBRACKET: ud,
  LEFTWHITECORNERBRACKET: cd,
  RIGHTWHITECORNERBRACKET: dd,
  FULLWIDTHLESSTHAN: fd,
  FULLWIDTHGREATERTHAN: pd,
  AMPERSAND: hd,
  APOSTROPHE: Bg,
  ASTERISK: md,
  AT: Oo,
  BACKSLASH: gd,
  BACKTICK: yd,
  CARET: vd,
  COLON: Ao,
  COMMA: Hg,
  DOLLAR: wd,
  DOT: cr,
  EQUALS: xd,
  EXCLAMATION: Vg,
  HYPHEN: En,
  PERCENT: ca,
  PIPE: bd,
  PLUS: Sd,
  POUND: Cd,
  QUERY: da,
  QUOTE: Wg,
  FULLWIDTHMIDDLEDOT: sC,
  SEMI: Ug,
  SLASH: dr,
  TILDE: fa,
  UNDERSCORE: kd,
  EMOJI: lC,
  SYM: Ed,
});
const _r = /[a-z]/,
  Kl = new RegExp("\\p{L}", "u"),
  Ih = new RegExp("\\p{Emoji}", "u"),
  Fr = /\d/,
  Lh = /\s/,
  Zw = "\r",
  $h = `
`,
  RI = "",
  PI = "",
  _h = "";
let mc = null,
  gc = null;
function DI(t = []) {
  const e = {};
  Zt.groups = e;
  const n = new Zt();
  mc == null && (mc = ex(EI)),
    gc == null && (gc = ex(MI)),
    Z(n, "'", Bg),
    Z(n, "{", aa),
    Z(n, "}", ua),
    Z(n, "[", ed),
    Z(n, "]", td),
    Z(n, "(", nd),
    Z(n, ")", rd),
    Z(n, "<", od),
    Z(n, ">", id),
    Z(n, "", sd),
    Z(n, "", ld),
    Z(n, "", ad),
    Z(n, "", ud),
    Z(n, "", cd),
    Z(n, "", dd),
    Z(n, "", fd),
    Z(n, "", pd),
    Z(n, "&", hd),
    Z(n, "*", md),
    Z(n, "@", Oo),
    Z(n, "`", yd),
    Z(n, "^", vd),
    Z(n, ":", Ao),
    Z(n, ",", Hg),
    Z(n, "$", wd),
    Z(n, ".", cr),
    Z(n, "=", xd),
    Z(n, "!", Vg),
    Z(n, "-", En),
    Z(n, "%", ca),
    Z(n, "|", bd),
    Z(n, "+", Sd),
    Z(n, "#", Cd),
    Z(n, "?", da),
    Z(n, '"', Wg),
    Z(n, "/", dr),
    Z(n, ";", Ug),
    Z(n, "~", fa),
    Z(n, "_", kd),
    Z(n, "\\", gd),
    Z(n, "", sC);
  const r = Xe(n, Fr, zg, { [Am]: !0 });
  Xe(r, Fr, r);
  const o = Xe(r, _r, oC, { [la]: !0 }),
    i = Xe(r, Kl, iC, { [Zl]: !0 }),
    l = Xe(n, _r, Br, { [Rm]: !0 });
  Xe(l, Fr, o), Xe(l, _r, l), Xe(o, Fr, o), Xe(o, _r, o);
  const u = Xe(n, Kl, Im, { [Pm]: !0 });
  Xe(u, _r), Xe(u, Fr, i), Xe(u, Kl, u), Xe(i, Fr, i), Xe(i, _r), Xe(i, Kl, i);
  const c = Z(n, $h, jg, { [Dh]: !0 }),
    f = Z(n, Zw, _m, { [Dh]: !0 }),
    p = Xe(n, Lh, _m, { [Dh]: !0 });
  Z(n, _h, p),
    Z(f, $h, c),
    Z(f, _h, p),
    Xe(f, Lh, p),
    Z(p, Zw),
    Z(p, $h),
    Xe(p, Lh, p),
    Z(p, _h, p);
  const m = Xe(n, Ih, lC, { [rC]: !0 });
  Z(m, "#"), Xe(m, Ih, m), Z(m, RI, m);
  const y = Z(m, PI);
  Z(y, "#"), Xe(y, Ih, m);
  const v = [
      [_r, l],
      [Fr, o],
    ],
    x = [
      [_r, null],
      [Kl, u],
      [Fr, i],
    ];
  for (let S = 0; S < mc.length; S++) wo(n, mc[S], Lm, Br, v);
  for (let S = 0; S < gc.length; S++) wo(n, gc[S], $m, Im, x);
  Mi(Lm, { tld: !0, ascii: !0 }, e),
    Mi($m, { utld: !0, alpha: !0 }, e),
    wo(n, "file", Lc, Br, v),
    wo(n, "mailto", Lc, Br, v),
    wo(n, "http", Rs, Br, v),
    wo(n, "https", Rs, Br, v),
    wo(n, "ftp", Rs, Br, v),
    wo(n, "ftps", Rs, Br, v),
    Mi(Lc, { scheme: !0, ascii: !0 }, e),
    Mi(Rs, { slashscheme: !0, ascii: !0 }, e),
    (t = t.sort((S, C) => (S[0] > C[0] ? 1 : -1)));
  for (let S = 0; S < t.length; S++) {
    const C = t[S][0],
      N = t[S][1] ? { [OI]: !0 } : { [TI]: !0 };
    C.indexOf("-") >= 0
      ? (N[Dm] = !0)
      : _r.test(C)
      ? Fr.test(C)
        ? (N[la] = !0)
        : (N[Rm] = !0)
      : (N[Am] = !0),
      Xw(n, C, C, N);
  }
  return (
    Xw(n, "localhost", Oa, { ascii: !0 }),
    (n.jd = new Zt(Ed)),
    { start: n, tokens: Xs({ groups: e }, aC) }
  );
}
function uC(t, e) {
  const n = II(e.replace(/[A-Z]/g, (u) => u.toLowerCase())),
    r = n.length,
    o = [];
  let i = 0,
    l = 0;
  for (; l < r; ) {
    let u = t,
      c = null,
      f = 0,
      p = null,
      m = -1,
      y = -1;
    for (; l < r && (c = u.go(n[l])); )
      (u = c),
        u.accepts()
          ? ((m = 0), (y = 0), (p = u))
          : m >= 0 && ((m += n[l].length), y++),
        (f += n[l].length),
        (i += n[l].length),
        l++;
    (i -= m),
      (l -= y),
      (f -= m),
      o.push({ t: p.t, v: e.slice(i - f, i), s: i - f, e: i });
  }
  return o;
}
function II(t) {
  const e = [],
    n = t.length;
  let r = 0;
  for (; r < n; ) {
    let o = t.charCodeAt(r),
      i,
      l =
        o < 55296 ||
        o > 56319 ||
        r + 1 === n ||
        (i = t.charCodeAt(r + 1)) < 56320 ||
        i > 57343
          ? t[r]
          : t.slice(r, r + 2);
    e.push(l), (r += l.length);
  }
  return e;
}
function wo(t, e, n, r, o) {
  let i;
  const l = e.length;
  for (let u = 0; u < l - 1; u++) {
    const c = e[u];
    t.j[c] ? (i = t.j[c]) : ((i = new Zt(r)), (i.jr = o.slice()), (t.j[c] = i)),
      (t = i);
  }
  return (i = new Zt(n)), (i.jr = o.slice()), (t.j[e[l - 1]] = i), i;
}
function ex(t) {
  const e = [],
    n = [];
  let r = 0,
    o = "0123456789";
  for (; r < t.length; ) {
    let i = 0;
    for (; o.indexOf(t[r + i]) >= 0; ) i++;
    if (i > 0) {
      e.push(n.join(""));
      for (let l = parseInt(t.substring(r, r + i), 10); l > 0; l--) n.pop();
      r += i;
    } else n.push(t[r]), r++;
  }
  return e;
}
const Ta = {
  defaultProtocol: "http",
  events: null,
  format: tx,
  formatHref: tx,
  nl2br: !1,
  tagName: "a",
  target: null,
  rel: null,
  validate: !0,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null,
};
function Kg(t, e = null) {
  let n = Xs({}, Ta);
  t && (n = Xs(n, t instanceof Kg ? t.o : t));
  const r = n.ignoreTags,
    o = [];
  for (let i = 0; i < r.length; i++) o.push(r[i].toUpperCase());
  (this.o = n), e && (this.defaultRender = e), (this.ignoreTags = o);
}
Kg.prototype = {
  o: Ta,
  ignoreTags: [],
  defaultRender(t) {
    return t;
  },
  check(t) {
    return this.get("validate", t.toString(), t);
  },
  get(t, e, n) {
    const r = e != null;
    let o = this.o[t];
    return (
      o &&
      (typeof o == "object"
        ? ((o = n.t in o ? o[n.t] : Ta[t]),
          typeof o == "function" && r && (o = o(e, n)))
        : typeof o == "function" && r && (o = o(e, n.t, n)),
      o)
    );
  },
  getObj(t, e, n) {
    let r = this.o[t];
    return typeof r == "function" && e != null && (r = r(e, n.t, n)), r;
  },
  render(t) {
    const e = t.render(this);
    return (this.get("render", null, t) || this.defaultRender)(e, t.t, t);
  },
};
function tx(t) {
  return t;
}
function cC(t, e) {
  (this.t = "token"), (this.v = t), (this.tk = e);
}
cC.prototype = {
  isLink: !1,
  toString() {
    return this.v;
  },
  toHref(t) {
    return this.toString();
  },
  toFormattedString(t) {
    const e = this.toString(),
      n = t.get("truncate", e, this),
      r = t.get("format", e, this);
    return n && r.length > n ? r.substring(0, n) + "" : r;
  },
  toFormattedHref(t) {
    return t.get("formatHref", this.toHref(t.get("defaultProtocol")), this);
  },
  startIndex() {
    return this.tk[0].s;
  },
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  toObject(t = Ta.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(t),
      start: this.startIndex(),
      end: this.endIndex(),
    };
  },
  toFormattedObject(t) {
    return {
      type: this.t,
      value: this.toFormattedString(t),
      isLink: this.isLink,
      href: this.toFormattedHref(t),
      start: this.startIndex(),
      end: this.endIndex(),
    };
  },
  validate(t) {
    return t.get("validate", this.toString(), this);
  },
  render(t) {
    const e = this,
      n = this.toHref(t.get("defaultProtocol")),
      r = t.get("formatHref", n, this),
      o = t.get("tagName", n, e),
      i = this.toFormattedString(t),
      l = {},
      u = t.get("className", n, e),
      c = t.get("target", n, e),
      f = t.get("rel", n, e),
      p = t.getObj("attributes", n, e),
      m = t.getObj("events", n, e);
    return (
      (l.href = r),
      u && (l.class = u),
      c && (l.target = c),
      f && (l.rel = f),
      p && Xs(l, p),
      { tagName: o, attributes: l, content: i, eventListeners: m }
    );
  },
};
function Xd(t, e) {
  class n extends cC {
    constructor(o, i) {
      super(o, i), (this.t = t);
    }
  }
  for (const r in e) n.prototype[r] = e[r];
  return (n.t = t), n;
}
const nx = Xd("email", {
    isLink: !0,
    toHref() {
      return "mailto:" + this.toString();
    },
  }),
  rx = Xd("text"),
  LI = Xd("nl"),
  yc = Xd("url", {
    isLink: !0,
    toHref(t = Ta.defaultProtocol) {
      return this.hasProtocol() ? this.v : `${t}://${this.v}`;
    },
    hasProtocol() {
      const t = this.tk;
      return t.length >= 2 && t[0].t !== Oa && t[1].t === Ao;
    },
  }),
  kn = (t) => new Zt(t);
function $I({ groups: t }) {
  const e = t.domain.concat([
      hd,
      md,
      Oo,
      gd,
      yd,
      vd,
      wd,
      xd,
      En,
      zg,
      ca,
      bd,
      Sd,
      Cd,
      dr,
      Ed,
      fa,
      kd,
    ]),
    n = [
      Ao,
      Hg,
      cr,
      Vg,
      ca,
      da,
      Wg,
      Ug,
      od,
      id,
      aa,
      ua,
      td,
      ed,
      nd,
      rd,
      sd,
      ld,
      ad,
      ud,
      cd,
      dd,
      fd,
      pd,
    ],
    r = [
      hd,
      Bg,
      md,
      gd,
      yd,
      vd,
      wd,
      xd,
      En,
      aa,
      ua,
      ca,
      bd,
      Sd,
      Cd,
      da,
      dr,
      Ed,
      fa,
      kd,
    ],
    o = kn(),
    i = Z(o, fa);
  Re(i, r, i), Re(i, t.domain, i);
  const l = kn(),
    u = kn(),
    c = kn();
  Re(o, t.domain, l),
    Re(o, t.scheme, u),
    Re(o, t.slashscheme, c),
    Re(l, r, i),
    Re(l, t.domain, l);
  const f = Z(l, Oo);
  Z(i, Oo, f), Z(u, Oo, f), Z(c, Oo, f);
  const p = Z(i, cr);
  Re(p, r, i), Re(p, t.domain, i);
  const m = kn();
  Re(f, t.domain, m), Re(m, t.domain, m);
  const y = Z(m, cr);
  Re(y, t.domain, m);
  const v = kn(nx);
  Re(y, t.tld, v), Re(y, t.utld, v), Z(f, Oa, v);
  const x = Z(m, En);
  Z(x, En, x), Re(x, t.domain, m), Re(v, t.domain, m), Z(v, cr, y), Z(v, En, x);
  const S = Z(v, Ao);
  Re(S, t.numeric, nx);
  const C = Z(l, En),
    E = Z(l, cr);
  Z(C, En, C), Re(C, t.domain, l), Re(E, r, i), Re(E, t.domain, l);
  const N = kn(yc);
  Re(E, t.tld, N),
    Re(E, t.utld, N),
    Re(N, t.domain, l),
    Re(N, r, i),
    Z(N, cr, E),
    Z(N, En, C),
    Z(N, Oo, f);
  const $ = Z(N, Ao),
    M = kn(yc);
  Re($, t.numeric, M);
  const I = kn(yc),
    R = kn();
  Re(I, e, I), Re(I, n, R), Re(R, e, I), Re(R, n, R), Z(N, dr, I), Z(M, dr, I);
  const F = Z(u, Ao),
    H = Z(c, Ao),
    U = Z(H, dr),
    re = Z(U, dr);
  Re(u, t.domain, l),
    Z(u, cr, E),
    Z(u, En, C),
    Re(c, t.domain, l),
    Z(c, cr, E),
    Z(c, En, C),
    Re(F, t.domain, I),
    Z(F, dr, I),
    Z(F, da, I),
    Re(re, t.domain, I),
    Re(re, e, I),
    Z(re, dr, I);
  const ce = [
    [aa, ua],
    [ed, td],
    [nd, rd],
    [od, id],
    [sd, ld],
    [ad, ud],
    [cd, dd],
    [fd, pd],
  ];
  for (let ee = 0; ee < ce.length; ee++) {
    const [le, de] = ce[ee],
      xe = Z(I, le);
    Z(R, le, xe), Z(xe, de, I);
    const oe = kn(yc);
    Re(xe, e, oe);
    const se = kn();
    Re(xe, n),
      Re(oe, e, oe),
      Re(oe, n, se),
      Re(se, e, oe),
      Re(se, n, se),
      Z(oe, de, I),
      Z(se, de, I);
  }
  return Z(o, Oa, N), Z(o, jg, LI), { start: o, tokens: aC };
}
function _I(t, e, n) {
  let r = n.length,
    o = 0,
    i = [],
    l = [];
  for (; o < r; ) {
    let u = t,
      c = null,
      f = null,
      p = 0,
      m = null,
      y = -1;
    for (; o < r && !(c = u.go(n[o].t)); ) l.push(n[o++]);
    for (; o < r && (f = c || u.go(n[o].t)); )
      (c = null),
        (u = f),
        u.accepts() ? ((y = 0), (m = u)) : y >= 0 && y++,
        o++,
        p++;
    if (y < 0) (o -= p), o < r && (l.push(n[o]), o++);
    else {
      l.length > 0 && (i.push(Fh(rx, e, l)), (l = [])), (o -= y), (p -= y);
      const v = m.t,
        x = n.slice(o - p, o);
      i.push(Fh(v, e, x));
    }
  }
  return l.length > 0 && i.push(Fh(rx, e, l)), i;
}
function Fh(t, e, n) {
  const r = n[0].s,
    o = n[n.length - 1].e,
    i = e.slice(r, o);
  return new t(i, n);
}
const FI = (typeof console < "u" && console && console.warn) || (() => {}),
  zI =
    "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.",
  qe = {
    scanner: null,
    parser: null,
    tokenQueue: [],
    pluginQueue: [],
    customSchemes: [],
    initialized: !1,
  };
function jI() {
  return (
    (Zt.groups = {}),
    (qe.scanner = null),
    (qe.parser = null),
    (qe.tokenQueue = []),
    (qe.pluginQueue = []),
    (qe.customSchemes = []),
    (qe.initialized = !1),
    qe
  );
}
function ox(t, e = !1) {
  if (
    (qe.initialized &&
      FI(
        `linkifyjs: already initialized - will not register custom scheme "${t}" ${zI}`
      ),
    !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t))
  )
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  qe.customSchemes.push([t, e]);
}
function BI() {
  qe.scanner = DI(qe.customSchemes);
  for (let t = 0; t < qe.tokenQueue.length; t++)
    qe.tokenQueue[t][1]({ scanner: qe.scanner });
  qe.parser = $I(qe.scanner.tokens);
  for (let t = 0; t < qe.pluginQueue.length; t++)
    qe.pluginQueue[t][1]({ scanner: qe.scanner, parser: qe.parser });
  return (qe.initialized = !0), qe;
}
function qg(t) {
  return (
    qe.initialized || BI(), _I(qe.parser.start, t, uC(qe.scanner.start, t))
  );
}
qg.scan = uC;
function dC(t, e = null, n = null) {
  if (e && typeof e == "object") {
    if (n) throw Error(`linkifyjs: Invalid link type ${e}; must be a string`);
    (n = e), (e = null);
  }
  const r = new Kg(n),
    o = qg(t),
    i = [];
  for (let l = 0; l < o.length; l++) {
    const u = o[l];
    u.isLink &&
      (!e || u.t === e) &&
      r.check(u) &&
      i.push(u.toFormattedObject(r));
  }
  return i;
}
function HI(t) {
  return t.length === 1
    ? t[0].isLink
    : t.length === 3 && t[1].isLink
    ? ["()", "[]"].includes(t[0].value + t[2].value)
    : !1;
}
function VI(t) {
  return new pt({
    key: new Wt("autolink"),
    appendTransaction: (e, n, r) => {
      const o = e.some((f) => f.docChanged) && !n.doc.eq(r.doc),
        i = e.some((f) => f.getMeta("preventAutolink"));
      if (!o || i) return;
      const { tr: l } = r,
        u = _R(n.doc, [...e]);
      if (
        (WR(u).forEach(({ newRange: f }) => {
          const p = zR(r.doc, f, (v) => v.isTextblock);
          let m, y;
          if (
            (p.length > 1
              ? ((m = p[0]),
                (y = r.doc.textBetween(
                  m.pos,
                  m.pos + m.node.nodeSize,
                  void 0,
                  " "
                )))
              : p.length &&
                r.doc.textBetween(f.from, f.to, " ", " ").endsWith(" ") &&
                ((m = p[0]), (y = r.doc.textBetween(m.pos, f.to, void 0, " "))),
            m && y)
          ) {
            const v = y.split(" ").filter((E) => E !== "");
            if (v.length <= 0) return !1;
            const x = v[v.length - 1],
              S = m.pos + y.lastIndexOf(x);
            if (!x) return !1;
            const C = qg(x).map((E) => E.toObject(t.defaultProtocol));
            if (!HI(C)) return !1;
            C.filter((E) => E.isLink)
              .map((E) => ({ ...E, from: S + E.start + 1, to: S + E.end + 1 }))
              .filter((E) =>
                r.schema.marks.code
                  ? !r.doc.rangeHasMark(E.from, E.to, r.schema.marks.code)
                  : !0
              )
              .filter((E) => t.validate(E.value))
              .filter((E) => t.shouldAutoLink(E.value))
              .forEach((E) => {
                kg(E.from, E.to, r.doc).some((N) => N.mark.type === t.type) ||
                  l.addMark(E.from, E.to, t.type.create({ href: E.href }));
              });
          }
        }),
        !!l.steps.length)
      )
        return l;
    },
  });
}
function WI(t) {
  return new pt({
    key: new Wt("handleClickLink"),
    props: {
      handleClick: (e, n, r) => {
        var o, i;
        if (r.button !== 0 || !e.editable) return !1;
        let l = r.target;
        const u = [];
        for (; l.nodeName !== "DIV"; ) u.push(l), (l = l.parentNode);
        if (!u.find((y) => y.nodeName === "A")) return !1;
        const c = OS(e.state, t.type.name),
          f = r.target,
          p =
            (o = f == null ? void 0 : f.href) !== null && o !== void 0
              ? o
              : c.href,
          m =
            (i = f == null ? void 0 : f.target) !== null && i !== void 0
              ? i
              : c.target;
        return f && p ? (window.open(p, m), !0) : !1;
      },
    },
  });
}
function UI(t) {
  return new pt({
    key: new Wt("handlePasteLink"),
    props: {
      handlePaste: (e, n, r) => {
        const { state: o } = e,
          { selection: i } = o,
          { empty: l } = i;
        if (l) return !1;
        let u = "";
        r.content.forEach((f) => {
          u += f.textContent;
        });
        const c = dC(u, { defaultProtocol: t.defaultProtocol }).find(
          (f) => f.isLink && f.value === u
        );
        return !u || !c
          ? !1
          : t.editor.commands.setMark(t.type, { href: c.href });
      },
    },
  });
}
const KI = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
function wi(t, e) {
  const n = [
    "http",
    "https",
    "ftp",
    "ftps",
    "mailto",
    "tel",
    "callto",
    "sms",
    "cid",
    "xmpp",
  ];
  return (
    e &&
      e.forEach((r) => {
        const o = typeof r == "string" ? r : r.scheme;
        o && n.push(o);
      }),
    !t ||
      t
        .replace(KI, "")
        .match(
          new RegExp(
            `^(?:(?:${n.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
            "i"
          )
        )
  );
}
const qI = Gn.create({
    name: "link",
    priority: 1e3,
    keepOnSplit: !1,
    exitable: !0,
    onCreate() {
      this.options.validate &&
        !this.options.shouldAutoLink &&
        ((this.options.shouldAutoLink = this.options.validate),
        console.warn(
          "The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead."
        )),
        this.options.protocols.forEach((t) => {
          if (typeof t == "string") {
            ox(t);
            return;
          }
          ox(t.scheme, t.optionalSlashes);
        });
    },
    onDestroy() {
      jI();
    },
    inclusive() {
      return this.options.autolink;
    },
    addOptions() {
      return {
        openOnClick: !0,
        linkOnPaste: !0,
        autolink: !0,
        protocols: [],
        defaultProtocol: "http",
        HTMLAttributes: {
          target: "_blank",
          rel: "noopener noreferrer nofollow",
          class: null,
        },
        isAllowedUri: (t, e) => !!wi(t, e.protocols),
        validate: (t) => !!t,
        shouldAutoLink: (t) => !!t,
      };
    },
    addAttributes() {
      return {
        href: {
          default: null,
          parseHTML(t) {
            return t.getAttribute("href");
          },
        },
        target: { default: this.options.HTMLAttributes.target },
        rel: { default: this.options.HTMLAttributes.rel },
        class: { default: this.options.HTMLAttributes.class },
      };
    },
    parseHTML() {
      return [
        {
          tag: "a[href]",
          getAttrs: (t) => {
            const e = t.getAttribute("href");
            return !e ||
              !this.options.isAllowedUri(e, {
                defaultValidate: (n) => !!wi(n, this.options.protocols),
                protocols: this.options.protocols,
                defaultProtocol: this.options.defaultProtocol,
              })
              ? !1
              : null;
          },
        },
      ];
    },
    renderHTML({ HTMLAttributes: t }) {
      return this.options.isAllowedUri(t.href, {
        defaultValidate: (e) => !!wi(e, this.options.protocols),
        protocols: this.options.protocols,
        defaultProtocol: this.options.defaultProtocol,
      })
        ? ["a", dt(this.options.HTMLAttributes, t), 0]
        : ["a", dt(this.options.HTMLAttributes, { ...t, href: "" }), 0];
    },
    addCommands() {
      return {
        setLink:
          (t) =>
          ({ chain: e }) => {
            const { href: n } = t;
            return this.options.isAllowedUri(n, {
              defaultValidate: (r) => !!wi(r, this.options.protocols),
              protocols: this.options.protocols,
              defaultProtocol: this.options.defaultProtocol,
            })
              ? e().setMark(this.name, t).setMeta("preventAutolink", !0).run()
              : !1;
          },
        toggleLink:
          (t) =>
          ({ chain: e }) => {
            const { href: n } = t;
            return this.options.isAllowedUri(n, {
              defaultValidate: (r) => !!wi(r, this.options.protocols),
              protocols: this.options.protocols,
              defaultProtocol: this.options.defaultProtocol,
            })
              ? e()
                  .toggleMark(this.name, t, { extendEmptyMarkRange: !0 })
                  .setMeta("preventAutolink", !0)
                  .run()
              : !1;
          },
        unsetLink:
          () =>
          ({ chain: t }) =>
            t()
              .unsetMark(this.name, { extendEmptyMarkRange: !0 })
              .setMeta("preventAutolink", !0)
              .run(),
      };
    },
    addPasteRules() {
      return [
        _i({
          find: (t) => {
            const e = [];
            if (t) {
              const { protocols: n, defaultProtocol: r } = this.options,
                o = dC(t).filter(
                  (i) =>
                    i.isLink &&
                    this.options.isAllowedUri(i.value, {
                      defaultValidate: (l) => !!wi(l, n),
                      protocols: n,
                      defaultProtocol: r,
                    })
                );
              o.length &&
                o.forEach((i) =>
                  e.push({
                    text: i.value,
                    data: { href: i.href },
                    index: i.start,
                  })
                );
            }
            return e;
          },
          type: this.type,
          getAttributes: (t) => {
            var e;
            return {
              href: (e = t.data) === null || e === void 0 ? void 0 : e.href,
            };
          },
        }),
      ];
    },
    addProseMirrorPlugins() {
      const t = [],
        { protocols: e, defaultProtocol: n } = this.options;
      return (
        this.options.autolink &&
          t.push(
            VI({
              type: this.type,
              defaultProtocol: this.options.defaultProtocol,
              validate: (r) =>
                this.options.isAllowedUri(r, {
                  defaultValidate: (o) => !!wi(o, e),
                  protocols: e,
                  defaultProtocol: n,
                }),
              shouldAutoLink: this.options.shouldAutoLink,
            })
          ),
        this.options.openOnClick === !0 && t.push(WI({ type: this.type })),
        this.options.linkOnPaste &&
          t.push(
            UI({
              editor: this.editor,
              defaultProtocol: this.options.defaultProtocol,
              type: this.type,
            })
          ),
        t
      );
    },
  }),
  GI = (t) => {
    if (!t.children.length) return;
    const e = t.querySelectorAll("span");
    e &&
      e.forEach((n) => {
        var r, o;
        const i = n.getAttribute("style"),
          l =
            (o =
              (r = n.parentElement) === null || r === void 0
                ? void 0
                : r.closest("span")) === null || o === void 0
              ? void 0
              : o.getAttribute("style");
        n.setAttribute("style", `${l};${i}`);
      });
  },
  JI = Gn.create({
    name: "textStyle",
    priority: 101,
    addOptions() {
      return { HTMLAttributes: {}, mergeNestedSpanStyles: !1 };
    },
    parseHTML() {
      return [
        {
          tag: "span",
          getAttrs: (t) =>
            t.hasAttribute("style")
              ? (this.options.mergeNestedSpanStyles && GI(t), {})
              : !1,
        },
      ];
    },
    renderHTML({ HTMLAttributes: t }) {
      return ["span", dt(this.options.HTMLAttributes, t), 0];
    },
    addCommands() {
      return {
        removeEmptyTextStyle:
          () =>
          ({ tr: t }) => {
            const { selection: e } = t;
            return (
              t.doc.nodesBetween(e.from, e.to, (n, r) => {
                if (n.isTextblock) return !0;
                n.marks
                  .filter((o) => o.type === this.type)
                  .some((o) => Object.values(o.attrs).some((i) => !!i)) ||
                  t.removeMark(r, r + n.nodeSize, this.type);
              }),
              !0
            );
          },
      };
    },
  }),
  QI = et.create({
    name: "color",
    addOptions() {
      return { types: ["textStyle"] };
    },
    addGlobalAttributes() {
      return [
        {
          types: this.options.types,
          attributes: {
            color: {
              default: null,
              parseHTML: (t) => {
                var e;
                return (e = t.style.color) === null || e === void 0
                  ? void 0
                  : e.replace(/['"]+/g, "");
              },
              renderHTML: (t) =>
                t.color ? { style: `color: ${t.color}` } : {},
            },
          },
        },
      ];
    },
    addCommands() {
      return {
        setColor:
          (t) =>
          ({ chain: e }) =>
            e().setMark("textStyle", { color: t }).run(),
        unsetColor:
          () =>
          ({ chain: t }) =>
            t()
              .setMark("textStyle", { color: null })
              .removeEmptyTextStyle()
              .run(),
      };
    },
  }),
  YI = (t) => tt({ find: /--$/, replace: t ?? "" }),
  XI = (t) => tt({ find: /\.\.\.$/, replace: t ?? "" }),
  ZI = (t) =>
    tt({ find: /(?:^|[\s{[(<'"\u2018\u201C])(")$/, replace: t ?? "" }),
  eL = (t) => tt({ find: /"$/, replace: t ?? "" }),
  tL = (t) =>
    tt({ find: /(?:^|[\s{[(<'"\u2018\u201C])(')$/, replace: t ?? "" }),
  nL = (t) => tt({ find: /'$/, replace: t ?? "" }),
  rL = (t) => tt({ find: /<-$/, replace: t ?? "" }),
  oL = (t) => tt({ find: /->$/, replace: t ?? "" }),
  iL = (t) => tt({ find: /\(c\)$/, replace: t ?? "" }),
  sL = (t) => tt({ find: /\(tm\)$/, replace: t ?? "" }),
  lL = (t) => tt({ find: /\(sm\)$/, replace: t ?? "" }),
  aL = (t) => tt({ find: /\(r\)$/, replace: t ?? "" }),
  uL = (t) => tt({ find: /(?:^|\s)(1\/2)\s$/, replace: t ?? "" }),
  cL = (t) => tt({ find: /\+\/-$/, replace: t ?? "" }),
  dL = (t) => tt({ find: /!=$/, replace: t ?? "" }),
  fL = (t) => tt({ find: /<<$/, replace: t ?? "" }),
  pL = (t) => tt({ find: />>$/, replace: t ?? "" }),
  hL = (t) => tt({ find: /\d+\s?([*x])\s?\d+$/, replace: t ?? "" }),
  mL = (t) => tt({ find: /\^2$/, replace: t ?? "" }),
  gL = (t) => tt({ find: /\^3$/, replace: t ?? "" }),
  yL = (t) => tt({ find: /(?:^|\s)(1\/4)\s$/, replace: t ?? "" }),
  vL = (t) => tt({ find: /(?:^|\s)(3\/4)\s$/, replace: t ?? "" }),
  wL = et.create({
    name: "typography",
    addOptions() {
      return {
        closeDoubleQuote: "",
        closeSingleQuote: "",
        copyright: "",
        ellipsis: "",
        emDash: "",
        laquo: "",
        leftArrow: "",
        multiplication: "",
        notEqual: "",
        oneHalf: "",
        oneQuarter: "",
        openDoubleQuote: "",
        openSingleQuote: "",
        plusMinus: "",
        raquo: "",
        registeredTrademark: "",
        rightArrow: "",
        servicemark: "",
        superscriptThree: "",
        superscriptTwo: "",
        threeQuarters: "",
        trademark: "",
      };
    },
    addInputRules() {
      const t = [];
      return (
        this.options.emDash !== !1 && t.push(YI(this.options.emDash)),
        this.options.ellipsis !== !1 && t.push(XI(this.options.ellipsis)),
        this.options.openDoubleQuote !== !1 &&
          t.push(ZI(this.options.openDoubleQuote)),
        this.options.closeDoubleQuote !== !1 &&
          t.push(eL(this.options.closeDoubleQuote)),
        this.options.openSingleQuote !== !1 &&
          t.push(tL(this.options.openSingleQuote)),
        this.options.closeSingleQuote !== !1 &&
          t.push(nL(this.options.closeSingleQuote)),
        this.options.leftArrow !== !1 && t.push(rL(this.options.leftArrow)),
        this.options.rightArrow !== !1 && t.push(oL(this.options.rightArrow)),
        this.options.copyright !== !1 && t.push(iL(this.options.copyright)),
        this.options.trademark !== !1 && t.push(sL(this.options.trademark)),
        this.options.servicemark !== !1 && t.push(lL(this.options.servicemark)),
        this.options.registeredTrademark !== !1 &&
          t.push(aL(this.options.registeredTrademark)),
        this.options.oneHalf !== !1 && t.push(uL(this.options.oneHalf)),
        this.options.plusMinus !== !1 && t.push(cL(this.options.plusMinus)),
        this.options.notEqual !== !1 && t.push(dL(this.options.notEqual)),
        this.options.laquo !== !1 && t.push(fL(this.options.laquo)),
        this.options.raquo !== !1 && t.push(pL(this.options.raquo)),
        this.options.multiplication !== !1 &&
          t.push(hL(this.options.multiplication)),
        this.options.superscriptTwo !== !1 &&
          t.push(mL(this.options.superscriptTwo)),
        this.options.superscriptThree !== !1 &&
          t.push(gL(this.options.superscriptThree)),
        this.options.oneQuarter !== !1 && t.push(yL(this.options.oneQuarter)),
        this.options.threeQuarters !== !1 &&
          t.push(vL(this.options.threeQuarters)),
        t
      );
    },
  }),
  xL = et.create({
    name: "textAlign",
    addOptions() {
      return {
        types: [],
        alignments: ["left", "center", "right", "justify"],
        defaultAlignment: null,
      };
    },
    addGlobalAttributes() {
      return [
        {
          types: this.options.types,
          attributes: {
            textAlign: {
              default: this.options.defaultAlignment,
              parseHTML: (t) => {
                const e = t.style.textAlign;
                return this.options.alignments.includes(e)
                  ? e
                  : this.options.defaultAlignment;
              },
              renderHTML: (t) =>
                t.textAlign ? { style: `text-align: ${t.textAlign}` } : {},
            },
          },
        },
      ];
    },
    addCommands() {
      return {
        setTextAlign:
          (t) =>
          ({ commands: e }) =>
            this.options.alignments.includes(t)
              ? this.options.types
                  .map((n) => e.updateAttributes(n, { textAlign: t }))
                  .every((n) => n)
              : !1,
        unsetTextAlign:
          () =>
          ({ commands: t }) =>
            this.options.types
              .map((e) => t.resetAttributes(e, "textAlign"))
              .every((e) => e),
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
        "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
        "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
        "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify"),
      };
    },
  }),
  bL = et.create({
    name: "fontSize",
    addOptions() {
      return { types: ["textStyle"] };
    },
    addGlobalAttributes() {
      return [
        { types: ["paragraph"], attributes: { class: {} } },
        {
          types: this.options.types,
          attributes: {
            fontSize: {
              parseHTML: (t) => t.style.fontSize.replace(/['"]+/g, ""),
              renderHTML: (t) =>
                t.fontSize ? { style: `font-size: ${t.fontSize}` } : {},
            },
          },
        },
      ];
    },
    addCommands() {
      return {
        setFontSize:
          (t) =>
          ({ chain: e }) =>
            e().setMark("textStyle", { fontSize: t }).run(),
        unsetFontSize:
          () =>
          ({ chain: t }) =>
            t()
              .setMark("textStyle", { fontSize: null })
              .removeEmptyTextStyle()
              .run(),
      };
    },
  });
function pn(t, e, n = void 0) {
  return () => t.chain().focus()[e](n).run();
}
function Ss(t, e) {
  return t.isActive(e) ? "bg-gray-400" : "";
}
var fC = {
    color: void 0,
    size: void 0,
    className: void 0,
    style: void 0,
    attr: void 0,
  },
  ix = Le.createContext && Le.createContext(fC),
  SL = ["attr", "size", "title"];
function CL(t, e) {
  if (t == null) return {};
  var n = kL(t, e),
    r,
    o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t);
    for (o = 0; o < i.length; o++)
      (r = i[o]),
        !(e.indexOf(r) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(t, r) &&
          (n[r] = t[r]);
  }
  return n;
}
function kL(t, e) {
  if (t == null) return {};
  var n = {};
  for (var r in t)
    if (Object.prototype.hasOwnProperty.call(t, r)) {
      if (e.indexOf(r) >= 0) continue;
      n[r] = t[r];
    }
  return n;
}
function Md() {
  return (
    (Md = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
          }
          return t;
        }),
    Md.apply(this, arguments)
  );
}
function sx(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e &&
      (r = r.filter(function (o) {
        return Object.getOwnPropertyDescriptor(t, o).enumerable;
      })),
      n.push.apply(n, r);
  }
  return n;
}
function Od(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? sx(Object(n), !0).forEach(function (r) {
          EL(t, r, n[r]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
      : sx(Object(n)).forEach(function (r) {
          Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
        });
  }
  return t;
}
function EL(t, e, n) {
  return (
    (e = ML(e)),
    e in t
      ? Object.defineProperty(t, e, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (t[e] = n),
    t
  );
}
function ML(t) {
  var e = OL(t, "string");
  return typeof e == "symbol" ? e : e + "";
}
function OL(t, e) {
  if (typeof t != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(t, e || "default");
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function pC(t) {
  return (
    t &&
    t.map((e, n) =>
      Le.createElement(e.tag, Od({ key: n }, e.attr), pC(e.child))
    )
  );
}
function Zn(t) {
  return (e) =>
    Le.createElement(TL, Md({ attr: Od({}, t.attr) }, e), pC(t.child));
}
function TL(t) {
  var e = (n) => {
    var { attr: r, size: o, title: i } = t,
      l = CL(t, SL),
      u = o || n.size || "1em",
      c;
    return (
      n.className && (c = n.className),
      t.className && (c = (c ? c + " " : "") + t.className),
      Le.createElement(
        "svg",
        Md(
          { stroke: "currentColor", fill: "currentColor", strokeWidth: "0" },
          n.attr,
          r,
          l,
          {
            className: c,
            style: Od(Od({ color: t.color || n.color }, n.style), t.style),
            height: u,
            width: u,
            xmlns: "http://www.w3.org/2000/svg",
          }
        ),
        i && Le.createElement("title", null, i),
        t.children
      )
    );
  };
  return ix !== void 0
    ? Le.createElement(ix.Consumer, null, (n) => e(n))
    : e(fC);
}
function NL(t) {
  return Zn({
    tag: "svg",
    attr: { viewBox: "0 0 448 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M352 64c0-17.7-14.3-32-32-32L128 32c-17.7 0-32 14.3-32 32s14.3 32 32 32l192 0c17.7 0 32-14.3 32-32zm96 128c0-17.7-14.3-32-32-32L32 160c-17.7 0-32 14.3-32 32s14.3 32 32 32l384 0c17.7 0 32-14.3 32-32zM0 448c0 17.7 14.3 32 32 32l384 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L32 416c-17.7 0-32 14.3-32 32zM352 320c0-17.7-14.3-32-32-32l-192 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l192 0c17.7 0 32-14.3 32-32z",
        },
        child: [],
      },
    ],
  })(t);
}
function AL(t) {
  return Zn({
    tag: "svg",
    attr: { viewBox: "0 0 448 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M448 64c0-17.7-14.3-32-32-32L32 32C14.3 32 0 46.3 0 64S14.3 96 32 96l384 0c17.7 0 32-14.3 32-32zm0 256c0-17.7-14.3-32-32-32L32 288c-17.7 0-32 14.3-32 32s14.3 32 32 32l384 0c17.7 0 32-14.3 32-32zM0 192c0 17.7 14.3 32 32 32l384 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L32 160c-17.7 0-32 14.3-32 32zM448 448c0-17.7-14.3-32-32-32L32 416c-17.7 0-32 14.3-32 32s14.3 32 32 32l384 0c17.7 0 32-14.3 32-32z",
        },
        child: [],
      },
    ],
  })(t);
}
function RL(t) {
  return Zn({
    tag: "svg",
    attr: { viewBox: "0 0 448 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M288 64c0 17.7-14.3 32-32 32L32 96C14.3 96 0 81.7 0 64S14.3 32 32 32l224 0c17.7 0 32 14.3 32 32zm0 256c0 17.7-14.3 32-32 32L32 352c-17.7 0-32-14.3-32-32s14.3-32 32-32l224 0c17.7 0 32 14.3 32 32zM0 192c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 224c-17.7 0-32-14.3-32-32zM448 448c0 17.7-14.3 32-32 32L32 480c-17.7 0-32-14.3-32-32s14.3-32 32-32l384 0c17.7 0 32 14.3 32 32z",
        },
        child: [],
      },
    ],
  })(t);
}
function PL(t) {
  return Zn({
    tag: "svg",
    attr: { viewBox: "0 0 448 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M448 64c0 17.7-14.3 32-32 32L192 96c-17.7 0-32-14.3-32-32s14.3-32 32-32l224 0c17.7 0 32 14.3 32 32zm0 256c0 17.7-14.3 32-32 32l-224 0c-17.7 0-32-14.3-32-32s14.3-32 32-32l224 0c17.7 0 32 14.3 32 32zM0 192c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 224c-17.7 0-32-14.3-32-32zM448 448c0 17.7-14.3 32-32 32L32 480c-17.7 0-32-14.3-32-32s14.3-32 32-32l384 0c17.7 0 32 14.3 32 32z",
        },
        child: [],
      },
    ],
  })(t);
}
function DL(t) {
  return Zn({
    tag: "svg",
    attr: { viewBox: "0 0 384 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M0 64C0 46.3 14.3 32 32 32l48 0 16 0 128 0c70.7 0 128 57.3 128 128c0 31.3-11.3 60.1-30 82.3c37.1 22.4 62 63.1 62 109.7c0 70.7-57.3 128-128 128L96 480l-16 0-48 0c-17.7 0-32-14.3-32-32s14.3-32 32-32l16 0 0-160L48 96 32 96C14.3 96 0 81.7 0 64zM224 224c35.3 0 64-28.7 64-64s-28.7-64-64-64L112 96l0 128 112 0zM112 288l0 128 144 0c35.3 0 64-28.7 64-64s-28.7-64-64-64l-32 0-112 0z",
        },
        child: [],
      },
    ],
  })(t);
}
function IL(t) {
  return Zn({
    tag: "svg",
    attr: { viewBox: "0 0 384 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M128 64c0-17.7 14.3-32 32-32l192 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-58.7 0L160 416l64 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 480c-17.7 0-32-14.3-32-32s14.3-32 32-32l58.7 0L224 96l-64 0c-17.7 0-32-14.3-32-32z",
        },
        child: [],
      },
    ],
  })(t);
}
function LL(t) {
  return Zn({
    tag: "svg",
    attr: { viewBox: "0 0 512 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M24 56c0-13.3 10.7-24 24-24l32 0c13.3 0 24 10.7 24 24l0 120 16 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-80 0c-13.3 0-24-10.7-24-24s10.7-24 24-24l16 0 0-96-8 0C34.7 80 24 69.3 24 56zM86.7 341.2c-6.5-7.4-18.3-6.9-24 1.2L51.5 357.9c-7.7 10.8-22.7 13.3-33.5 5.6s-13.3-22.7-5.6-33.5l11.1-15.6c23.7-33.2 72.3-35.6 99.2-4.9c21.3 24.4 20.8 60.9-1.1 84.7L86.8 432l33.2 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-88 0c-9.5 0-18.2-5.6-22-14.4s-2.1-18.9 4.3-25.9l72-78c5.3-5.8 5.4-14.6 .3-20.5zM224 64l256 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-256 0c-17.7 0-32-14.3-32-32s14.3-32 32-32zm0 160l256 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-256 0c-17.7 0-32-14.3-32-32s14.3-32 32-32zm0 160l256 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-256 0c-17.7 0-32-14.3-32-32s14.3-32 32-32z",
        },
        child: [],
      },
    ],
  })(t);
}
function $L(t) {
  return Zn({
    tag: "svg",
    attr: { viewBox: "0 0 512 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M64 144a48 48 0 1 0 0-96 48 48 0 1 0 0 96zM192 64c-17.7 0-32 14.3-32 32s14.3 32 32 32l288 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L192 64zm0 160c-17.7 0-32 14.3-32 32s14.3 32 32 32l288 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-288 0zm0 160c-17.7 0-32 14.3-32 32s14.3 32 32 32l288 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-288 0zM64 464a48 48 0 1 0 0-96 48 48 0 1 0 0 96zm48-208a48 48 0 1 0 -96 0 48 48 0 1 0 96 0z",
        },
        child: [],
      },
    ],
  })(t);
}
function _L(t) {
  return Zn({
    tag: "svg",
    attr: { viewBox: "0 0 512 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M161.3 144c3.2-17.2 14-30.1 33.7-38.6c21.1-9 51.8-12.3 88.6-6.5c11.9 1.9 48.8 9.1 60.1 12c17.1 4.5 34.6-5.6 39.2-22.7s-5.6-34.6-22.7-39.2c-14.3-3.8-53.6-11.4-66.6-13.4c-44.7-7-88.3-4.2-123.7 10.9c-36.5 15.6-64.4 44.8-71.8 87.3c-.1 .6-.2 1.1-.2 1.7c-2.8 23.9 .5 45.6 10.1 64.6c4.5 9 10.2 16.9 16.7 23.9L32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l448 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-209.9 0-.4-.1-1.1-.3c-36-10.8-65.2-19.6-85.2-33.1c-9.3-6.3-15-12.6-18.2-19.1c-3.1-6.1-5.2-14.6-3.8-27.4zM348.9 337.2c2.7 6.5 4.4 15.8 1.9 30.1c-3 17.6-13.8 30.8-33.9 39.4c-21.1 9-51.7 12.3-88.5 6.5c-18-2.9-49.1-13.5-74.4-22.1c-5.6-1.9-11-3.7-15.9-5.4c-16.8-5.6-34.9 3.5-40.5 20.3s3.5 34.9 20.3 40.5c3.6 1.2 7.9 2.7 12.7 4.3c0 0 0 0 0 0s0 0 0 0c24.9 8.5 63.6 21.7 87.6 25.6c0 0 0 0 0 0l.2 0c44.7 7 88.3 4.2 123.7-10.9c36.5-15.6 64.4-44.8 71.8-87.3c3.6-21 2.7-40.4-3.1-58.1l-75.7 0c7 5.6 11.4 11.2 13.9 17.2z",
        },
        child: [],
      },
    ],
  })(t);
}
function FL(t) {
  return Zn({
    tag: "svg",
    attr: { viewBox: "0 0 448 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M16 64c0-17.7 14.3-32 32-32l96 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-16 0 0 128c0 53 43 96 96 96s96-43 96-96l0-128-16 0c-17.7 0-32-14.3-32-32s14.3-32 32-32l96 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-16 0 0 128c0 88.4-71.6 160-160 160s-160-71.6-160-160L64 96 48 96C30.3 96 16 81.7 16 64zM0 448c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 480c-17.7 0-32-14.3-32-32z",
        },
        child: [],
      },
    ],
  })(t);
}
function lx(t, e) {
  if (typeof t == "function") return t(e);
  t != null && (t.current = e);
}
function Zd(...t) {
  return (e) => {
    let n = !1;
    const r = t.map((o) => {
      const i = lx(o, e);
      return !n && typeof i == "function" && (n = !0), i;
    });
    if (n)
      return () => {
        for (let o = 0; o < r.length; o++) {
          const i = r[o];
          typeof i == "function" ? i() : lx(t[o], null);
        }
      };
  };
}
function ft(...t) {
  return b.useCallback(Zd(...t), t);
}
var Ho = b.forwardRef((t, e) => {
  const { children: n, ...r } = t,
    o = b.Children.toArray(n),
    i = o.find(jL);
  if (i) {
    const l = i.props.children,
      u = o.map((c) =>
        c === i
          ? b.Children.count(l) > 1
            ? b.Children.only(null)
            : b.isValidElement(l)
            ? l.props.children
            : null
          : c
      );
    return O.jsx(Fm, {
      ...r,
      ref: e,
      children: b.isValidElement(l) ? b.cloneElement(l, void 0, u) : null,
    });
  }
  return O.jsx(Fm, { ...r, ref: e, children: n });
});
Ho.displayName = "Slot";
var Fm = b.forwardRef((t, e) => {
  const { children: n, ...r } = t;
  if (b.isValidElement(n)) {
    const o = HL(n),
      i = BL(r, n.props);
    return (
      n.type !== b.Fragment && (i.ref = e ? Zd(e, o) : o), b.cloneElement(n, i)
    );
  }
  return b.Children.count(n) > 1 ? b.Children.only(null) : null;
});
Fm.displayName = "SlotClone";
var zL = ({ children: t }) => O.jsx(O.Fragment, { children: t });
function jL(t) {
  return b.isValidElement(t) && t.type === zL;
}
function BL(t, e) {
  const n = { ...e };
  for (const r in e) {
    const o = t[r],
      i = e[r];
    /^on[A-Z]/.test(r)
      ? o && i
        ? (n[r] = (...u) => {
            i(...u), o(...u);
          })
        : o && (n[r] = o)
      : r === "style"
      ? (n[r] = { ...o, ...i })
      : r === "className" && (n[r] = [o, i].filter(Boolean).join(" "));
  }
  return { ...t, ...n };
}
function HL(t) {
  var r, o;
  let e =
      (r = Object.getOwnPropertyDescriptor(t.props, "ref")) == null
        ? void 0
        : r.get,
    n = e && "isReactWarning" in e && e.isReactWarning;
  return n
    ? t.ref
    : ((e =
        (o = Object.getOwnPropertyDescriptor(t, "ref")) == null
          ? void 0
          : o.get),
      (n = e && "isReactWarning" in e && e.isReactWarning),
      n ? t.props.ref : t.props.ref || t.ref);
}
function hC(t) {
  var e,
    n,
    r = "";
  if (typeof t == "string" || typeof t == "number") r += t;
  else if (typeof t == "object")
    if (Array.isArray(t)) {
      var o = t.length;
      for (e = 0; e < o; e++)
        t[e] && (n = hC(t[e])) && (r && (r += " "), (r += n));
    } else for (n in t) t[n] && (r && (r += " "), (r += n));
  return r;
}
function mC() {
  for (var t, e, n = 0, r = "", o = arguments.length; n < o; n++)
    (t = arguments[n]) && (e = hC(t)) && (r && (r += " "), (r += e));
  return r;
}
const ax = (t) => (typeof t == "boolean" ? `${t}` : t === 0 ? "0" : t),
  ux = mC,
  VL = (t, e) => (n) => {
    var r;
    if ((e == null ? void 0 : e.variants) == null)
      return ux(
        t,
        n == null ? void 0 : n.class,
        n == null ? void 0 : n.className
      );
    const { variants: o, defaultVariants: i } = e,
      l = Object.keys(o).map((f) => {
        const p = n == null ? void 0 : n[f],
          m = i == null ? void 0 : i[f];
        if (p === null) return null;
        const y = ax(p) || ax(m);
        return o[f][y];
      }),
      u =
        n &&
        Object.entries(n).reduce((f, p) => {
          let [m, y] = p;
          return y === void 0 || (f[m] = y), f;
        }, {}),
      c =
        e == null || (r = e.compoundVariants) === null || r === void 0
          ? void 0
          : r.reduce((f, p) => {
              let { class: m, className: y, ...v } = p;
              return Object.entries(v).every((x) => {
                let [S, C] = x;
                return Array.isArray(C)
                  ? C.includes({ ...i, ...u }[S])
                  : { ...i, ...u }[S] === C;
              })
                ? [...f, m, y]
                : f;
            }, []);
    return ux(
      t,
      l,
      c,
      n == null ? void 0 : n.class,
      n == null ? void 0 : n.className
    );
  },
  Gg = "-",
  WL = (t) => {
    const e = KL(t),
      { conflictingClassGroups: n, conflictingClassGroupModifiers: r } = t;
    return {
      getClassGroupId: (l) => {
        const u = l.split(Gg);
        return u[0] === "" && u.length !== 1 && u.shift(), gC(u, e) || UL(l);
      },
      getConflictingClassGroupIds: (l, u) => {
        const c = n[l] || [];
        return u && r[l] ? [...c, ...r[l]] : c;
      },
    };
  },
  gC = (t, e) => {
    var l;
    if (t.length === 0) return e.classGroupId;
    const n = t[0],
      r = e.nextPart.get(n),
      o = r ? gC(t.slice(1), r) : void 0;
    if (o) return o;
    if (e.validators.length === 0) return;
    const i = t.join(Gg);
    return (l = e.validators.find(({ validator: u }) => u(i))) == null
      ? void 0
      : l.classGroupId;
  },
  cx = /^\[(.+)\]$/,
  UL = (t) => {
    if (cx.test(t)) {
      const e = cx.exec(t)[1],
        n = e == null ? void 0 : e.substring(0, e.indexOf(":"));
      if (n) return "arbitrary.." + n;
    }
  },
  KL = (t) => {
    const { theme: e, prefix: n } = t,
      r = { nextPart: new Map(), validators: [] };
    return (
      GL(Object.entries(t.classGroups), n).forEach(([i, l]) => {
        zm(l, r, i, e);
      }),
      r
    );
  },
  zm = (t, e, n, r) => {
    t.forEach((o) => {
      if (typeof o == "string") {
        const i = o === "" ? e : dx(e, o);
        i.classGroupId = n;
        return;
      }
      if (typeof o == "function") {
        if (qL(o)) {
          zm(o(r), e, n, r);
          return;
        }
        e.validators.push({ validator: o, classGroupId: n });
        return;
      }
      Object.entries(o).forEach(([i, l]) => {
        zm(l, dx(e, i), n, r);
      });
    });
  },
  dx = (t, e) => {
    let n = t;
    return (
      e.split(Gg).forEach((r) => {
        n.nextPart.has(r) ||
          n.nextPart.set(r, { nextPart: new Map(), validators: [] }),
          (n = n.nextPart.get(r));
      }),
      n
    );
  },
  qL = (t) => t.isThemeGetter,
  GL = (t, e) =>
    e
      ? t.map(([n, r]) => {
          const o = r.map((i) =>
            typeof i == "string"
              ? e + i
              : typeof i == "object"
              ? Object.fromEntries(
                  Object.entries(i).map(([l, u]) => [e + l, u])
                )
              : i
          );
          return [n, o];
        })
      : t,
  JL = (t) => {
    if (t < 1) return { get: () => {}, set: () => {} };
    let e = 0,
      n = new Map(),
      r = new Map();
    const o = (i, l) => {
      n.set(i, l), e++, e > t && ((e = 0), (r = n), (n = new Map()));
    };
    return {
      get(i) {
        let l = n.get(i);
        if (l !== void 0) return l;
        if ((l = r.get(i)) !== void 0) return o(i, l), l;
      },
      set(i, l) {
        n.has(i) ? n.set(i, l) : o(i, l);
      },
    };
  },
  yC = "!",
  QL = (t) => {
    const { separator: e, experimentalParseClassName: n } = t,
      r = e.length === 1,
      o = e[0],
      i = e.length,
      l = (u) => {
        const c = [];
        let f = 0,
          p = 0,
          m;
        for (let C = 0; C < u.length; C++) {
          let E = u[C];
          if (f === 0) {
            if (E === o && (r || u.slice(C, C + i) === e)) {
              c.push(u.slice(p, C)), (p = C + i);
              continue;
            }
            if (E === "/") {
              m = C;
              continue;
            }
          }
          E === "[" ? f++ : E === "]" && f--;
        }
        const y = c.length === 0 ? u : u.substring(p),
          v = y.startsWith(yC),
          x = v ? y.substring(1) : y,
          S = m && m > p ? m - p : void 0;
        return {
          modifiers: c,
          hasImportantModifier: v,
          baseClassName: x,
          maybePostfixModifierPosition: S,
        };
      };
    return n ? (u) => n({ className: u, parseClassName: l }) : l;
  },
  YL = (t) => {
    if (t.length <= 1) return t;
    const e = [];
    let n = [];
    return (
      t.forEach((r) => {
        r[0] === "[" ? (e.push(...n.sort(), r), (n = [])) : n.push(r);
      }),
      e.push(...n.sort()),
      e
    );
  },
  XL = (t) => ({ cache: JL(t.cacheSize), parseClassName: QL(t), ...WL(t) }),
  ZL = /\s+/,
  e4 = (t, e) => {
    const {
        parseClassName: n,
        getClassGroupId: r,
        getConflictingClassGroupIds: o,
      } = e,
      i = [],
      l = t.trim().split(ZL);
    let u = "";
    for (let c = l.length - 1; c >= 0; c -= 1) {
      const f = l[c],
        {
          modifiers: p,
          hasImportantModifier: m,
          baseClassName: y,
          maybePostfixModifierPosition: v,
        } = n(f);
      let x = !!v,
        S = r(x ? y.substring(0, v) : y);
      if (!S) {
        if (!x) {
          u = f + (u.length > 0 ? " " + u : u);
          continue;
        }
        if (((S = r(y)), !S)) {
          u = f + (u.length > 0 ? " " + u : u);
          continue;
        }
        x = !1;
      }
      const C = YL(p).join(":"),
        E = m ? C + yC : C,
        N = E + S;
      if (i.includes(N)) continue;
      i.push(N);
      const $ = o(S, x);
      for (let M = 0; M < $.length; ++M) {
        const I = $[M];
        i.push(E + I);
      }
      u = f + (u.length > 0 ? " " + u : u);
    }
    return u;
  };
function t4() {
  let t = 0,
    e,
    n,
    r = "";
  for (; t < arguments.length; )
    (e = arguments[t++]) && (n = vC(e)) && (r && (r += " "), (r += n));
  return r;
}
const vC = (t) => {
  if (typeof t == "string") return t;
  let e,
    n = "";
  for (let r = 0; r < t.length; r++)
    t[r] && (e = vC(t[r])) && (n && (n += " "), (n += e));
  return n;
};
function n4(t, ...e) {
  let n,
    r,
    o,
    i = l;
  function l(c) {
    const f = e.reduce((p, m) => m(p), t());
    return (n = XL(f)), (r = n.cache.get), (o = n.cache.set), (i = u), u(c);
  }
  function u(c) {
    const f = r(c);
    if (f) return f;
    const p = e4(c, n);
    return o(c, p), p;
  }
  return function () {
    return i(t4.apply(null, arguments));
  };
}
const Ke = (t) => {
    const e = (n) => n[t] || [];
    return (e.isThemeGetter = !0), e;
  },
  wC = /^\[(?:([a-z-]+):)?(.+)\]$/i,
  r4 = /^\d+\/\d+$/,
  o4 = new Set(["px", "full", "screen"]),
  i4 = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/,
  s4 =
    /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/,
  l4 = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/,
  a4 = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/,
  u4 =
    /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/,
  zr = (t) => Fs(t) || o4.has(t) || r4.test(t),
  xo = (t) => rl(t, "length", y4),
  Fs = (t) => !!t && !Number.isNaN(Number(t)),
  zh = (t) => rl(t, "number", Fs),
  ql = (t) => !!t && Number.isInteger(Number(t)),
  c4 = (t) => t.endsWith("%") && Fs(t.slice(0, -1)),
  Ne = (t) => wC.test(t),
  bo = (t) => i4.test(t),
  d4 = new Set(["length", "size", "percentage"]),
  f4 = (t) => rl(t, d4, xC),
  p4 = (t) => rl(t, "position", xC),
  h4 = new Set(["image", "url"]),
  m4 = (t) => rl(t, h4, w4),
  g4 = (t) => rl(t, "", v4),
  Gl = () => !0,
  rl = (t, e, n) => {
    const r = wC.exec(t);
    return r
      ? r[1]
        ? typeof e == "string"
          ? r[1] === e
          : e.has(r[1])
        : n(r[2])
      : !1;
  },
  y4 = (t) => s4.test(t) && !l4.test(t),
  xC = () => !1,
  v4 = (t) => a4.test(t),
  w4 = (t) => u4.test(t),
  x4 = () => {
    const t = Ke("colors"),
      e = Ke("spacing"),
      n = Ke("blur"),
      r = Ke("brightness"),
      o = Ke("borderColor"),
      i = Ke("borderRadius"),
      l = Ke("borderSpacing"),
      u = Ke("borderWidth"),
      c = Ke("contrast"),
      f = Ke("grayscale"),
      p = Ke("hueRotate"),
      m = Ke("invert"),
      y = Ke("gap"),
      v = Ke("gradientColorStops"),
      x = Ke("gradientColorStopPositions"),
      S = Ke("inset"),
      C = Ke("margin"),
      E = Ke("opacity"),
      N = Ke("padding"),
      $ = Ke("saturate"),
      M = Ke("scale"),
      I = Ke("sepia"),
      R = Ke("skew"),
      F = Ke("space"),
      H = Ke("translate"),
      U = () => ["auto", "contain", "none"],
      re = () => ["auto", "hidden", "clip", "visible", "scroll"],
      ce = () => ["auto", Ne, e],
      ee = () => [Ne, e],
      le = () => ["", zr, xo],
      de = () => ["auto", Fs, Ne],
      xe = () => [
        "bottom",
        "center",
        "left",
        "left-bottom",
        "left-top",
        "right",
        "right-bottom",
        "right-top",
        "top",
      ],
      oe = () => ["solid", "dashed", "dotted", "double", "none"],
      se = () => [
        "normal",
        "multiply",
        "screen",
        "overlay",
        "darken",
        "lighten",
        "color-dodge",
        "color-burn",
        "hard-light",
        "soft-light",
        "difference",
        "exclusion",
        "hue",
        "saturation",
        "color",
        "luminosity",
      ],
      B = () => [
        "start",
        "end",
        "center",
        "between",
        "around",
        "evenly",
        "stretch",
      ],
      V = () => ["", "0", Ne],
      K = () => [
        "auto",
        "avoid",
        "all",
        "avoid-page",
        "page",
        "left",
        "right",
        "column",
      ],
      D = () => [Fs, Ne];
    return {
      cacheSize: 500,
      separator: ":",
      theme: {
        colors: [Gl],
        spacing: [zr, xo],
        blur: ["none", "", bo, Ne],
        brightness: D(),
        borderColor: [t],
        borderRadius: ["none", "", "full", bo, Ne],
        borderSpacing: ee(),
        borderWidth: le(),
        contrast: D(),
        grayscale: V(),
        hueRotate: D(),
        invert: V(),
        gap: ee(),
        gradientColorStops: [t],
        gradientColorStopPositions: [c4, xo],
        inset: ce(),
        margin: ce(),
        opacity: D(),
        padding: ee(),
        saturate: D(),
        scale: D(),
        sepia: V(),
        skew: D(),
        space: ee(),
        translate: ee(),
      },
      classGroups: {
        aspect: [{ aspect: ["auto", "square", "video", Ne] }],
        container: ["container"],
        columns: [{ columns: [bo] }],
        "break-after": [{ "break-after": K() }],
        "break-before": [{ "break-before": K() }],
        "break-inside": [
          { "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] },
        ],
        "box-decoration": [{ "box-decoration": ["slice", "clone"] }],
        box: [{ box: ["border", "content"] }],
        display: [
          "block",
          "inline-block",
          "inline",
          "flex",
          "inline-flex",
          "table",
          "inline-table",
          "table-caption",
          "table-cell",
          "table-column",
          "table-column-group",
          "table-footer-group",
          "table-header-group",
          "table-row-group",
          "table-row",
          "flow-root",
          "grid",
          "inline-grid",
          "contents",
          "list-item",
          "hidden",
        ],
        float: [{ float: ["right", "left", "none", "start", "end"] }],
        clear: [{ clear: ["left", "right", "both", "none", "start", "end"] }],
        isolation: ["isolate", "isolation-auto"],
        "object-fit": [
          { object: ["contain", "cover", "fill", "none", "scale-down"] },
        ],
        "object-position": [{ object: [...xe(), Ne] }],
        overflow: [{ overflow: re() }],
        "overflow-x": [{ "overflow-x": re() }],
        "overflow-y": [{ "overflow-y": re() }],
        overscroll: [{ overscroll: U() }],
        "overscroll-x": [{ "overscroll-x": U() }],
        "overscroll-y": [{ "overscroll-y": U() }],
        position: ["static", "fixed", "absolute", "relative", "sticky"],
        inset: [{ inset: [S] }],
        "inset-x": [{ "inset-x": [S] }],
        "inset-y": [{ "inset-y": [S] }],
        start: [{ start: [S] }],
        end: [{ end: [S] }],
        top: [{ top: [S] }],
        right: [{ right: [S] }],
        bottom: [{ bottom: [S] }],
        left: [{ left: [S] }],
        visibility: ["visible", "invisible", "collapse"],
        z: [{ z: ["auto", ql, Ne] }],
        basis: [{ basis: ce() }],
        "flex-direction": [
          { flex: ["row", "row-reverse", "col", "col-reverse"] },
        ],
        "flex-wrap": [{ flex: ["wrap", "wrap-reverse", "nowrap"] }],
        flex: [{ flex: ["1", "auto", "initial", "none", Ne] }],
        grow: [{ grow: V() }],
        shrink: [{ shrink: V() }],
        order: [{ order: ["first", "last", "none", ql, Ne] }],
        "grid-cols": [{ "grid-cols": [Gl] }],
        "col-start-end": [{ col: ["auto", { span: ["full", ql, Ne] }, Ne] }],
        "col-start": [{ "col-start": de() }],
        "col-end": [{ "col-end": de() }],
        "grid-rows": [{ "grid-rows": [Gl] }],
        "row-start-end": [{ row: ["auto", { span: [ql, Ne] }, Ne] }],
        "row-start": [{ "row-start": de() }],
        "row-end": [{ "row-end": de() }],
        "grid-flow": [
          { "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] },
        ],
        "auto-cols": [{ "auto-cols": ["auto", "min", "max", "fr", Ne] }],
        "auto-rows": [{ "auto-rows": ["auto", "min", "max", "fr", Ne] }],
        gap: [{ gap: [y] }],
        "gap-x": [{ "gap-x": [y] }],
        "gap-y": [{ "gap-y": [y] }],
        "justify-content": [{ justify: ["normal", ...B()] }],
        "justify-items": [
          { "justify-items": ["start", "end", "center", "stretch"] },
        ],
        "justify-self": [
          { "justify-self": ["auto", "start", "end", "center", "stretch"] },
        ],
        "align-content": [{ content: ["normal", ...B(), "baseline"] }],
        "align-items": [
          { items: ["start", "end", "center", "baseline", "stretch"] },
        ],
        "align-self": [
          { self: ["auto", "start", "end", "center", "stretch", "baseline"] },
        ],
        "place-content": [{ "place-content": [...B(), "baseline"] }],
        "place-items": [
          { "place-items": ["start", "end", "center", "baseline", "stretch"] },
        ],
        "place-self": [
          { "place-self": ["auto", "start", "end", "center", "stretch"] },
        ],
        p: [{ p: [N] }],
        px: [{ px: [N] }],
        py: [{ py: [N] }],
        ps: [{ ps: [N] }],
        pe: [{ pe: [N] }],
        pt: [{ pt: [N] }],
        pr: [{ pr: [N] }],
        pb: [{ pb: [N] }],
        pl: [{ pl: [N] }],
        m: [{ m: [C] }],
        mx: [{ mx: [C] }],
        my: [{ my: [C] }],
        ms: [{ ms: [C] }],
        me: [{ me: [C] }],
        mt: [{ mt: [C] }],
        mr: [{ mr: [C] }],
        mb: [{ mb: [C] }],
        ml: [{ ml: [C] }],
        "space-x": [{ "space-x": [F] }],
        "space-x-reverse": ["space-x-reverse"],
        "space-y": [{ "space-y": [F] }],
        "space-y-reverse": ["space-y-reverse"],
        w: [{ w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", Ne, e] }],
        "min-w": [{ "min-w": [Ne, e, "min", "max", "fit"] }],
        "max-w": [
          {
            "max-w": [
              Ne,
              e,
              "none",
              "full",
              "min",
              "max",
              "fit",
              "prose",
              { screen: [bo] },
              bo,
            ],
          },
        ],
        h: [{ h: [Ne, e, "auto", "min", "max", "fit", "svh", "lvh", "dvh"] }],
        "min-h": [
          { "min-h": [Ne, e, "min", "max", "fit", "svh", "lvh", "dvh"] },
        ],
        "max-h": [
          { "max-h": [Ne, e, "min", "max", "fit", "svh", "lvh", "dvh"] },
        ],
        size: [{ size: [Ne, e, "auto", "min", "max", "fit"] }],
        "font-size": [{ text: ["base", bo, xo] }],
        "font-smoothing": ["antialiased", "subpixel-antialiased"],
        "font-style": ["italic", "not-italic"],
        "font-weight": [
          {
            font: [
              "thin",
              "extralight",
              "light",
              "normal",
              "medium",
              "semibold",
              "bold",
              "extrabold",
              "black",
              zh,
            ],
          },
        ],
        "font-family": [{ font: [Gl] }],
        "fvn-normal": ["normal-nums"],
        "fvn-ordinal": ["ordinal"],
        "fvn-slashed-zero": ["slashed-zero"],
        "fvn-figure": ["lining-nums", "oldstyle-nums"],
        "fvn-spacing": ["proportional-nums", "tabular-nums"],
        "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
        tracking: [
          {
            tracking: [
              "tighter",
              "tight",
              "normal",
              "wide",
              "wider",
              "widest",
              Ne,
            ],
          },
        ],
        "line-clamp": [{ "line-clamp": ["none", Fs, zh] }],
        leading: [
          {
            leading: [
              "none",
              "tight",
              "snug",
              "normal",
              "relaxed",
              "loose",
              zr,
              Ne,
            ],
          },
        ],
        "list-image": [{ "list-image": ["none", Ne] }],
        "list-style-type": [{ list: ["none", "disc", "decimal", Ne] }],
        "list-style-position": [{ list: ["inside", "outside"] }],
        "placeholder-color": [{ placeholder: [t] }],
        "placeholder-opacity": [{ "placeholder-opacity": [E] }],
        "text-alignment": [
          { text: ["left", "center", "right", "justify", "start", "end"] },
        ],
        "text-color": [{ text: [t] }],
        "text-opacity": [{ "text-opacity": [E] }],
        "text-decoration": [
          "underline",
          "overline",
          "line-through",
          "no-underline",
        ],
        "text-decoration-style": [{ decoration: [...oe(), "wavy"] }],
        "text-decoration-thickness": [
          { decoration: ["auto", "from-font", zr, xo] },
        ],
        "underline-offset": [{ "underline-offset": ["auto", zr, Ne] }],
        "text-decoration-color": [{ decoration: [t] }],
        "text-transform": [
          "uppercase",
          "lowercase",
          "capitalize",
          "normal-case",
        ],
        "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
        "text-wrap": [{ text: ["wrap", "nowrap", "balance", "pretty"] }],
        indent: [{ indent: ee() }],
        "vertical-align": [
          {
            align: [
              "baseline",
              "top",
              "middle",
              "bottom",
              "text-top",
              "text-bottom",
              "sub",
              "super",
              Ne,
            ],
          },
        ],
        whitespace: [
          {
            whitespace: [
              "normal",
              "nowrap",
              "pre",
              "pre-line",
              "pre-wrap",
              "break-spaces",
            ],
          },
        ],
        break: [{ break: ["normal", "words", "all", "keep"] }],
        hyphens: [{ hyphens: ["none", "manual", "auto"] }],
        content: [{ content: ["none", Ne] }],
        "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }],
        "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }],
        "bg-opacity": [{ "bg-opacity": [E] }],
        "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }],
        "bg-position": [{ bg: [...xe(), p4] }],
        "bg-repeat": [
          { bg: ["no-repeat", { repeat: ["", "x", "y", "round", "space"] }] },
        ],
        "bg-size": [{ bg: ["auto", "cover", "contain", f4] }],
        "bg-image": [
          {
            bg: [
              "none",
              { "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"] },
              m4,
            ],
          },
        ],
        "bg-color": [{ bg: [t] }],
        "gradient-from-pos": [{ from: [x] }],
        "gradient-via-pos": [{ via: [x] }],
        "gradient-to-pos": [{ to: [x] }],
        "gradient-from": [{ from: [v] }],
        "gradient-via": [{ via: [v] }],
        "gradient-to": [{ to: [v] }],
        rounded: [{ rounded: [i] }],
        "rounded-s": [{ "rounded-s": [i] }],
        "rounded-e": [{ "rounded-e": [i] }],
        "rounded-t": [{ "rounded-t": [i] }],
        "rounded-r": [{ "rounded-r": [i] }],
        "rounded-b": [{ "rounded-b": [i] }],
        "rounded-l": [{ "rounded-l": [i] }],
        "rounded-ss": [{ "rounded-ss": [i] }],
        "rounded-se": [{ "rounded-se": [i] }],
        "rounded-ee": [{ "rounded-ee": [i] }],
        "rounded-es": [{ "rounded-es": [i] }],
        "rounded-tl": [{ "rounded-tl": [i] }],
        "rounded-tr": [{ "rounded-tr": [i] }],
        "rounded-br": [{ "rounded-br": [i] }],
        "rounded-bl": [{ "rounded-bl": [i] }],
        "border-w": [{ border: [u] }],
        "border-w-x": [{ "border-x": [u] }],
        "border-w-y": [{ "border-y": [u] }],
        "border-w-s": [{ "border-s": [u] }],
        "border-w-e": [{ "border-e": [u] }],
        "border-w-t": [{ "border-t": [u] }],
        "border-w-r": [{ "border-r": [u] }],
        "border-w-b": [{ "border-b": [u] }],
        "border-w-l": [{ "border-l": [u] }],
        "border-opacity": [{ "border-opacity": [E] }],
        "border-style": [{ border: [...oe(), "hidden"] }],
        "divide-x": [{ "divide-x": [u] }],
        "divide-x-reverse": ["divide-x-reverse"],
        "divide-y": [{ "divide-y": [u] }],
        "divide-y-reverse": ["divide-y-reverse"],
        "divide-opacity": [{ "divide-opacity": [E] }],
        "divide-style": [{ divide: oe() }],
        "border-color": [{ border: [o] }],
        "border-color-x": [{ "border-x": [o] }],
        "border-color-y": [{ "border-y": [o] }],
        "border-color-s": [{ "border-s": [o] }],
        "border-color-e": [{ "border-e": [o] }],
        "border-color-t": [{ "border-t": [o] }],
        "border-color-r": [{ "border-r": [o] }],
        "border-color-b": [{ "border-b": [o] }],
        "border-color-l": [{ "border-l": [o] }],
        "divide-color": [{ divide: [o] }],
        "outline-style": [{ outline: ["", ...oe()] }],
        "outline-offset": [{ "outline-offset": [zr, Ne] }],
        "outline-w": [{ outline: [zr, xo] }],
        "outline-color": [{ outline: [t] }],
        "ring-w": [{ ring: le() }],
        "ring-w-inset": ["ring-inset"],
        "ring-color": [{ ring: [t] }],
        "ring-opacity": [{ "ring-opacity": [E] }],
        "ring-offset-w": [{ "ring-offset": [zr, xo] }],
        "ring-offset-color": [{ "ring-offset": [t] }],
        shadow: [{ shadow: ["", "inner", "none", bo, g4] }],
        "shadow-color": [{ shadow: [Gl] }],
        opacity: [{ opacity: [E] }],
        "mix-blend": [
          { "mix-blend": [...se(), "plus-lighter", "plus-darker"] },
        ],
        "bg-blend": [{ "bg-blend": se() }],
        filter: [{ filter: ["", "none"] }],
        blur: [{ blur: [n] }],
        brightness: [{ brightness: [r] }],
        contrast: [{ contrast: [c] }],
        "drop-shadow": [{ "drop-shadow": ["", "none", bo, Ne] }],
        grayscale: [{ grayscale: [f] }],
        "hue-rotate": [{ "hue-rotate": [p] }],
        invert: [{ invert: [m] }],
        saturate: [{ saturate: [$] }],
        sepia: [{ sepia: [I] }],
        "backdrop-filter": [{ "backdrop-filter": ["", "none"] }],
        "backdrop-blur": [{ "backdrop-blur": [n] }],
        "backdrop-brightness": [{ "backdrop-brightness": [r] }],
        "backdrop-contrast": [{ "backdrop-contrast": [c] }],
        "backdrop-grayscale": [{ "backdrop-grayscale": [f] }],
        "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [p] }],
        "backdrop-invert": [{ "backdrop-invert": [m] }],
        "backdrop-opacity": [{ "backdrop-opacity": [E] }],
        "backdrop-saturate": [{ "backdrop-saturate": [$] }],
        "backdrop-sepia": [{ "backdrop-sepia": [I] }],
        "border-collapse": [{ border: ["collapse", "separate"] }],
        "border-spacing": [{ "border-spacing": [l] }],
        "border-spacing-x": [{ "border-spacing-x": [l] }],
        "border-spacing-y": [{ "border-spacing-y": [l] }],
        "table-layout": [{ table: ["auto", "fixed"] }],
        caption: [{ caption: ["top", "bottom"] }],
        transition: [
          {
            transition: [
              "none",
              "all",
              "",
              "colors",
              "opacity",
              "shadow",
              "transform",
              Ne,
            ],
          },
        ],
        duration: [{ duration: D() }],
        ease: [{ ease: ["linear", "in", "out", "in-out", Ne] }],
        delay: [{ delay: D() }],
        animate: [{ animate: ["none", "spin", "ping", "pulse", "bounce", Ne] }],
        transform: [{ transform: ["", "gpu", "none"] }],
        scale: [{ scale: [M] }],
        "scale-x": [{ "scale-x": [M] }],
        "scale-y": [{ "scale-y": [M] }],
        rotate: [{ rotate: [ql, Ne] }],
        "translate-x": [{ "translate-x": [H] }],
        "translate-y": [{ "translate-y": [H] }],
        "skew-x": [{ "skew-x": [R] }],
        "skew-y": [{ "skew-y": [R] }],
        "transform-origin": [
          {
            origin: [
              "center",
              "top",
              "top-right",
              "right",
              "bottom-right",
              "bottom",
              "bottom-left",
              "left",
              "top-left",
              Ne,
            ],
          },
        ],
        accent: [{ accent: ["auto", t] }],
        appearance: [{ appearance: ["none", "auto"] }],
        cursor: [
          {
            cursor: [
              "auto",
              "default",
              "pointer",
              "wait",
              "text",
              "move",
              "help",
              "not-allowed",
              "none",
              "context-menu",
              "progress",
              "cell",
              "crosshair",
              "vertical-text",
              "alias",
              "copy",
              "no-drop",
              "grab",
              "grabbing",
              "all-scroll",
              "col-resize",
              "row-resize",
              "n-resize",
              "e-resize",
              "s-resize",
              "w-resize",
              "ne-resize",
              "nw-resize",
              "se-resize",
              "sw-resize",
              "ew-resize",
              "ns-resize",
              "nesw-resize",
              "nwse-resize",
              "zoom-in",
              "zoom-out",
              Ne,
            ],
          },
        ],
        "caret-color": [{ caret: [t] }],
        "pointer-events": [{ "pointer-events": ["none", "auto"] }],
        resize: [{ resize: ["none", "y", "x", ""] }],
        "scroll-behavior": [{ scroll: ["auto", "smooth"] }],
        "scroll-m": [{ "scroll-m": ee() }],
        "scroll-mx": [{ "scroll-mx": ee() }],
        "scroll-my": [{ "scroll-my": ee() }],
        "scroll-ms": [{ "scroll-ms": ee() }],
        "scroll-me": [{ "scroll-me": ee() }],
        "scroll-mt": [{ "scroll-mt": ee() }],
        "scroll-mr": [{ "scroll-mr": ee() }],
        "scroll-mb": [{ "scroll-mb": ee() }],
        "scroll-ml": [{ "scroll-ml": ee() }],
        "scroll-p": [{ "scroll-p": ee() }],
        "scroll-px": [{ "scroll-px": ee() }],
        "scroll-py": [{ "scroll-py": ee() }],
        "scroll-ps": [{ "scroll-ps": ee() }],
        "scroll-pe": [{ "scroll-pe": ee() }],
        "scroll-pt": [{ "scroll-pt": ee() }],
        "scroll-pr": [{ "scroll-pr": ee() }],
        "scroll-pb": [{ "scroll-pb": ee() }],
        "scroll-pl": [{ "scroll-pl": ee() }],
        "snap-align": [{ snap: ["start", "end", "center", "align-none"] }],
        "snap-stop": [{ snap: ["normal", "always"] }],
        "snap-type": [{ snap: ["none", "x", "y", "both"] }],
        "snap-strictness": [{ snap: ["mandatory", "proximity"] }],
        touch: [{ touch: ["auto", "none", "manipulation"] }],
        "touch-x": [{ "touch-pan": ["x", "left", "right"] }],
        "touch-y": [{ "touch-pan": ["y", "up", "down"] }],
        "touch-pz": ["touch-pinch-zoom"],
        select: [{ select: ["none", "text", "all", "auto"] }],
        "will-change": [
          { "will-change": ["auto", "scroll", "contents", "transform", Ne] },
        ],
        fill: [{ fill: [t, "none"] }],
        "stroke-w": [{ stroke: [zr, xo, zh] }],
        stroke: [{ stroke: [t, "none"] }],
        sr: ["sr-only", "not-sr-only"],
        "forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }],
      },
      conflictingClassGroups: {
        overflow: ["overflow-x", "overflow-y"],
        overscroll: ["overscroll-x", "overscroll-y"],
        inset: [
          "inset-x",
          "inset-y",
          "start",
          "end",
          "top",
          "right",
          "bottom",
          "left",
        ],
        "inset-x": ["right", "left"],
        "inset-y": ["top", "bottom"],
        flex: ["basis", "grow", "shrink"],
        gap: ["gap-x", "gap-y"],
        p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
        px: ["pr", "pl"],
        py: ["pt", "pb"],
        m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
        mx: ["mr", "ml"],
        my: ["mt", "mb"],
        size: ["w", "h"],
        "font-size": ["leading"],
        "fvn-normal": [
          "fvn-ordinal",
          "fvn-slashed-zero",
          "fvn-figure",
          "fvn-spacing",
          "fvn-fraction",
        ],
        "fvn-ordinal": ["fvn-normal"],
        "fvn-slashed-zero": ["fvn-normal"],
        "fvn-figure": ["fvn-normal"],
        "fvn-spacing": ["fvn-normal"],
        "fvn-fraction": ["fvn-normal"],
        "line-clamp": ["display", "overflow"],
        rounded: [
          "rounded-s",
          "rounded-e",
          "rounded-t",
          "rounded-r",
          "rounded-b",
          "rounded-l",
          "rounded-ss",
          "rounded-se",
          "rounded-ee",
          "rounded-es",
          "rounded-tl",
          "rounded-tr",
          "rounded-br",
          "rounded-bl",
        ],
        "rounded-s": ["rounded-ss", "rounded-es"],
        "rounded-e": ["rounded-se", "rounded-ee"],
        "rounded-t": ["rounded-tl", "rounded-tr"],
        "rounded-r": ["rounded-tr", "rounded-br"],
        "rounded-b": ["rounded-br", "rounded-bl"],
        "rounded-l": ["rounded-tl", "rounded-bl"],
        "border-spacing": ["border-spacing-x", "border-spacing-y"],
        "border-w": [
          "border-w-s",
          "border-w-e",
          "border-w-t",
          "border-w-r",
          "border-w-b",
          "border-w-l",
        ],
        "border-w-x": ["border-w-r", "border-w-l"],
        "border-w-y": ["border-w-t", "border-w-b"],
        "border-color": [
          "border-color-s",
          "border-color-e",
          "border-color-t",
          "border-color-r",
          "border-color-b",
          "border-color-l",
        ],
        "border-color-x": ["border-color-r", "border-color-l"],
        "border-color-y": ["border-color-t", "border-color-b"],
        "scroll-m": [
          "scroll-mx",
          "scroll-my",
          "scroll-ms",
          "scroll-me",
          "scroll-mt",
          "scroll-mr",
          "scroll-mb",
          "scroll-ml",
        ],
        "scroll-mx": ["scroll-mr", "scroll-ml"],
        "scroll-my": ["scroll-mt", "scroll-mb"],
        "scroll-p": [
          "scroll-px",
          "scroll-py",
          "scroll-ps",
          "scroll-pe",
          "scroll-pt",
          "scroll-pr",
          "scroll-pb",
          "scroll-pl",
        ],
        "scroll-px": ["scroll-pr", "scroll-pl"],
        "scroll-py": ["scroll-pt", "scroll-pb"],
        touch: ["touch-x", "touch-y", "touch-pz"],
        "touch-x": ["touch"],
        "touch-y": ["touch"],
        "touch-pz": ["touch"],
      },
      conflictingClassGroupModifiers: { "font-size": ["leading"] },
    };
  },
  b4 = n4(x4);
function Be(...t) {
  return b4(mC(t));
}
const S4 = VL(
    "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
    {
      variants: {
        variant: {
          default: "bg-primary text-primary-foreground hover:bg-primary/90",
          destructive:
            "bg-destructive text-destructive-foreground hover:bg-destructive/90",
          outline:
            "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
          secondary:
            "bg-secondary text-secondary-foreground hover:bg-secondary/80",
          ghost: "hover:bg-accent hover:text-accent-foreground",
          link: "text-primary underline-offset-4 hover:underline",
        },
        size: {
          default: "h-10 px-4 py-2",
          sm: "h-9 rounded-md px-3",
          lg: "h-11 rounded-md px-8",
          icon: "h-10 w-10",
        },
      },
      defaultVariants: { variant: "default", size: "default" },
    }
  ),
  ef = b.forwardRef(
    ({ className: t, variant: e, size: n, asChild: r = !1, ...o }, i) => {
      const l = r ? Ho : "button";
      return O.jsx(l, {
        className: Be(S4({ variant: e, size: n, className: t })),
        ref: i,
        ...o,
      });
    }
  );
ef.displayName = "Button";
function fn({ children: t, className: e, ...n }) {
  return O.jsx(ef, {
    className: `bg-white text-black hover:bg-gray-300 p-2 ${e ?? ""}`,
    ...n,
    children: t,
  });
}
function bC(t) {
  const { children: e, onClick: n } = t;
  return O.jsx(ef, {
    asChild: !0,
    className: "bg-white text-black hover:bg-gray-300 p-2",
    onClick: n,
    children: O.jsx("div", { children: e }),
  });
}
function Oe(t, e, { checkForDefaultPrevented: n = !0 } = {}) {
  return function (o) {
    if ((t == null || t(o), n === !1 || !o.defaultPrevented))
      return e == null ? void 0 : e(o);
  };
}
function C4(t, e) {
  const n = b.createContext(e),
    r = (i) => {
      const { children: l, ...u } = i,
        c = b.useMemo(() => u, Object.values(u));
      return O.jsx(n.Provider, { value: c, children: l });
    };
  r.displayName = t + "Provider";
  function o(i) {
    const l = b.useContext(n);
    if (l) return l;
    if (e !== void 0) return e;
    throw new Error(`\`${i}\` must be used within \`${t}\``);
  }
  return [r, o];
}
function Ui(t, e = []) {
  let n = [];
  function r(i, l) {
    const u = b.createContext(l),
      c = n.length;
    n = [...n, l];
    const f = (m) => {
      var E;
      const { scope: y, children: v, ...x } = m,
        S = ((E = y == null ? void 0 : y[t]) == null ? void 0 : E[c]) || u,
        C = b.useMemo(() => x, Object.values(x));
      return O.jsx(S.Provider, { value: C, children: v });
    };
    f.displayName = i + "Provider";
    function p(m, y) {
      var S;
      const v = ((S = y == null ? void 0 : y[t]) == null ? void 0 : S[c]) || u,
        x = b.useContext(v);
      if (x) return x;
      if (l !== void 0) return l;
      throw new Error(`\`${m}\` must be used within \`${i}\``);
    }
    return [f, p];
  }
  const o = () => {
    const i = n.map((l) => b.createContext(l));
    return function (u) {
      const c = (u == null ? void 0 : u[t]) || i;
      return b.useMemo(() => ({ [`__scope${t}`]: { ...u, [t]: c } }), [u, c]);
    };
  };
  return (o.scopeName = t), [r, k4(o, ...e)];
}
function k4(...t) {
  const e = t[0];
  if (t.length === 1) return e;
  const n = () => {
    const r = t.map((o) => ({ useScope: o(), scopeName: o.scopeName }));
    return function (i) {
      const l = r.reduce((u, { useScope: c, scopeName: f }) => {
        const m = c(i)[`__scope${f}`];
        return { ...u, ...m };
      }, {});
      return b.useMemo(() => ({ [`__scope${e.scopeName}`]: l }), [l]);
    };
  };
  return (n.scopeName = e.scopeName), n;
}
function Jn(t) {
  const e = b.useRef(t);
  return (
    b.useEffect(() => {
      e.current = t;
    }),
    b.useMemo(
      () =>
        (...n) => {
          var r;
          return (r = e.current) == null ? void 0 : r.call(e, ...n);
        },
      []
    )
  );
}
function Jg({ prop: t, defaultProp: e, onChange: n = () => {} }) {
  const [r, o] = E4({ defaultProp: e, onChange: n }),
    i = t !== void 0,
    l = i ? t : r,
    u = Jn(n),
    c = b.useCallback(
      (f) => {
        if (i) {
          const m = typeof f == "function" ? f(t) : f;
          m !== t && u(m);
        } else o(f);
      },
      [i, t, o, u]
    );
  return [l, c];
}
function E4({ defaultProp: t, onChange: e }) {
  const n = b.useState(t),
    [r] = n,
    o = b.useRef(r),
    i = Jn(e);
  return (
    b.useEffect(() => {
      o.current !== r && (i(r), (o.current = r));
    }, [r, o, i]),
    n
  );
}
var M4 = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "span",
    "svg",
    "ul",
  ],
  nt = M4.reduce((t, e) => {
    const n = b.forwardRef((r, o) => {
      const { asChild: i, ...l } = r,
        u = i ? Ho : e;
      return (
        typeof window < "u" && (window[Symbol.for("radix-ui")] = !0),
        O.jsx(u, { ...l, ref: o })
      );
    });
    return (n.displayName = `Primitive.${e}`), { ...t, [e]: n };
  }, {});
function SC(t, e) {
  t && Ba.flushSync(() => t.dispatchEvent(e));
}
function CC(t) {
  const e = t + "CollectionProvider",
    [n, r] = Ui(e),
    [o, i] = n(e, { collectionRef: { current: null }, itemMap: new Map() }),
    l = (v) => {
      const { scope: x, children: S } = v,
        C = Le.useRef(null),
        E = Le.useRef(new Map()).current;
      return O.jsx(o, { scope: x, itemMap: E, collectionRef: C, children: S });
    };
  l.displayName = e;
  const u = t + "CollectionSlot",
    c = Le.forwardRef((v, x) => {
      const { scope: S, children: C } = v,
        E = i(u, S),
        N = ft(x, E.collectionRef);
      return O.jsx(Ho, { ref: N, children: C });
    });
  c.displayName = u;
  const f = t + "CollectionItemSlot",
    p = "data-radix-collection-item",
    m = Le.forwardRef((v, x) => {
      const { scope: S, children: C, ...E } = v,
        N = Le.useRef(null),
        $ = ft(x, N),
        M = i(f, S);
      return (
        Le.useEffect(
          () => (
            M.itemMap.set(N, { ref: N, ...E }), () => void M.itemMap.delete(N)
          )
        ),
        O.jsx(Ho, { [p]: "", ref: $, children: C })
      );
    });
  m.displayName = f;
  function y(v) {
    const x = i(t + "CollectionConsumer", v);
    return Le.useCallback(() => {
      const C = x.collectionRef.current;
      if (!C) return [];
      const E = Array.from(C.querySelectorAll(`[${p}]`));
      return Array.from(x.itemMap.values()).sort(
        (M, I) => E.indexOf(M.ref.current) - E.indexOf(I.ref.current)
      );
    }, [x.collectionRef, x.itemMap]);
  }
  return [{ Provider: l, Slot: c, ItemSlot: m }, y, r];
}
var O4 = b.createContext(void 0);
function kC(t) {
  const e = b.useContext(O4);
  return t || e || "ltr";
}
function T4(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = Jn(t);
  b.useEffect(() => {
    const r = (o) => {
      o.key === "Escape" && n(o);
    };
    return (
      e.addEventListener("keydown", r, { capture: !0 }),
      () => e.removeEventListener("keydown", r, { capture: !0 })
    );
  }, [n, e]);
}
var N4 = "DismissableLayer",
  jm = "dismissableLayer.update",
  A4 = "dismissableLayer.pointerDownOutside",
  R4 = "dismissableLayer.focusOutside",
  fx,
  EC = b.createContext({
    layers: new Set(),
    layersWithOutsidePointerEventsDisabled: new Set(),
    branches: new Set(),
  }),
  tf = b.forwardRef((t, e) => {
    const {
        disableOutsidePointerEvents: n = !1,
        onEscapeKeyDown: r,
        onPointerDownOutside: o,
        onFocusOutside: i,
        onInteractOutside: l,
        onDismiss: u,
        ...c
      } = t,
      f = b.useContext(EC),
      [p, m] = b.useState(null),
      y =
        (p == null ? void 0 : p.ownerDocument) ??
        (globalThis == null ? void 0 : globalThis.document),
      [, v] = b.useState({}),
      x = ft(e, (F) => m(F)),
      S = Array.from(f.layers),
      [C] = [...f.layersWithOutsidePointerEventsDisabled].slice(-1),
      E = S.indexOf(C),
      N = p ? S.indexOf(p) : -1,
      $ = f.layersWithOutsidePointerEventsDisabled.size > 0,
      M = N >= E,
      I = I4((F) => {
        const H = F.target,
          U = [...f.branches].some((re) => re.contains(H));
        !M ||
          U ||
          (o == null || o(F),
          l == null || l(F),
          F.defaultPrevented || u == null || u());
      }, y),
      R = L4((F) => {
        const H = F.target;
        [...f.branches].some((re) => re.contains(H)) ||
          (i == null || i(F),
          l == null || l(F),
          F.defaultPrevented || u == null || u());
      }, y);
    return (
      T4((F) => {
        N === f.layers.size - 1 &&
          (r == null || r(F),
          !F.defaultPrevented && u && (F.preventDefault(), u()));
      }, y),
      b.useEffect(() => {
        if (p)
          return (
            n &&
              (f.layersWithOutsidePointerEventsDisabled.size === 0 &&
                ((fx = y.body.style.pointerEvents),
                (y.body.style.pointerEvents = "none")),
              f.layersWithOutsidePointerEventsDisabled.add(p)),
            f.layers.add(p),
            px(),
            () => {
              n &&
                f.layersWithOutsidePointerEventsDisabled.size === 1 &&
                (y.body.style.pointerEvents = fx);
            }
          );
      }, [p, y, n, f]),
      b.useEffect(
        () => () => {
          p &&
            (f.layers.delete(p),
            f.layersWithOutsidePointerEventsDisabled.delete(p),
            px());
        },
        [p, f]
      ),
      b.useEffect(() => {
        const F = () => v({});
        return (
          document.addEventListener(jm, F),
          () => document.removeEventListener(jm, F)
        );
      }, []),
      O.jsx(nt.div, {
        ...c,
        ref: x,
        style: {
          pointerEvents: $ ? (M ? "auto" : "none") : void 0,
          ...t.style,
        },
        onFocusCapture: Oe(t.onFocusCapture, R.onFocusCapture),
        onBlurCapture: Oe(t.onBlurCapture, R.onBlurCapture),
        onPointerDownCapture: Oe(
          t.onPointerDownCapture,
          I.onPointerDownCapture
        ),
      })
    );
  });
tf.displayName = N4;
var P4 = "DismissableLayerBranch",
  D4 = b.forwardRef((t, e) => {
    const n = b.useContext(EC),
      r = b.useRef(null),
      o = ft(e, r);
    return (
      b.useEffect(() => {
        const i = r.current;
        if (i)
          return (
            n.branches.add(i),
            () => {
              n.branches.delete(i);
            }
          );
      }, [n.branches]),
      O.jsx(nt.div, { ...t, ref: o })
    );
  });
D4.displayName = P4;
function I4(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = Jn(t),
    r = b.useRef(!1),
    o = b.useRef(() => {});
  return (
    b.useEffect(() => {
      const i = (u) => {
          if (u.target && !r.current) {
            let c = function () {
              MC(A4, n, f, { discrete: !0 });
            };
            const f = { originalEvent: u };
            u.pointerType === "touch"
              ? (e.removeEventListener("click", o.current),
                (o.current = c),
                e.addEventListener("click", o.current, { once: !0 }))
              : c();
          } else e.removeEventListener("click", o.current);
          r.current = !1;
        },
        l = window.setTimeout(() => {
          e.addEventListener("pointerdown", i);
        }, 0);
      return () => {
        window.clearTimeout(l),
          e.removeEventListener("pointerdown", i),
          e.removeEventListener("click", o.current);
      };
    }, [e, n]),
    { onPointerDownCapture: () => (r.current = !0) }
  );
}
function L4(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = Jn(t),
    r = b.useRef(!1);
  return (
    b.useEffect(() => {
      const o = (i) => {
        i.target &&
          !r.current &&
          MC(R4, n, { originalEvent: i }, { discrete: !1 });
      };
      return (
        e.addEventListener("focusin", o),
        () => e.removeEventListener("focusin", o)
      );
    }, [e, n]),
    {
      onFocusCapture: () => (r.current = !0),
      onBlurCapture: () => (r.current = !1),
    }
  );
}
function px() {
  const t = new CustomEvent(jm);
  document.dispatchEvent(t);
}
function MC(t, e, n, { discrete: r }) {
  const o = n.originalEvent.target,
    i = new CustomEvent(t, { bubbles: !1, cancelable: !0, detail: n });
  e && o.addEventListener(t, e, { once: !0 }),
    r ? SC(o, i) : o.dispatchEvent(i);
}
var jh = 0;
function Qg() {
  b.useEffect(() => {
    const t = document.querySelectorAll("[data-radix-focus-guard]");
    return (
      document.body.insertAdjacentElement("afterbegin", t[0] ?? hx()),
      document.body.insertAdjacentElement("beforeend", t[1] ?? hx()),
      jh++,
      () => {
        jh === 1 &&
          document
            .querySelectorAll("[data-radix-focus-guard]")
            .forEach((e) => e.remove()),
          jh--;
      }
    );
  }, []);
}
function hx() {
  const t = document.createElement("span");
  return (
    t.setAttribute("data-radix-focus-guard", ""),
    (t.tabIndex = 0),
    (t.style.outline = "none"),
    (t.style.opacity = "0"),
    (t.style.position = "fixed"),
    (t.style.pointerEvents = "none"),
    t
  );
}
var Bh = "focusScope.autoFocusOnMount",
  Hh = "focusScope.autoFocusOnUnmount",
  mx = { bubbles: !1, cancelable: !0 },
  $4 = "FocusScope",
  nf = b.forwardRef((t, e) => {
    const {
        loop: n = !1,
        trapped: r = !1,
        onMountAutoFocus: o,
        onUnmountAutoFocus: i,
        ...l
      } = t,
      [u, c] = b.useState(null),
      f = Jn(o),
      p = Jn(i),
      m = b.useRef(null),
      y = ft(e, (S) => c(S)),
      v = b.useRef({
        paused: !1,
        pause() {
          this.paused = !0;
        },
        resume() {
          this.paused = !1;
        },
      }).current;
    b.useEffect(() => {
      if (r) {
        let S = function ($) {
            if (v.paused || !u) return;
            const M = $.target;
            u.contains(M) ? (m.current = M) : Co(m.current, { select: !0 });
          },
          C = function ($) {
            if (v.paused || !u) return;
            const M = $.relatedTarget;
            M !== null && (u.contains(M) || Co(m.current, { select: !0 }));
          },
          E = function ($) {
            if (document.activeElement === document.body)
              for (const I of $) I.removedNodes.length > 0 && Co(u);
          };
        document.addEventListener("focusin", S),
          document.addEventListener("focusout", C);
        const N = new MutationObserver(E);
        return (
          u && N.observe(u, { childList: !0, subtree: !0 }),
          () => {
            document.removeEventListener("focusin", S),
              document.removeEventListener("focusout", C),
              N.disconnect();
          }
        );
      }
    }, [r, u, v.paused]),
      b.useEffect(() => {
        if (u) {
          yx.add(v);
          const S = document.activeElement;
          if (!u.contains(S)) {
            const E = new CustomEvent(Bh, mx);
            u.addEventListener(Bh, f),
              u.dispatchEvent(E),
              E.defaultPrevented ||
                (_4(H4(OC(u)), { select: !0 }),
                document.activeElement === S && Co(u));
          }
          return () => {
            u.removeEventListener(Bh, f),
              setTimeout(() => {
                const E = new CustomEvent(Hh, mx);
                u.addEventListener(Hh, p),
                  u.dispatchEvent(E),
                  E.defaultPrevented || Co(S ?? document.body, { select: !0 }),
                  u.removeEventListener(Hh, p),
                  yx.remove(v);
              }, 0);
          };
        }
      }, [u, f, p, v]);
    const x = b.useCallback(
      (S) => {
        if ((!n && !r) || v.paused) return;
        const C = S.key === "Tab" && !S.altKey && !S.ctrlKey && !S.metaKey,
          E = document.activeElement;
        if (C && E) {
          const N = S.currentTarget,
            [$, M] = F4(N);
          $ && M
            ? !S.shiftKey && E === M
              ? (S.preventDefault(), n && Co($, { select: !0 }))
              : S.shiftKey &&
                E === $ &&
                (S.preventDefault(), n && Co(M, { select: !0 }))
            : E === N && S.preventDefault();
        }
      },
      [n, r, v.paused]
    );
    return O.jsx(nt.div, { tabIndex: -1, ...l, ref: y, onKeyDown: x });
  });
nf.displayName = $4;
function _4(t, { select: e = !1 } = {}) {
  const n = document.activeElement;
  for (const r of t)
    if ((Co(r, { select: e }), document.activeElement !== n)) return;
}
function F4(t) {
  const e = OC(t),
    n = gx(e, t),
    r = gx(e.reverse(), t);
  return [n, r];
}
function OC(t) {
  const e = [],
    n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (r) => {
        const o = r.tagName === "INPUT" && r.type === "hidden";
        return r.disabled || r.hidden || o
          ? NodeFilter.FILTER_SKIP
          : r.tabIndex >= 0
          ? NodeFilter.FILTER_ACCEPT
          : NodeFilter.FILTER_SKIP;
      },
    });
  for (; n.nextNode(); ) e.push(n.currentNode);
  return e;
}
function gx(t, e) {
  for (const n of t) if (!z4(n, { upTo: e })) return n;
}
function z4(t, { upTo: e }) {
  if (getComputedStyle(t).visibility === "hidden") return !0;
  for (; t; ) {
    if (e !== void 0 && t === e) return !1;
    if (getComputedStyle(t).display === "none") return !0;
    t = t.parentElement;
  }
  return !1;
}
function j4(t) {
  return t instanceof HTMLInputElement && "select" in t;
}
function Co(t, { select: e = !1 } = {}) {
  if (t && t.focus) {
    const n = document.activeElement;
    t.focus({ preventScroll: !0 }), t !== n && j4(t) && e && t.select();
  }
}
var yx = B4();
function B4() {
  let t = [];
  return {
    add(e) {
      const n = t[0];
      e !== n && (n == null || n.pause()), (t = vx(t, e)), t.unshift(e);
    },
    remove(e) {
      var n;
      (t = vx(t, e)), (n = t[0]) == null || n.resume();
    },
  };
}
function vx(t, e) {
  const n = [...t],
    r = n.indexOf(e);
  return r !== -1 && n.splice(r, 1), n;
}
function H4(t) {
  return t.filter((e) => e.tagName !== "A");
}
var zi =
    globalThis != null && globalThis.document ? b.useLayoutEffect : () => {},
  V4 = Yx.useId || (() => {}),
  W4 = 0;
function Td(t) {
  const [e, n] = b.useState(V4());
  return (
    zi(() => {
      n((r) => r ?? String(W4++));
    }, [t]),
    e ? `radix-${e}` : ""
  );
}
const U4 = ["top", "right", "bottom", "left"],
  Vo = Math.min,
  hn = Math.max,
  Nd = Math.round,
  vc = Math.floor,
  mr = (t) => ({ x: t, y: t }),
  K4 = { left: "right", right: "left", bottom: "top", top: "bottom" },
  q4 = { start: "end", end: "start" };
function Bm(t, e, n) {
  return hn(t, Vo(e, n));
}
function qr(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function Gr(t) {
  return t.split("-")[0];
}
function ol(t) {
  return t.split("-")[1];
}
function Yg(t) {
  return t === "x" ? "y" : "x";
}
function Xg(t) {
  return t === "y" ? "height" : "width";
}
function Wo(t) {
  return ["top", "bottom"].includes(Gr(t)) ? "y" : "x";
}
function Zg(t) {
  return Yg(Wo(t));
}
function G4(t, e, n) {
  n === void 0 && (n = !1);
  const r = ol(t),
    o = Zg(t),
    i = Xg(o);
  let l =
    o === "x"
      ? r === (n ? "end" : "start")
        ? "right"
        : "left"
      : r === "start"
      ? "bottom"
      : "top";
  return e.reference[i] > e.floating[i] && (l = Ad(l)), [l, Ad(l)];
}
function J4(t) {
  const e = Ad(t);
  return [Hm(t), e, Hm(e)];
}
function Hm(t) {
  return t.replace(/start|end/g, (e) => q4[e]);
}
function Q4(t, e, n) {
  const r = ["left", "right"],
    o = ["right", "left"],
    i = ["top", "bottom"],
    l = ["bottom", "top"];
  switch (t) {
    case "top":
    case "bottom":
      return n ? (e ? o : r) : e ? r : o;
    case "left":
    case "right":
      return e ? i : l;
    default:
      return [];
  }
}
function Y4(t, e, n, r) {
  const o = ol(t);
  let i = Q4(Gr(t), n === "start", r);
  return (
    o && ((i = i.map((l) => l + "-" + o)), e && (i = i.concat(i.map(Hm)))), i
  );
}
function Ad(t) {
  return t.replace(/left|right|bottom|top/g, (e) => K4[e]);
}
function X4(t) {
  return { top: 0, right: 0, bottom: 0, left: 0, ...t };
}
function TC(t) {
  return typeof t != "number"
    ? X4(t)
    : { top: t, right: t, bottom: t, left: t };
}
function Rd(t) {
  const { x: e, y: n, width: r, height: o } = t;
  return {
    width: r,
    height: o,
    top: n,
    left: e,
    right: e + r,
    bottom: n + o,
    x: e,
    y: n,
  };
}
function wx(t, e, n) {
  let { reference: r, floating: o } = t;
  const i = Wo(e),
    l = Zg(e),
    u = Xg(l),
    c = Gr(e),
    f = i === "y",
    p = r.x + r.width / 2 - o.width / 2,
    m = r.y + r.height / 2 - o.height / 2,
    y = r[u] / 2 - o[u] / 2;
  let v;
  switch (c) {
    case "top":
      v = { x: p, y: r.y - o.height };
      break;
    case "bottom":
      v = { x: p, y: r.y + r.height };
      break;
    case "right":
      v = { x: r.x + r.width, y: m };
      break;
    case "left":
      v = { x: r.x - o.width, y: m };
      break;
    default:
      v = { x: r.x, y: r.y };
  }
  switch (ol(e)) {
    case "start":
      v[l] -= y * (n && f ? -1 : 1);
      break;
    case "end":
      v[l] += y * (n && f ? -1 : 1);
      break;
  }
  return v;
}
const Z4 = async (t, e, n) => {
  const {
      placement: r = "bottom",
      strategy: o = "absolute",
      middleware: i = [],
      platform: l,
    } = n,
    u = i.filter(Boolean),
    c = await (l.isRTL == null ? void 0 : l.isRTL(e));
  let f = await l.getElementRects({ reference: t, floating: e, strategy: o }),
    { x: p, y: m } = wx(f, r, c),
    y = r,
    v = {},
    x = 0;
  for (let S = 0; S < u.length; S++) {
    const { name: C, fn: E } = u[S],
      {
        x: N,
        y: $,
        data: M,
        reset: I,
      } = await E({
        x: p,
        y: m,
        initialPlacement: r,
        placement: y,
        strategy: o,
        middlewareData: v,
        rects: f,
        platform: l,
        elements: { reference: t, floating: e },
      });
    (p = N ?? p),
      (m = $ ?? m),
      (v = { ...v, [C]: { ...v[C], ...M } }),
      I &&
        x <= 50 &&
        (x++,
        typeof I == "object" &&
          (I.placement && (y = I.placement),
          I.rects &&
            (f =
              I.rects === !0
                ? await l.getElementRects({
                    reference: t,
                    floating: e,
                    strategy: o,
                  })
                : I.rects),
          ({ x: p, y: m } = wx(f, y, c))),
        (S = -1));
  }
  return { x: p, y: m, placement: y, strategy: o, middlewareData: v };
};
async function Na(t, e) {
  var n;
  e === void 0 && (e = {});
  const { x: r, y: o, platform: i, rects: l, elements: u, strategy: c } = t,
    {
      boundary: f = "clippingAncestors",
      rootBoundary: p = "viewport",
      elementContext: m = "floating",
      altBoundary: y = !1,
      padding: v = 0,
    } = qr(e, t),
    x = TC(v),
    C = u[y ? (m === "floating" ? "reference" : "floating") : m],
    E = Rd(
      await i.getClippingRect({
        element:
          (n = await (i.isElement == null ? void 0 : i.isElement(C))) == null ||
          n
            ? C
            : C.contextElement ||
              (await (i.getDocumentElement == null
                ? void 0
                : i.getDocumentElement(u.floating))),
        boundary: f,
        rootBoundary: p,
        strategy: c,
      })
    ),
    N =
      m === "floating"
        ? { x: r, y: o, width: l.floating.width, height: l.floating.height }
        : l.reference,
    $ = await (i.getOffsetParent == null
      ? void 0
      : i.getOffsetParent(u.floating)),
    M = (await (i.isElement == null ? void 0 : i.isElement($)))
      ? (await (i.getScale == null ? void 0 : i.getScale($))) || { x: 1, y: 1 }
      : { x: 1, y: 1 },
    I = Rd(
      i.convertOffsetParentRelativeRectToViewportRelativeRect
        ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
            elements: u,
            rect: N,
            offsetParent: $,
            strategy: c,
          })
        : N
    );
  return {
    top: (E.top - I.top + x.top) / M.y,
    bottom: (I.bottom - E.bottom + x.bottom) / M.y,
    left: (E.left - I.left + x.left) / M.x,
    right: (I.right - E.right + x.right) / M.x,
  };
}
const e$ = (t) => ({
    name: "arrow",
    options: t,
    async fn(e) {
      const {
          x: n,
          y: r,
          placement: o,
          rects: i,
          platform: l,
          elements: u,
          middlewareData: c,
        } = e,
        { element: f, padding: p = 0 } = qr(t, e) || {};
      if (f == null) return {};
      const m = TC(p),
        y = { x: n, y: r },
        v = Zg(o),
        x = Xg(v),
        S = await l.getDimensions(f),
        C = v === "y",
        E = C ? "top" : "left",
        N = C ? "bottom" : "right",
        $ = C ? "clientHeight" : "clientWidth",
        M = i.reference[x] + i.reference[v] - y[v] - i.floating[x],
        I = y[v] - i.reference[v],
        R = await (l.getOffsetParent == null ? void 0 : l.getOffsetParent(f));
      let F = R ? R[$] : 0;
      (!F || !(await (l.isElement == null ? void 0 : l.isElement(R)))) &&
        (F = u.floating[$] || i.floating[x]);
      const H = M / 2 - I / 2,
        U = F / 2 - S[x] / 2 - 1,
        re = Vo(m[E], U),
        ce = Vo(m[N], U),
        ee = re,
        le = F - S[x] - ce,
        de = F / 2 - S[x] / 2 + H,
        xe = Bm(ee, de, le),
        oe =
          !c.arrow &&
          ol(o) != null &&
          de !== xe &&
          i.reference[x] / 2 - (de < ee ? re : ce) - S[x] / 2 < 0,
        se = oe ? (de < ee ? de - ee : de - le) : 0;
      return {
        [v]: y[v] + se,
        data: {
          [v]: xe,
          centerOffset: de - xe - se,
          ...(oe && { alignmentOffset: se }),
        },
        reset: oe,
      };
    },
  }),
  t$ = function (t) {
    return (
      t === void 0 && (t = {}),
      {
        name: "flip",
        options: t,
        async fn(e) {
          var n, r;
          const {
              placement: o,
              middlewareData: i,
              rects: l,
              initialPlacement: u,
              platform: c,
              elements: f,
            } = e,
            {
              mainAxis: p = !0,
              crossAxis: m = !0,
              fallbackPlacements: y,
              fallbackStrategy: v = "bestFit",
              fallbackAxisSideDirection: x = "none",
              flipAlignment: S = !0,
              ...C
            } = qr(t, e);
          if ((n = i.arrow) != null && n.alignmentOffset) return {};
          const E = Gr(o),
            N = Wo(u),
            $ = Gr(u) === u,
            M = await (c.isRTL == null ? void 0 : c.isRTL(f.floating)),
            I = y || ($ || !S ? [Ad(u)] : J4(u)),
            R = x !== "none";
          !y && R && I.push(...Y4(u, S, x, M));
          const F = [u, ...I],
            H = await Na(e, C),
            U = [];
          let re = ((r = i.flip) == null ? void 0 : r.overflows) || [];
          if ((p && U.push(H[E]), m)) {
            const de = G4(o, l, M);
            U.push(H[de[0]], H[de[1]]);
          }
          if (
            ((re = [...re, { placement: o, overflows: U }]),
            !U.every((de) => de <= 0))
          ) {
            var ce, ee;
            const de = (((ce = i.flip) == null ? void 0 : ce.index) || 0) + 1,
              xe = F[de];
            if (xe)
              return {
                data: { index: de, overflows: re },
                reset: { placement: xe },
              };
            let oe =
              (ee = re
                .filter((se) => se.overflows[0] <= 0)
                .sort((se, B) => se.overflows[1] - B.overflows[1])[0]) == null
                ? void 0
                : ee.placement;
            if (!oe)
              switch (v) {
                case "bestFit": {
                  var le;
                  const se =
                    (le = re
                      .filter((B) => {
                        if (R) {
                          const V = Wo(B.placement);
                          return V === N || V === "y";
                        }
                        return !0;
                      })
                      .map((B) => [
                        B.placement,
                        B.overflows
                          .filter((V) => V > 0)
                          .reduce((V, K) => V + K, 0),
                      ])
                      .sort((B, V) => B[1] - V[1])[0]) == null
                      ? void 0
                      : le[0];
                  se && (oe = se);
                  break;
                }
                case "initialPlacement":
                  oe = u;
                  break;
              }
            if (o !== oe) return { reset: { placement: oe } };
          }
          return {};
        },
      }
    );
  };
function xx(t, e) {
  return {
    top: t.top - e.height,
    right: t.right - e.width,
    bottom: t.bottom - e.height,
    left: t.left - e.width,
  };
}
function bx(t) {
  return U4.some((e) => t[e] >= 0);
}
const n$ = function (t) {
  return (
    t === void 0 && (t = {}),
    {
      name: "hide",
      options: t,
      async fn(e) {
        const { rects: n } = e,
          { strategy: r = "referenceHidden", ...o } = qr(t, e);
        switch (r) {
          case "referenceHidden": {
            const i = await Na(e, { ...o, elementContext: "reference" }),
              l = xx(i, n.reference);
            return {
              data: { referenceHiddenOffsets: l, referenceHidden: bx(l) },
            };
          }
          case "escaped": {
            const i = await Na(e, { ...o, altBoundary: !0 }),
              l = xx(i, n.floating);
            return { data: { escapedOffsets: l, escaped: bx(l) } };
          }
          default:
            return {};
        }
      },
    }
  );
};
async function r$(t, e) {
  const { placement: n, platform: r, elements: o } = t,
    i = await (r.isRTL == null ? void 0 : r.isRTL(o.floating)),
    l = Gr(n),
    u = ol(n),
    c = Wo(n) === "y",
    f = ["left", "top"].includes(l) ? -1 : 1,
    p = i && c ? -1 : 1,
    m = qr(e, t);
  let {
    mainAxis: y,
    crossAxis: v,
    alignmentAxis: x,
  } = typeof m == "number"
    ? { mainAxis: m, crossAxis: 0, alignmentAxis: null }
    : {
        mainAxis: m.mainAxis || 0,
        crossAxis: m.crossAxis || 0,
        alignmentAxis: m.alignmentAxis,
      };
  return (
    u && typeof x == "number" && (v = u === "end" ? x * -1 : x),
    c ? { x: v * p, y: y * f } : { x: y * f, y: v * p }
  );
}
const o$ = function (t) {
    return (
      t === void 0 && (t = 0),
      {
        name: "offset",
        options: t,
        async fn(e) {
          var n, r;
          const { x: o, y: i, placement: l, middlewareData: u } = e,
            c = await r$(e, t);
          return l === ((n = u.offset) == null ? void 0 : n.placement) &&
            (r = u.arrow) != null &&
            r.alignmentOffset
            ? {}
            : { x: o + c.x, y: i + c.y, data: { ...c, placement: l } };
        },
      }
    );
  },
  i$ = function (t) {
    return (
      t === void 0 && (t = {}),
      {
        name: "shift",
        options: t,
        async fn(e) {
          const { x: n, y: r, placement: o } = e,
            {
              mainAxis: i = !0,
              crossAxis: l = !1,
              limiter: u = {
                fn: (C) => {
                  let { x: E, y: N } = C;
                  return { x: E, y: N };
                },
              },
              ...c
            } = qr(t, e),
            f = { x: n, y: r },
            p = await Na(e, c),
            m = Wo(Gr(o)),
            y = Yg(m);
          let v = f[y],
            x = f[m];
          if (i) {
            const C = y === "y" ? "top" : "left",
              E = y === "y" ? "bottom" : "right",
              N = v + p[C],
              $ = v - p[E];
            v = Bm(N, v, $);
          }
          if (l) {
            const C = m === "y" ? "top" : "left",
              E = m === "y" ? "bottom" : "right",
              N = x + p[C],
              $ = x - p[E];
            x = Bm(N, x, $);
          }
          const S = u.fn({ ...e, [y]: v, [m]: x });
          return {
            ...S,
            data: { x: S.x - n, y: S.y - r, enabled: { [y]: i, [m]: l } },
          };
        },
      }
    );
  },
  s$ = function (t) {
    return (
      t === void 0 && (t = {}),
      {
        options: t,
        fn(e) {
          const { x: n, y: r, placement: o, rects: i, middlewareData: l } = e,
            { offset: u = 0, mainAxis: c = !0, crossAxis: f = !0 } = qr(t, e),
            p = { x: n, y: r },
            m = Wo(o),
            y = Yg(m);
          let v = p[y],
            x = p[m];
          const S = qr(u, e),
            C =
              typeof S == "number"
                ? { mainAxis: S, crossAxis: 0 }
                : { mainAxis: 0, crossAxis: 0, ...S };
          if (c) {
            const $ = y === "y" ? "height" : "width",
              M = i.reference[y] - i.floating[$] + C.mainAxis,
              I = i.reference[y] + i.reference[$] - C.mainAxis;
            v < M ? (v = M) : v > I && (v = I);
          }
          if (f) {
            var E, N;
            const $ = y === "y" ? "width" : "height",
              M = ["top", "left"].includes(Gr(o)),
              I =
                i.reference[m] -
                i.floating[$] +
                ((M && ((E = l.offset) == null ? void 0 : E[m])) || 0) +
                (M ? 0 : C.crossAxis),
              R =
                i.reference[m] +
                i.reference[$] +
                (M ? 0 : ((N = l.offset) == null ? void 0 : N[m]) || 0) -
                (M ? C.crossAxis : 0);
            x < I ? (x = I) : x > R && (x = R);
          }
          return { [y]: v, [m]: x };
        },
      }
    );
  },
  l$ = function (t) {
    return (
      t === void 0 && (t = {}),
      {
        name: "size",
        options: t,
        async fn(e) {
          var n, r;
          const { placement: o, rects: i, platform: l, elements: u } = e,
            { apply: c = () => {}, ...f } = qr(t, e),
            p = await Na(e, f),
            m = Gr(o),
            y = ol(o),
            v = Wo(o) === "y",
            { width: x, height: S } = i.floating;
          let C, E;
          m === "top" || m === "bottom"
            ? ((C = m),
              (E =
                y ===
                ((await (l.isRTL == null ? void 0 : l.isRTL(u.floating)))
                  ? "start"
                  : "end")
                  ? "left"
                  : "right"))
            : ((E = m), (C = y === "end" ? "top" : "bottom"));
          const N = S - p.top - p.bottom,
            $ = x - p.left - p.right,
            M = Vo(S - p[C], N),
            I = Vo(x - p[E], $),
            R = !e.middlewareData.shift;
          let F = M,
            H = I;
          if (
            ((n = e.middlewareData.shift) != null && n.enabled.x && (H = $),
            (r = e.middlewareData.shift) != null && r.enabled.y && (F = N),
            R && !y)
          ) {
            const re = hn(p.left, 0),
              ce = hn(p.right, 0),
              ee = hn(p.top, 0),
              le = hn(p.bottom, 0);
            v
              ? (H =
                  x -
                  2 * (re !== 0 || ce !== 0 ? re + ce : hn(p.left, p.right)))
              : (F =
                  S -
                  2 * (ee !== 0 || le !== 0 ? ee + le : hn(p.top, p.bottom)));
          }
          await c({ ...e, availableWidth: H, availableHeight: F });
          const U = await l.getDimensions(u.floating);
          return x !== U.width || S !== U.height
            ? { reset: { rects: !0 } }
            : {};
        },
      }
    );
  };
function rf() {
  return typeof window < "u";
}
function il(t) {
  return NC(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function gn(t) {
  var e;
  return (
    (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) ||
    window
  );
}
function xr(t) {
  var e;
  return (e = (NC(t) ? t.ownerDocument : t.document) || window.document) == null
    ? void 0
    : e.documentElement;
}
function NC(t) {
  return rf() ? t instanceof Node || t instanceof gn(t).Node : !1;
}
function Qn(t) {
  return rf() ? t instanceof Element || t instanceof gn(t).Element : !1;
}
function wr(t) {
  return rf() ? t instanceof HTMLElement || t instanceof gn(t).HTMLElement : !1;
}
function Sx(t) {
  return !rf() || typeof ShadowRoot > "u"
    ? !1
    : t instanceof ShadowRoot || t instanceof gn(t).ShadowRoot;
}
function Ha(t) {
  const { overflow: e, overflowX: n, overflowY: r, display: o } = Yn(t);
  return (
    /auto|scroll|overlay|hidden|clip/.test(e + r + n) &&
    !["inline", "contents"].includes(o)
  );
}
function a$(t) {
  return ["table", "td", "th"].includes(il(t));
}
function of(t) {
  return [":popover-open", ":modal"].some((e) => {
    try {
      return t.matches(e);
    } catch {
      return !1;
    }
  });
}
function ey(t) {
  const e = ty(),
    n = Qn(t) ? Yn(t) : t;
  return (
    ["transform", "translate", "scale", "rotate", "perspective"].some((r) =>
      n[r] ? n[r] !== "none" : !1
    ) ||
    (n.containerType ? n.containerType !== "normal" : !1) ||
    (!e && (n.backdropFilter ? n.backdropFilter !== "none" : !1)) ||
    (!e && (n.filter ? n.filter !== "none" : !1)) ||
    ["transform", "translate", "scale", "rotate", "perspective", "filter"].some(
      (r) => (n.willChange || "").includes(r)
    ) ||
    ["paint", "layout", "strict", "content"].some((r) =>
      (n.contain || "").includes(r)
    )
  );
}
function u$(t) {
  let e = Uo(t);
  for (; wr(e) && !Zs(e); ) {
    if (ey(e)) return e;
    if (of(e)) return null;
    e = Uo(e);
  }
  return null;
}
function ty() {
  return typeof CSS > "u" || !CSS.supports
    ? !1
    : CSS.supports("-webkit-backdrop-filter", "none");
}
function Zs(t) {
  return ["html", "body", "#document"].includes(il(t));
}
function Yn(t) {
  return gn(t).getComputedStyle(t);
}
function sf(t) {
  return Qn(t)
    ? { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop }
    : { scrollLeft: t.scrollX, scrollTop: t.scrollY };
}
function Uo(t) {
  if (il(t) === "html") return t;
  const e = t.assignedSlot || t.parentNode || (Sx(t) && t.host) || xr(t);
  return Sx(e) ? e.host : e;
}
function AC(t) {
  const e = Uo(t);
  return Zs(e)
    ? t.ownerDocument
      ? t.ownerDocument.body
      : t.body
    : wr(e) && Ha(e)
    ? e
    : AC(e);
}
function Aa(t, e, n) {
  var r;
  e === void 0 && (e = []), n === void 0 && (n = !0);
  const o = AC(t),
    i = o === ((r = t.ownerDocument) == null ? void 0 : r.body),
    l = gn(o);
  if (i) {
    const u = Vm(l);
    return e.concat(
      l,
      l.visualViewport || [],
      Ha(o) ? o : [],
      u && n ? Aa(u) : []
    );
  }
  return e.concat(o, Aa(o, [], n));
}
function Vm(t) {
  return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null;
}
function RC(t) {
  const e = Yn(t);
  let n = parseFloat(e.width) || 0,
    r = parseFloat(e.height) || 0;
  const o = wr(t),
    i = o ? t.offsetWidth : n,
    l = o ? t.offsetHeight : r,
    u = Nd(n) !== i || Nd(r) !== l;
  return u && ((n = i), (r = l)), { width: n, height: r, $: u };
}
function ny(t) {
  return Qn(t) ? t : t.contextElement;
}
function zs(t) {
  const e = ny(t);
  if (!wr(e)) return mr(1);
  const n = e.getBoundingClientRect(),
    { width: r, height: o, $: i } = RC(e);
  let l = (i ? Nd(n.width) : n.width) / r,
    u = (i ? Nd(n.height) : n.height) / o;
  return (
    (!l || !Number.isFinite(l)) && (l = 1),
    (!u || !Number.isFinite(u)) && (u = 1),
    { x: l, y: u }
  );
}
const c$ = mr(0);
function PC(t) {
  const e = gn(t);
  return !ty() || !e.visualViewport
    ? c$
    : { x: e.visualViewport.offsetLeft, y: e.visualViewport.offsetTop };
}
function d$(t, e, n) {
  return e === void 0 && (e = !1), !n || (e && n !== gn(t)) ? !1 : e;
}
function ji(t, e, n, r) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  const o = t.getBoundingClientRect(),
    i = ny(t);
  let l = mr(1);
  e && (r ? Qn(r) && (l = zs(r)) : (l = zs(t)));
  const u = d$(i, n, r) ? PC(i) : mr(0);
  let c = (o.left + u.x) / l.x,
    f = (o.top + u.y) / l.y,
    p = o.width / l.x,
    m = o.height / l.y;
  if (i) {
    const y = gn(i),
      v = r && Qn(r) ? gn(r) : r;
    let x = y,
      S = Vm(x);
    for (; S && r && v !== x; ) {
      const C = zs(S),
        E = S.getBoundingClientRect(),
        N = Yn(S),
        $ = E.left + (S.clientLeft + parseFloat(N.paddingLeft)) * C.x,
        M = E.top + (S.clientTop + parseFloat(N.paddingTop)) * C.y;
      (c *= C.x),
        (f *= C.y),
        (p *= C.x),
        (m *= C.y),
        (c += $),
        (f += M),
        (x = gn(S)),
        (S = Vm(x));
    }
  }
  return Rd({ width: p, height: m, x: c, y: f });
}
function ry(t, e) {
  const n = sf(t).scrollLeft;
  return e ? e.left + n : ji(xr(t)).left + n;
}
function DC(t, e, n) {
  n === void 0 && (n = !1);
  const r = t.getBoundingClientRect(),
    o = r.left + e.scrollLeft - (n ? 0 : ry(t, r)),
    i = r.top + e.scrollTop;
  return { x: o, y: i };
}
function f$(t) {
  let { elements: e, rect: n, offsetParent: r, strategy: o } = t;
  const i = o === "fixed",
    l = xr(r),
    u = e ? of(e.floating) : !1;
  if (r === l || (u && i)) return n;
  let c = { scrollLeft: 0, scrollTop: 0 },
    f = mr(1);
  const p = mr(0),
    m = wr(r);
  if (
    (m || (!m && !i)) &&
    ((il(r) !== "body" || Ha(l)) && (c = sf(r)), wr(r))
  ) {
    const v = ji(r);
    (f = zs(r)), (p.x = v.x + r.clientLeft), (p.y = v.y + r.clientTop);
  }
  const y = l && !m && !i ? DC(l, c, !0) : mr(0);
  return {
    width: n.width * f.x,
    height: n.height * f.y,
    x: n.x * f.x - c.scrollLeft * f.x + p.x + y.x,
    y: n.y * f.y - c.scrollTop * f.y + p.y + y.y,
  };
}
function p$(t) {
  return Array.from(t.getClientRects());
}
function h$(t) {
  const e = xr(t),
    n = sf(t),
    r = t.ownerDocument.body,
    o = hn(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth),
    i = hn(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
  let l = -n.scrollLeft + ry(t);
  const u = -n.scrollTop;
  return (
    Yn(r).direction === "rtl" && (l += hn(e.clientWidth, r.clientWidth) - o),
    { width: o, height: i, x: l, y: u }
  );
}
function m$(t, e) {
  const n = gn(t),
    r = xr(t),
    o = n.visualViewport;
  let i = r.clientWidth,
    l = r.clientHeight,
    u = 0,
    c = 0;
  if (o) {
    (i = o.width), (l = o.height);
    const f = ty();
    (!f || (f && e === "fixed")) && ((u = o.offsetLeft), (c = o.offsetTop));
  }
  return { width: i, height: l, x: u, y: c };
}
function g$(t, e) {
  const n = ji(t, !0, e === "fixed"),
    r = n.top + t.clientTop,
    o = n.left + t.clientLeft,
    i = wr(t) ? zs(t) : mr(1),
    l = t.clientWidth * i.x,
    u = t.clientHeight * i.y,
    c = o * i.x,
    f = r * i.y;
  return { width: l, height: u, x: c, y: f };
}
function Cx(t, e, n) {
  let r;
  if (e === "viewport") r = m$(t, n);
  else if (e === "document") r = h$(xr(t));
  else if (Qn(e)) r = g$(e, n);
  else {
    const o = PC(t);
    r = { x: e.x - o.x, y: e.y - o.y, width: e.width, height: e.height };
  }
  return Rd(r);
}
function IC(t, e) {
  const n = Uo(t);
  return n === e || !Qn(n) || Zs(n)
    ? !1
    : Yn(n).position === "fixed" || IC(n, e);
}
function y$(t, e) {
  const n = e.get(t);
  if (n) return n;
  let r = Aa(t, [], !1).filter((u) => Qn(u) && il(u) !== "body"),
    o = null;
  const i = Yn(t).position === "fixed";
  let l = i ? Uo(t) : t;
  for (; Qn(l) && !Zs(l); ) {
    const u = Yn(l),
      c = ey(l);
    !c && u.position === "fixed" && (o = null),
      (
        i
          ? !c && !o
          : (!c &&
              u.position === "static" &&
              !!o &&
              ["absolute", "fixed"].includes(o.position)) ||
            (Ha(l) && !c && IC(t, l))
      )
        ? (r = r.filter((p) => p !== l))
        : (o = u),
      (l = Uo(l));
  }
  return e.set(t, r), r;
}
function v$(t) {
  let { element: e, boundary: n, rootBoundary: r, strategy: o } = t;
  const l = [
      ...(n === "clippingAncestors"
        ? of(e)
          ? []
          : y$(e, this._c)
        : [].concat(n)),
      r,
    ],
    u = l[0],
    c = l.reduce((f, p) => {
      const m = Cx(e, p, o);
      return (
        (f.top = hn(m.top, f.top)),
        (f.right = Vo(m.right, f.right)),
        (f.bottom = Vo(m.bottom, f.bottom)),
        (f.left = hn(m.left, f.left)),
        f
      );
    }, Cx(e, u, o));
  return {
    width: c.right - c.left,
    height: c.bottom - c.top,
    x: c.left,
    y: c.top,
  };
}
function w$(t) {
  const { width: e, height: n } = RC(t);
  return { width: e, height: n };
}
function x$(t, e, n) {
  const r = wr(e),
    o = xr(e),
    i = n === "fixed",
    l = ji(t, !0, i, e);
  let u = { scrollLeft: 0, scrollTop: 0 };
  const c = mr(0);
  if (r || (!r && !i))
    if (((il(e) !== "body" || Ha(o)) && (u = sf(e)), r)) {
      const y = ji(e, !0, i, e);
      (c.x = y.x + e.clientLeft), (c.y = y.y + e.clientTop);
    } else o && (c.x = ry(o));
  const f = o && !r && !i ? DC(o, u) : mr(0),
    p = l.left + u.scrollLeft - c.x - f.x,
    m = l.top + u.scrollTop - c.y - f.y;
  return { x: p, y: m, width: l.width, height: l.height };
}
function Vh(t) {
  return Yn(t).position === "static";
}
function kx(t, e) {
  if (!wr(t) || Yn(t).position === "fixed") return null;
  if (e) return e(t);
  let n = t.offsetParent;
  return xr(t) === n && (n = n.ownerDocument.body), n;
}
function LC(t, e) {
  const n = gn(t);
  if (of(t)) return n;
  if (!wr(t)) {
    let o = Uo(t);
    for (; o && !Zs(o); ) {
      if (Qn(o) && !Vh(o)) return o;
      o = Uo(o);
    }
    return n;
  }
  let r = kx(t, e);
  for (; r && a$(r) && Vh(r); ) r = kx(r, e);
  return r && Zs(r) && Vh(r) && !ey(r) ? n : r || u$(t) || n;
}
const b$ = async function (t) {
  const e = this.getOffsetParent || LC,
    n = this.getDimensions,
    r = await n(t.floating);
  return {
    reference: x$(t.reference, await e(t.floating), t.strategy),
    floating: { x: 0, y: 0, width: r.width, height: r.height },
  };
};
function S$(t) {
  return Yn(t).direction === "rtl";
}
const C$ = {
  convertOffsetParentRelativeRectToViewportRelativeRect: f$,
  getDocumentElement: xr,
  getClippingRect: v$,
  getOffsetParent: LC,
  getElementRects: b$,
  getClientRects: p$,
  getDimensions: w$,
  getScale: zs,
  isElement: Qn,
  isRTL: S$,
};
function $C(t, e) {
  return (
    t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height
  );
}
function k$(t, e) {
  let n = null,
    r;
  const o = xr(t);
  function i() {
    var u;
    clearTimeout(r), (u = n) == null || u.disconnect(), (n = null);
  }
  function l(u, c) {
    u === void 0 && (u = !1), c === void 0 && (c = 1), i();
    const f = t.getBoundingClientRect(),
      { left: p, top: m, width: y, height: v } = f;
    if ((u || e(), !y || !v)) return;
    const x = vc(m),
      S = vc(o.clientWidth - (p + y)),
      C = vc(o.clientHeight - (m + v)),
      E = vc(p),
      $ = {
        rootMargin: -x + "px " + -S + "px " + -C + "px " + -E + "px",
        threshold: hn(0, Vo(1, c)) || 1,
      };
    let M = !0;
    function I(R) {
      const F = R[0].intersectionRatio;
      if (F !== c) {
        if (!M) return l();
        F
          ? l(!1, F)
          : (r = setTimeout(() => {
              l(!1, 1e-7);
            }, 1e3));
      }
      F === 1 && !$C(f, t.getBoundingClientRect()) && l(), (M = !1);
    }
    try {
      n = new IntersectionObserver(I, { ...$, root: o.ownerDocument });
    } catch {
      n = new IntersectionObserver(I, $);
    }
    n.observe(t);
  }
  return l(!0), i;
}
function E$(t, e, n, r) {
  r === void 0 && (r = {});
  const {
      ancestorScroll: o = !0,
      ancestorResize: i = !0,
      elementResize: l = typeof ResizeObserver == "function",
      layoutShift: u = typeof IntersectionObserver == "function",
      animationFrame: c = !1,
    } = r,
    f = ny(t),
    p = o || i ? [...(f ? Aa(f) : []), ...Aa(e)] : [];
  p.forEach((E) => {
    o && E.addEventListener("scroll", n, { passive: !0 }),
      i && E.addEventListener("resize", n);
  });
  const m = f && u ? k$(f, n) : null;
  let y = -1,
    v = null;
  l &&
    ((v = new ResizeObserver((E) => {
      let [N] = E;
      N &&
        N.target === f &&
        v &&
        (v.unobserve(e),
        cancelAnimationFrame(y),
        (y = requestAnimationFrame(() => {
          var $;
          ($ = v) == null || $.observe(e);
        }))),
        n();
    })),
    f && !c && v.observe(f),
    v.observe(e));
  let x,
    S = c ? ji(t) : null;
  c && C();
  function C() {
    const E = ji(t);
    S && !$C(S, E) && n(), (S = E), (x = requestAnimationFrame(C));
  }
  return (
    n(),
    () => {
      var E;
      p.forEach((N) => {
        o && N.removeEventListener("scroll", n),
          i && N.removeEventListener("resize", n);
      }),
        m == null || m(),
        (E = v) == null || E.disconnect(),
        (v = null),
        c && cancelAnimationFrame(x);
    }
  );
}
const M$ = o$,
  O$ = i$,
  T$ = t$,
  N$ = l$,
  A$ = n$,
  Ex = e$,
  R$ = s$,
  P$ = (t, e, n) => {
    const r = new Map(),
      o = { platform: C$, ...n },
      i = { ...o.platform, _c: r };
    return Z4(t, e, { ...o, platform: i });
  };
var $c = typeof document < "u" ? b.useLayoutEffect : b.useEffect;
function Pd(t, e) {
  if (t === e) return !0;
  if (typeof t != typeof e) return !1;
  if (typeof t == "function" && t.toString() === e.toString()) return !0;
  let n, r, o;
  if (t && e && typeof t == "object") {
    if (Array.isArray(t)) {
      if (((n = t.length), n !== e.length)) return !1;
      for (r = n; r-- !== 0; ) if (!Pd(t[r], e[r])) return !1;
      return !0;
    }
    if (((o = Object.keys(t)), (n = o.length), n !== Object.keys(e).length))
      return !1;
    for (r = n; r-- !== 0; ) if (!{}.hasOwnProperty.call(e, o[r])) return !1;
    for (r = n; r-- !== 0; ) {
      const i = o[r];
      if (!(i === "_owner" && t.$$typeof) && !Pd(t[i], e[i])) return !1;
    }
    return !0;
  }
  return t !== t && e !== e;
}
function _C(t) {
  return typeof window > "u"
    ? 1
    : (t.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function Mx(t, e) {
  const n = _C(t);
  return Math.round(e * n) / n;
}
function Wh(t) {
  const e = b.useRef(t);
  return (
    $c(() => {
      e.current = t;
    }),
    e
  );
}
function D$(t) {
  t === void 0 && (t = {});
  const {
      placement: e = "bottom",
      strategy: n = "absolute",
      middleware: r = [],
      platform: o,
      elements: { reference: i, floating: l } = {},
      transform: u = !0,
      whileElementsMounted: c,
      open: f,
    } = t,
    [p, m] = b.useState({
      x: 0,
      y: 0,
      strategy: n,
      placement: e,
      middlewareData: {},
      isPositioned: !1,
    }),
    [y, v] = b.useState(r);
  Pd(y, r) || v(r);
  const [x, S] = b.useState(null),
    [C, E] = b.useState(null),
    N = b.useCallback((B) => {
      B !== R.current && ((R.current = B), S(B));
    }, []),
    $ = b.useCallback((B) => {
      B !== F.current && ((F.current = B), E(B));
    }, []),
    M = i || x,
    I = l || C,
    R = b.useRef(null),
    F = b.useRef(null),
    H = b.useRef(p),
    U = c != null,
    re = Wh(c),
    ce = Wh(o),
    ee = Wh(f),
    le = b.useCallback(() => {
      if (!R.current || !F.current) return;
      const B = { placement: e, strategy: n, middleware: y };
      ce.current && (B.platform = ce.current),
        P$(R.current, F.current, B).then((V) => {
          const K = { ...V, isPositioned: ee.current !== !1 };
          de.current &&
            !Pd(H.current, K) &&
            ((H.current = K),
            Ba.flushSync(() => {
              m(K);
            }));
        });
    }, [y, e, n, ce, ee]);
  $c(() => {
    f === !1 &&
      H.current.isPositioned &&
      ((H.current.isPositioned = !1), m((B) => ({ ...B, isPositioned: !1 })));
  }, [f]);
  const de = b.useRef(!1);
  $c(
    () => (
      (de.current = !0),
      () => {
        de.current = !1;
      }
    ),
    []
  ),
    $c(() => {
      if ((M && (R.current = M), I && (F.current = I), M && I)) {
        if (re.current) return re.current(M, I, le);
        le();
      }
    }, [M, I, le, re, U]);
  const xe = b.useMemo(
      () => ({ reference: R, floating: F, setReference: N, setFloating: $ }),
      [N, $]
    ),
    oe = b.useMemo(() => ({ reference: M, floating: I }), [M, I]),
    se = b.useMemo(() => {
      const B = { position: n, left: 0, top: 0 };
      if (!oe.floating) return B;
      const V = Mx(oe.floating, p.x),
        K = Mx(oe.floating, p.y);
      return u
        ? {
            ...B,
            transform: "translate(" + V + "px, " + K + "px)",
            ...(_C(oe.floating) >= 1.5 && { willChange: "transform" }),
          }
        : { position: n, left: V, top: K };
    }, [n, u, oe.floating, p.x, p.y]);
  return b.useMemo(
    () => ({ ...p, update: le, refs: xe, elements: oe, floatingStyles: se }),
    [p, le, xe, oe, se]
  );
}
const I$ = (t) => {
    function e(n) {
      return {}.hasOwnProperty.call(n, "current");
    }
    return {
      name: "arrow",
      options: t,
      fn(n) {
        const { element: r, padding: o } = typeof t == "function" ? t(n) : t;
        return r && e(r)
          ? r.current != null
            ? Ex({ element: r.current, padding: o }).fn(n)
            : {}
          : r
          ? Ex({ element: r, padding: o }).fn(n)
          : {};
      },
    };
  },
  L$ = (t, e) => ({ ...M$(t), options: [t, e] }),
  $$ = (t, e) => ({ ...O$(t), options: [t, e] }),
  _$ = (t, e) => ({ ...R$(t), options: [t, e] }),
  F$ = (t, e) => ({ ...T$(t), options: [t, e] }),
  z$ = (t, e) => ({ ...N$(t), options: [t, e] }),
  j$ = (t, e) => ({ ...A$(t), options: [t, e] }),
  B$ = (t, e) => ({ ...I$(t), options: [t, e] });
var H$ = "Arrow",
  FC = b.forwardRef((t, e) => {
    const { children: n, width: r = 10, height: o = 5, ...i } = t;
    return O.jsx(nt.svg, {
      ...i,
      ref: e,
      width: r,
      height: o,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: t.asChild ? n : O.jsx("polygon", { points: "0,0 30,0 15,10" }),
    });
  });
FC.displayName = H$;
var V$ = FC;
function W$(t) {
  const [e, n] = b.useState(void 0);
  return (
    zi(() => {
      if (t) {
        n({ width: t.offsetWidth, height: t.offsetHeight });
        const r = new ResizeObserver((o) => {
          if (!Array.isArray(o) || !o.length) return;
          const i = o[0];
          let l, u;
          if ("borderBoxSize" in i) {
            const c = i.borderBoxSize,
              f = Array.isArray(c) ? c[0] : c;
            (l = f.inlineSize), (u = f.blockSize);
          } else (l = t.offsetWidth), (u = t.offsetHeight);
          n({ width: l, height: u });
        });
        return r.observe(t, { box: "border-box" }), () => r.unobserve(t);
      } else n(void 0);
    }, [t]),
    e
  );
}
var oy = "Popper",
  [zC, lf] = Ui(oy),
  [U$, jC] = zC(oy),
  BC = (t) => {
    const { __scopePopper: e, children: n } = t,
      [r, o] = b.useState(null);
    return O.jsx(U$, { scope: e, anchor: r, onAnchorChange: o, children: n });
  };
BC.displayName = oy;
var HC = "PopperAnchor",
  VC = b.forwardRef((t, e) => {
    const { __scopePopper: n, virtualRef: r, ...o } = t,
      i = jC(HC, n),
      l = b.useRef(null),
      u = ft(e, l);
    return (
      b.useEffect(() => {
        i.onAnchorChange((r == null ? void 0 : r.current) || l.current);
      }),
      r ? null : O.jsx(nt.div, { ...o, ref: u })
    );
  });
VC.displayName = HC;
var iy = "PopperContent",
  [K$, q$] = zC(iy),
  WC = b.forwardRef((t, e) => {
    var he, we, be, $e, Kt, tr;
    const {
        __scopePopper: n,
        side: r = "bottom",
        sideOffset: o = 0,
        align: i = "center",
        alignOffset: l = 0,
        arrowPadding: u = 0,
        avoidCollisions: c = !0,
        collisionBoundary: f = [],
        collisionPadding: p = 0,
        sticky: m = "partial",
        hideWhenDetached: y = !1,
        updatePositionStrategy: v = "optimized",
        onPlaced: x,
        ...S
      } = t,
      C = jC(iy, n),
      [E, N] = b.useState(null),
      $ = ft(e, (Mt) => N(Mt)),
      [M, I] = b.useState(null),
      R = W$(M),
      F = (R == null ? void 0 : R.width) ?? 0,
      H = (R == null ? void 0 : R.height) ?? 0,
      U = r + (i !== "center" ? "-" + i : ""),
      re =
        typeof p == "number"
          ? p
          : { top: 0, right: 0, bottom: 0, left: 0, ...p },
      ce = Array.isArray(f) ? f : [f],
      ee = ce.length > 0,
      le = { padding: re, boundary: ce.filter(J$), altBoundary: ee },
      {
        refs: de,
        floatingStyles: xe,
        placement: oe,
        isPositioned: se,
        middlewareData: B,
      } = D$({
        strategy: "fixed",
        placement: U,
        whileElementsMounted: (...Mt) =>
          E$(...Mt, { animationFrame: v === "always" }),
        elements: { reference: C.anchor },
        middleware: [
          L$({ mainAxis: o + H, alignmentAxis: l }),
          c &&
            $$({
              mainAxis: !0,
              crossAxis: !1,
              limiter: m === "partial" ? _$() : void 0,
              ...le,
            }),
          c && F$({ ...le }),
          z$({
            ...le,
            apply: ({
              elements: Mt,
              rects: $n,
              availableWidth: Sr,
              availableHeight: nr,
            }) => {
              const { width: _n, height: Cr } = $n.reference,
                sn = Mt.floating.style;
              sn.setProperty("--radix-popper-available-width", `${Sr}px`),
                sn.setProperty("--radix-popper-available-height", `${nr}px`),
                sn.setProperty("--radix-popper-anchor-width", `${_n}px`),
                sn.setProperty("--radix-popper-anchor-height", `${Cr}px`);
            },
          }),
          M && B$({ element: M, padding: u }),
          Q$({ arrowWidth: F, arrowHeight: H }),
          y && j$({ strategy: "referenceHidden", ...le }),
        ],
      }),
      [V, K] = qC(oe),
      D = Jn(x);
    zi(() => {
      se && (D == null || D());
    }, [se, D]);
    const A = (he = B.arrow) == null ? void 0 : he.x,
      X = (we = B.arrow) == null ? void 0 : we.y,
      ne = ((be = B.arrow) == null ? void 0 : be.centerOffset) !== 0,
      [Q, ie] = b.useState();
    return (
      zi(() => {
        E && ie(window.getComputedStyle(E).zIndex);
      }, [E]),
      O.jsx("div", {
        ref: de.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...xe,
          transform: se ? xe.transform : "translate(0, -200%)",
          minWidth: "max-content",
          zIndex: Q,
          "--radix-popper-transform-origin": [
            ($e = B.transformOrigin) == null ? void 0 : $e.x,
            (Kt = B.transformOrigin) == null ? void 0 : Kt.y,
          ].join(" "),
          ...(((tr = B.hide) == null ? void 0 : tr.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none",
          }),
        },
        dir: t.dir,
        children: O.jsx(K$, {
          scope: n,
          placedSide: V,
          onArrowChange: I,
          arrowX: A,
          arrowY: X,
          shouldHideArrow: ne,
          children: O.jsx(nt.div, {
            "data-side": V,
            "data-align": K,
            ...S,
            ref: $,
            style: { ...S.style, animation: se ? void 0 : "none" },
          }),
        }),
      })
    );
  });
WC.displayName = iy;
var UC = "PopperArrow",
  G$ = { top: "bottom", right: "left", bottom: "top", left: "right" },
  KC = b.forwardRef(function (e, n) {
    const { __scopePopper: r, ...o } = e,
      i = q$(UC, r),
      l = G$[i.placedSide];
    return O.jsx("span", {
      ref: i.onArrowChange,
      style: {
        position: "absolute",
        left: i.arrowX,
        top: i.arrowY,
        [l]: 0,
        transformOrigin: {
          top: "",
          right: "0 0",
          bottom: "center 0",
          left: "100% 0",
        }[i.placedSide],
        transform: {
          top: "translateY(100%)",
          right: "translateY(50%) rotate(90deg) translateX(-50%)",
          bottom: "rotate(180deg)",
          left: "translateY(50%) rotate(-90deg) translateX(50%)",
        }[i.placedSide],
        visibility: i.shouldHideArrow ? "hidden" : void 0,
      },
      children: O.jsx(V$, {
        ...o,
        ref: n,
        style: { ...o.style, display: "block" },
      }),
    });
  });
KC.displayName = UC;
function J$(t) {
  return t !== null;
}
var Q$ = (t) => ({
  name: "transformOrigin",
  options: t,
  fn(e) {
    var C, E, N;
    const { placement: n, rects: r, middlewareData: o } = e,
      l = ((C = o.arrow) == null ? void 0 : C.centerOffset) !== 0,
      u = l ? 0 : t.arrowWidth,
      c = l ? 0 : t.arrowHeight,
      [f, p] = qC(n),
      m = { start: "0%", center: "50%", end: "100%" }[p],
      y = (((E = o.arrow) == null ? void 0 : E.x) ?? 0) + u / 2,
      v = (((N = o.arrow) == null ? void 0 : N.y) ?? 0) + c / 2;
    let x = "",
      S = "";
    return (
      f === "bottom"
        ? ((x = l ? m : `${y}px`), (S = `${-c}px`))
        : f === "top"
        ? ((x = l ? m : `${y}px`), (S = `${r.floating.height + c}px`))
        : f === "right"
        ? ((x = `${-c}px`), (S = l ? m : `${v}px`))
        : f === "left" &&
          ((x = `${r.floating.width + c}px`), (S = l ? m : `${v}px`)),
      { data: { x, y: S } }
    );
  },
});
function qC(t) {
  const [e, n = "center"] = t.split("-");
  return [e, n];
}
var GC = BC,
  sy = VC,
  JC = WC,
  QC = KC,
  Y$ = "Portal",
  af = b.forwardRef((t, e) => {
    var u;
    const { container: n, ...r } = t,
      [o, i] = b.useState(!1);
    zi(() => i(!0), []);
    const l =
      n ||
      (o &&
        ((u = globalThis == null ? void 0 : globalThis.document) == null
          ? void 0
          : u.body));
    return l ? Ig.createPortal(O.jsx(nt.div, { ...r, ref: e }), l) : null;
  });
af.displayName = Y$;
function X$(t, e) {
  return b.useReducer((n, r) => e[n][r] ?? n, t);
}
var br = (t) => {
  const { present: e, children: n } = t,
    r = Z$(e),
    o =
      typeof n == "function" ? n({ present: r.isPresent }) : b.Children.only(n),
    i = ft(r.ref, e_(o));
  return typeof n == "function" || r.isPresent
    ? b.cloneElement(o, { ref: i })
    : null;
};
br.displayName = "Presence";
function Z$(t) {
  const [e, n] = b.useState(),
    r = b.useRef({}),
    o = b.useRef(t),
    i = b.useRef("none"),
    l = t ? "mounted" : "unmounted",
    [u, c] = X$(l, {
      mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" },
      unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" },
      unmounted: { MOUNT: "mounted" },
    });
  return (
    b.useEffect(() => {
      const f = wc(r.current);
      i.current = u === "mounted" ? f : "none";
    }, [u]),
    zi(() => {
      const f = r.current,
        p = o.current;
      if (p !== t) {
        const y = i.current,
          v = wc(f);
        t
          ? c("MOUNT")
          : v === "none" || (f == null ? void 0 : f.display) === "none"
          ? c("UNMOUNT")
          : c(p && y !== v ? "ANIMATION_OUT" : "UNMOUNT"),
          (o.current = t);
      }
    }, [t, c]),
    zi(() => {
      if (e) {
        let f;
        const p = e.ownerDocument.defaultView ?? window,
          m = (v) => {
            const S = wc(r.current).includes(v.animationName);
            if (v.target === e && S && (c("ANIMATION_END"), !o.current)) {
              const C = e.style.animationFillMode;
              (e.style.animationFillMode = "forwards"),
                (f = p.setTimeout(() => {
                  e.style.animationFillMode === "forwards" &&
                    (e.style.animationFillMode = C);
                }));
            }
          },
          y = (v) => {
            v.target === e && (i.current = wc(r.current));
          };
        return (
          e.addEventListener("animationstart", y),
          e.addEventListener("animationcancel", m),
          e.addEventListener("animationend", m),
          () => {
            p.clearTimeout(f),
              e.removeEventListener("animationstart", y),
              e.removeEventListener("animationcancel", m),
              e.removeEventListener("animationend", m);
          }
        );
      } else c("ANIMATION_END");
    }, [e, c]),
    {
      isPresent: ["mounted", "unmountSuspended"].includes(u),
      ref: b.useCallback((f) => {
        f && (r.current = getComputedStyle(f)), n(f);
      }, []),
    }
  );
}
function wc(t) {
  return (t == null ? void 0 : t.animationName) || "none";
}
function e_(t) {
  var r, o;
  let e =
      (r = Object.getOwnPropertyDescriptor(t.props, "ref")) == null
        ? void 0
        : r.get,
    n = e && "isReactWarning" in e && e.isReactWarning;
  return n
    ? t.ref
    : ((e =
        (o = Object.getOwnPropertyDescriptor(t, "ref")) == null
          ? void 0
          : o.get),
      (n = e && "isReactWarning" in e && e.isReactWarning),
      n ? t.props.ref : t.props.ref || t.ref);
}
var Uh = "rovingFocusGroup.onEntryFocus",
  t_ = { bubbles: !1, cancelable: !0 },
  uf = "RovingFocusGroup",
  [Wm, YC, n_] = CC(uf),
  [r_, XC] = Ui(uf, [n_]),
  [o_, i_] = r_(uf),
  ZC = b.forwardRef((t, e) =>
    O.jsx(Wm.Provider, {
      scope: t.__scopeRovingFocusGroup,
      children: O.jsx(Wm.Slot, {
        scope: t.__scopeRovingFocusGroup,
        children: O.jsx(s_, { ...t, ref: e }),
      }),
    })
  );
ZC.displayName = uf;
var s_ = b.forwardRef((t, e) => {
    const {
        __scopeRovingFocusGroup: n,
        orientation: r,
        loop: o = !1,
        dir: i,
        currentTabStopId: l,
        defaultCurrentTabStopId: u,
        onCurrentTabStopIdChange: c,
        onEntryFocus: f,
        preventScrollOnEntryFocus: p = !1,
        ...m
      } = t,
      y = b.useRef(null),
      v = ft(e, y),
      x = kC(i),
      [S = null, C] = Jg({ prop: l, defaultProp: u, onChange: c }),
      [E, N] = b.useState(!1),
      $ = Jn(f),
      M = YC(n),
      I = b.useRef(!1),
      [R, F] = b.useState(0);
    return (
      b.useEffect(() => {
        const H = y.current;
        if (H)
          return H.addEventListener(Uh, $), () => H.removeEventListener(Uh, $);
      }, [$]),
      O.jsx(o_, {
        scope: n,
        orientation: r,
        dir: x,
        loop: o,
        currentTabStopId: S,
        onItemFocus: b.useCallback((H) => C(H), [C]),
        onItemShiftTab: b.useCallback(() => N(!0), []),
        onFocusableItemAdd: b.useCallback(() => F((H) => H + 1), []),
        onFocusableItemRemove: b.useCallback(() => F((H) => H - 1), []),
        children: O.jsx(nt.div, {
          tabIndex: E || R === 0 ? -1 : 0,
          "data-orientation": r,
          ...m,
          ref: v,
          style: { outline: "none", ...t.style },
          onMouseDown: Oe(t.onMouseDown, () => {
            I.current = !0;
          }),
          onFocus: Oe(t.onFocus, (H) => {
            const U = !I.current;
            if (H.target === H.currentTarget && U && !E) {
              const re = new CustomEvent(Uh, t_);
              if ((H.currentTarget.dispatchEvent(re), !re.defaultPrevented)) {
                const ce = M().filter((oe) => oe.focusable),
                  ee = ce.find((oe) => oe.active),
                  le = ce.find((oe) => oe.id === S),
                  xe = [ee, le, ...ce]
                    .filter(Boolean)
                    .map((oe) => oe.ref.current);
                nk(xe, p);
              }
            }
            I.current = !1;
          }),
          onBlur: Oe(t.onBlur, () => N(!1)),
        }),
      })
    );
  }),
  ek = "RovingFocusGroupItem",
  tk = b.forwardRef((t, e) => {
    const {
        __scopeRovingFocusGroup: n,
        focusable: r = !0,
        active: o = !1,
        tabStopId: i,
        ...l
      } = t,
      u = Td(),
      c = i || u,
      f = i_(ek, n),
      p = f.currentTabStopId === c,
      m = YC(n),
      { onFocusableItemAdd: y, onFocusableItemRemove: v } = f;
    return (
      b.useEffect(() => {
        if (r) return y(), () => v();
      }, [r, y, v]),
      O.jsx(Wm.ItemSlot, {
        scope: n,
        id: c,
        focusable: r,
        active: o,
        children: O.jsx(nt.span, {
          tabIndex: p ? 0 : -1,
          "data-orientation": f.orientation,
          ...l,
          ref: e,
          onMouseDown: Oe(t.onMouseDown, (x) => {
            r ? f.onItemFocus(c) : x.preventDefault();
          }),
          onFocus: Oe(t.onFocus, () => f.onItemFocus(c)),
          onKeyDown: Oe(t.onKeyDown, (x) => {
            if (x.key === "Tab" && x.shiftKey) {
              f.onItemShiftTab();
              return;
            }
            if (x.target !== x.currentTarget) return;
            const S = u_(x, f.orientation, f.dir);
            if (S !== void 0) {
              if (x.metaKey || x.ctrlKey || x.altKey || x.shiftKey) return;
              x.preventDefault();
              let E = m()
                .filter((N) => N.focusable)
                .map((N) => N.ref.current);
              if (S === "last") E.reverse();
              else if (S === "prev" || S === "next") {
                S === "prev" && E.reverse();
                const N = E.indexOf(x.currentTarget);
                E = f.loop ? c_(E, N + 1) : E.slice(N + 1);
              }
              setTimeout(() => nk(E));
            }
          }),
        }),
      })
    );
  });
tk.displayName = ek;
var l_ = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last",
};
function a_(t, e) {
  return e !== "rtl"
    ? t
    : t === "ArrowLeft"
    ? "ArrowRight"
    : t === "ArrowRight"
    ? "ArrowLeft"
    : t;
}
function u_(t, e, n) {
  const r = a_(t.key, n);
  if (
    !(e === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) &&
    !(e === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r))
  )
    return l_[r];
}
function nk(t, e = !1) {
  const n = document.activeElement;
  for (const r of t)
    if (
      r === n ||
      (r.focus({ preventScroll: e }), document.activeElement !== n)
    )
      return;
}
function c_(t, e) {
  return t.map((n, r) => t[(e + r) % t.length]);
}
var d_ = ZC,
  f_ = tk,
  p_ = function (t) {
    if (typeof document > "u") return null;
    var e = Array.isArray(t) ? t[0] : t;
    return e.ownerDocument.body;
  },
  Cs = new WeakMap(),
  xc = new WeakMap(),
  bc = {},
  Kh = 0,
  rk = function (t) {
    return t && (t.host || rk(t.parentNode));
  },
  h_ = function (t, e) {
    return e
      .map(function (n) {
        if (t.contains(n)) return n;
        var r = rk(n);
        return r && t.contains(r)
          ? r
          : (console.error(
              "aria-hidden",
              n,
              "in not contained inside",
              t,
              ". Doing nothing"
            ),
            null);
      })
      .filter(function (n) {
        return !!n;
      });
  },
  m_ = function (t, e, n, r) {
    var o = h_(e, Array.isArray(t) ? t : [t]);
    bc[n] || (bc[n] = new WeakMap());
    var i = bc[n],
      l = [],
      u = new Set(),
      c = new Set(o),
      f = function (m) {
        !m || u.has(m) || (u.add(m), f(m.parentNode));
      };
    o.forEach(f);
    var p = function (m) {
      !m ||
        c.has(m) ||
        Array.prototype.forEach.call(m.children, function (y) {
          if (u.has(y)) p(y);
          else
            try {
              var v = y.getAttribute(r),
                x = v !== null && v !== "false",
                S = (Cs.get(y) || 0) + 1,
                C = (i.get(y) || 0) + 1;
              Cs.set(y, S),
                i.set(y, C),
                l.push(y),
                S === 1 && x && xc.set(y, !0),
                C === 1 && y.setAttribute(n, "true"),
                x || y.setAttribute(r, "true");
            } catch (E) {
              console.error("aria-hidden: cannot operate on ", y, E);
            }
        });
    };
    return (
      p(e),
      u.clear(),
      Kh++,
      function () {
        l.forEach(function (m) {
          var y = Cs.get(m) - 1,
            v = i.get(m) - 1;
          Cs.set(m, y),
            i.set(m, v),
            y || (xc.has(m) || m.removeAttribute(r), xc.delete(m)),
            v || m.removeAttribute(n);
        }),
          Kh--,
          Kh ||
            ((Cs = new WeakMap()),
            (Cs = new WeakMap()),
            (xc = new WeakMap()),
            (bc = {}));
      }
    );
  },
  cf = function (t, e, n) {
    n === void 0 && (n = "data-aria-hidden");
    var r = Array.from(Array.isArray(t) ? t : [t]),
      o = p_(t);
    return o
      ? (r.push.apply(r, Array.from(o.querySelectorAll("[aria-live]"))),
        m_(r, o, n, "aria-hidden"))
      : function () {
          return null;
        };
  },
  Dt = function () {
    return (
      (Dt =
        Object.assign ||
        function (e) {
          for (var n, r = 1, o = arguments.length; r < o; r++) {
            n = arguments[r];
            for (var i in n)
              Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
          }
          return e;
        }),
      Dt.apply(this, arguments)
    );
  };
function ly(t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(t); o < r.length; o++)
      e.indexOf(r[o]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[o]) &&
        (n[r[o]] = t[r[o]]);
  return n;
}
function ok(t, e, n) {
  if (n || arguments.length === 2)
    for (var r = 0, o = e.length, i; r < o; r++)
      (i || !(r in e)) &&
        (i || (i = Array.prototype.slice.call(e, 0, r)), (i[r] = e[r]));
  return t.concat(i || Array.prototype.slice.call(e));
}
var pa = "right-scroll-bar-position",
  ha = "width-before-scroll-bar",
  g_ = "with-scroll-bars-hidden",
  y_ = "--removed-body-scroll-bar-size";
function qh(t, e) {
  return typeof t == "function" ? t(e) : t && (t.current = e), t;
}
function v_(t, e) {
  var n = b.useState(function () {
    return {
      value: t,
      callback: e,
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var o = n.value;
          o !== r && ((n.value = r), n.callback(r, o));
        },
      },
    };
  })[0];
  return (n.callback = e), n.facade;
}
var w_ = typeof window < "u" ? b.useLayoutEffect : b.useEffect,
  Ox = new WeakMap();
function ik(t, e) {
  var n = v_(null, function (r) {
    return t.forEach(function (o) {
      return qh(o, r);
    });
  });
  return (
    w_(
      function () {
        var r = Ox.get(n);
        if (r) {
          var o = new Set(r),
            i = new Set(t),
            l = n.current;
          o.forEach(function (u) {
            i.has(u) || qh(u, null);
          }),
            i.forEach(function (u) {
              o.has(u) || qh(u, l);
            });
        }
        Ox.set(n, t);
      },
      [t]
    ),
    n
  );
}
function x_(t) {
  return t;
}
function b_(t, e) {
  e === void 0 && (e = x_);
  var n = [],
    r = !1,
    o = {
      read: function () {
        if (r)
          throw new Error(
            "Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`."
          );
        return n.length ? n[n.length - 1] : t;
      },
      useMedium: function (i) {
        var l = e(i, r);
        return (
          n.push(l),
          function () {
            n = n.filter(function (u) {
              return u !== l;
            });
          }
        );
      },
      assignSyncMedium: function (i) {
        for (r = !0; n.length; ) {
          var l = n;
          (n = []), l.forEach(i);
        }
        n = {
          push: function (u) {
            return i(u);
          },
          filter: function () {
            return n;
          },
        };
      },
      assignMedium: function (i) {
        r = !0;
        var l = [];
        if (n.length) {
          var u = n;
          (n = []), u.forEach(i), (l = n);
        }
        var c = function () {
            var p = l;
            (l = []), p.forEach(i);
          },
          f = function () {
            return Promise.resolve().then(c);
          };
        f(),
          (n = {
            push: function (p) {
              l.push(p), f();
            },
            filter: function (p) {
              return (l = l.filter(p)), n;
            },
          });
      },
    };
  return o;
}
function sk(t) {
  t === void 0 && (t = {});
  var e = b_(null);
  return (e.options = Dt({ async: !0, ssr: !1 }, t)), e;
}
var lk = function (t) {
  var e = t.sideCar,
    n = ly(t, ["sideCar"]);
  if (!e)
    throw new Error(
      "Sidecar: please provide `sideCar` property to import the right car"
    );
  var r = e.read();
  if (!r) throw new Error("Sidecar medium not found");
  return b.createElement(r, Dt({}, n));
};
lk.isSideCarExport = !0;
function ak(t, e) {
  return t.useMedium(e), lk;
}
var uk = sk(),
  Gh = function () {},
  df = b.forwardRef(function (t, e) {
    var n = b.useRef(null),
      r = b.useState({
        onScrollCapture: Gh,
        onWheelCapture: Gh,
        onTouchMoveCapture: Gh,
      }),
      o = r[0],
      i = r[1],
      l = t.forwardProps,
      u = t.children,
      c = t.className,
      f = t.removeScrollBar,
      p = t.enabled,
      m = t.shards,
      y = t.sideCar,
      v = t.noIsolation,
      x = t.inert,
      S = t.allowPinchZoom,
      C = t.as,
      E = C === void 0 ? "div" : C,
      N = t.gapMode,
      $ = ly(t, [
        "forwardProps",
        "children",
        "className",
        "removeScrollBar",
        "enabled",
        "shards",
        "sideCar",
        "noIsolation",
        "inert",
        "allowPinchZoom",
        "as",
        "gapMode",
      ]),
      M = y,
      I = ik([n, e]),
      R = Dt(Dt({}, $), o);
    return b.createElement(
      b.Fragment,
      null,
      p &&
        b.createElement(M, {
          sideCar: uk,
          removeScrollBar: f,
          shards: m,
          noIsolation: v,
          inert: x,
          setCallbacks: i,
          allowPinchZoom: !!S,
          lockRef: n,
          gapMode: N,
        }),
      l
        ? b.cloneElement(b.Children.only(u), Dt(Dt({}, R), { ref: I }))
        : b.createElement(E, Dt({}, R, { className: c, ref: I }), u)
    );
  });
df.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 };
df.classNames = { fullWidth: ha, zeroRight: pa };
var S_ = function () {
  if (typeof __webpack_nonce__ < "u") return __webpack_nonce__;
};
function C_() {
  if (!document) return null;
  var t = document.createElement("style");
  t.type = "text/css";
  var e = S_();
  return e && t.setAttribute("nonce", e), t;
}
function k_(t, e) {
  t.styleSheet
    ? (t.styleSheet.cssText = e)
    : t.appendChild(document.createTextNode(e));
}
function E_(t) {
  var e = document.head || document.getElementsByTagName("head")[0];
  e.appendChild(t);
}
var M_ = function () {
    var t = 0,
      e = null;
    return {
      add: function (n) {
        t == 0 && (e = C_()) && (k_(e, n), E_(e)), t++;
      },
      remove: function () {
        t--,
          !t && e && (e.parentNode && e.parentNode.removeChild(e), (e = null));
      },
    };
  },
  O_ = function () {
    var t = M_();
    return function (e, n) {
      b.useEffect(
        function () {
          return (
            t.add(e),
            function () {
              t.remove();
            }
          );
        },
        [e && n]
      );
    };
  },
  ay = function () {
    var t = O_(),
      e = function (n) {
        var r = n.styles,
          o = n.dynamic;
        return t(r, o), null;
      };
    return e;
  },
  T_ = { left: 0, top: 0, right: 0, gap: 0 },
  Jh = function (t) {
    return parseInt(t || "", 10) || 0;
  },
  N_ = function (t) {
    var e = window.getComputedStyle(document.body),
      n = e[t === "padding" ? "paddingLeft" : "marginLeft"],
      r = e[t === "padding" ? "paddingTop" : "marginTop"],
      o = e[t === "padding" ? "paddingRight" : "marginRight"];
    return [Jh(n), Jh(r), Jh(o)];
  },
  A_ = function (t) {
    if ((t === void 0 && (t = "margin"), typeof window > "u")) return T_;
    var e = N_(t),
      n = document.documentElement.clientWidth,
      r = window.innerWidth;
    return {
      left: e[0],
      top: e[1],
      right: e[2],
      gap: Math.max(0, r - n + e[2] - e[0]),
    };
  },
  R_ = ay(),
  js = "data-scroll-locked",
  P_ = function (t, e, n, r) {
    var o = t.left,
      i = t.top,
      l = t.right,
      u = t.gap;
    return (
      n === void 0 && (n = "margin"),
      `
  .`
        .concat(
          g_,
          ` {
   overflow: hidden `
        )
        .concat(
          r,
          `;
   padding-right: `
        )
        .concat(u, "px ")
        .concat(
          r,
          `;
  }
  body[`
        )
        .concat(
          js,
          `] {
    overflow: hidden `
        )
        .concat(
          r,
          `;
    overscroll-behavior: contain;
    `
        )
        .concat(
          [
            e && "position: relative ".concat(r, ";"),
            n === "margin" &&
              `
    padding-left: `
                .concat(
                  o,
                  `px;
    padding-top: `
                )
                .concat(
                  i,
                  `px;
    padding-right: `
                )
                .concat(
                  l,
                  `px;
    margin-left:0;
    margin-top:0;
    margin-right: `
                )
                .concat(u, "px ")
                .concat(
                  r,
                  `;
    `
                ),
            n === "padding" &&
              "padding-right: ".concat(u, "px ").concat(r, ";"),
          ]
            .filter(Boolean)
            .join(""),
          `
  }
  
  .`
        )
        .concat(
          pa,
          ` {
    right: `
        )
        .concat(u, "px ")
        .concat(
          r,
          `;
  }
  
  .`
        )
        .concat(
          ha,
          ` {
    margin-right: `
        )
        .concat(u, "px ")
        .concat(
          r,
          `;
  }
  
  .`
        )
        .concat(pa, " .")
        .concat(
          pa,
          ` {
    right: 0 `
        )
        .concat(
          r,
          `;
  }
  
  .`
        )
        .concat(ha, " .")
        .concat(
          ha,
          ` {
    margin-right: 0 `
        )
        .concat(
          r,
          `;
  }
  
  body[`
        )
        .concat(
          js,
          `] {
    `
        )
        .concat(y_, ": ")
        .concat(
          u,
          `px;
  }
`
        )
    );
  },
  Tx = function () {
    var t = parseInt(document.body.getAttribute(js) || "0", 10);
    return isFinite(t) ? t : 0;
  },
  D_ = function () {
    b.useEffect(function () {
      return (
        document.body.setAttribute(js, (Tx() + 1).toString()),
        function () {
          var t = Tx() - 1;
          t <= 0
            ? document.body.removeAttribute(js)
            : document.body.setAttribute(js, t.toString());
        }
      );
    }, []);
  },
  ck = function (t) {
    var e = t.noRelative,
      n = t.noImportant,
      r = t.gapMode,
      o = r === void 0 ? "margin" : r;
    D_();
    var i = b.useMemo(
      function () {
        return A_(o);
      },
      [o]
    );
    return b.createElement(R_, { styles: P_(i, !e, o, n ? "" : "!important") });
  },
  Um = !1;
if (typeof window < "u")
  try {
    var Sc = Object.defineProperty({}, "passive", {
      get: function () {
        return (Um = !0), !0;
      },
    });
    window.addEventListener("test", Sc, Sc),
      window.removeEventListener("test", Sc, Sc);
  } catch {
    Um = !1;
  }
var ks = Um ? { passive: !1 } : !1,
  I_ = function (t) {
    return t.tagName === "TEXTAREA";
  },
  dk = function (t, e) {
    if (!(t instanceof Element)) return !1;
    var n = window.getComputedStyle(t);
    return (
      n[e] !== "hidden" &&
      !(n.overflowY === n.overflowX && !I_(t) && n[e] === "visible")
    );
  },
  L_ = function (t) {
    return dk(t, "overflowY");
  },
  $_ = function (t) {
    return dk(t, "overflowX");
  },
  Nx = function (t, e) {
    var n = e.ownerDocument,
      r = e;
    do {
      typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
      var o = fk(t, r);
      if (o) {
        var i = pk(t, r),
          l = i[1],
          u = i[2];
        if (l > u) return !0;
      }
      r = r.parentNode;
    } while (r && r !== n.body);
    return !1;
  },
  __ = function (t) {
    var e = t.scrollTop,
      n = t.scrollHeight,
      r = t.clientHeight;
    return [e, n, r];
  },
  F_ = function (t) {
    var e = t.scrollLeft,
      n = t.scrollWidth,
      r = t.clientWidth;
    return [e, n, r];
  },
  fk = function (t, e) {
    return t === "v" ? L_(e) : $_(e);
  },
  pk = function (t, e) {
    return t === "v" ? __(e) : F_(e);
  },
  z_ = function (t, e) {
    return t === "h" && e === "rtl" ? -1 : 1;
  },
  j_ = function (t, e, n, r, o) {
    var i = z_(t, window.getComputedStyle(e).direction),
      l = i * r,
      u = n.target,
      c = e.contains(u),
      f = !1,
      p = l > 0,
      m = 0,
      y = 0;
    do {
      var v = pk(t, u),
        x = v[0],
        S = v[1],
        C = v[2],
        E = S - C - i * x;
      (x || E) && fk(t, u) && ((m += E), (y += x)),
        u instanceof ShadowRoot ? (u = u.host) : (u = u.parentNode);
    } while ((!c && u !== document.body) || (c && (e.contains(u) || e === u)));
    return ((p && Math.abs(m) < 1) || (!p && Math.abs(y) < 1)) && (f = !0), f;
  },
  Cc = function (t) {
    return "changedTouches" in t
      ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY]
      : [0, 0];
  },
  Ax = function (t) {
    return [t.deltaX, t.deltaY];
  },
  Rx = function (t) {
    return t && "current" in t ? t.current : t;
  },
  B_ = function (t, e) {
    return t[0] === e[0] && t[1] === e[1];
  },
  H_ = function (t) {
    return `
  .block-interactivity-`
      .concat(
        t,
        ` {pointer-events: none;}
  .allow-interactivity-`
      )
      .concat(
        t,
        ` {pointer-events: all;}
`
      );
  },
  V_ = 0,
  Es = [];
function W_(t) {
  var e = b.useRef([]),
    n = b.useRef([0, 0]),
    r = b.useRef(),
    o = b.useState(V_++)[0],
    i = b.useState(ay)[0],
    l = b.useRef(t);
  b.useEffect(
    function () {
      l.current = t;
    },
    [t]
  ),
    b.useEffect(
      function () {
        if (t.inert) {
          document.body.classList.add("block-interactivity-".concat(o));
          var S = ok([t.lockRef.current], (t.shards || []).map(Rx), !0).filter(
            Boolean
          );
          return (
            S.forEach(function (C) {
              return C.classList.add("allow-interactivity-".concat(o));
            }),
            function () {
              document.body.classList.remove("block-interactivity-".concat(o)),
                S.forEach(function (C) {
                  return C.classList.remove("allow-interactivity-".concat(o));
                });
            }
          );
        }
      },
      [t.inert, t.lockRef.current, t.shards]
    );
  var u = b.useCallback(function (S, C) {
      if (
        ("touches" in S && S.touches.length === 2) ||
        (S.type === "wheel" && S.ctrlKey)
      )
        return !l.current.allowPinchZoom;
      var E = Cc(S),
        N = n.current,
        $ = "deltaX" in S ? S.deltaX : N[0] - E[0],
        M = "deltaY" in S ? S.deltaY : N[1] - E[1],
        I,
        R = S.target,
        F = Math.abs($) > Math.abs(M) ? "h" : "v";
      if ("touches" in S && F === "h" && R.type === "range") return !1;
      var H = Nx(F, R);
      if (!H) return !0;
      if ((H ? (I = F) : ((I = F === "v" ? "h" : "v"), (H = Nx(F, R))), !H))
        return !1;
      if (
        (!r.current && "changedTouches" in S && ($ || M) && (r.current = I), !I)
      )
        return !0;
      var U = r.current || I;
      return j_(U, C, S, U === "h" ? $ : M);
    }, []),
    c = b.useCallback(function (S) {
      var C = S;
      if (!(!Es.length || Es[Es.length - 1] !== i)) {
        var E = "deltaY" in C ? Ax(C) : Cc(C),
          N = e.current.filter(function (I) {
            return (
              I.name === C.type &&
              (I.target === C.target || C.target === I.shadowParent) &&
              B_(I.delta, E)
            );
          })[0];
        if (N && N.should) {
          C.cancelable && C.preventDefault();
          return;
        }
        if (!N) {
          var $ = (l.current.shards || [])
              .map(Rx)
              .filter(Boolean)
              .filter(function (I) {
                return I.contains(C.target);
              }),
            M = $.length > 0 ? u(C, $[0]) : !l.current.noIsolation;
          M && C.cancelable && C.preventDefault();
        }
      }
    }, []),
    f = b.useCallback(function (S, C, E, N) {
      var $ = { name: S, delta: C, target: E, should: N, shadowParent: U_(E) };
      e.current.push($),
        setTimeout(function () {
          e.current = e.current.filter(function (M) {
            return M !== $;
          });
        }, 1);
    }, []),
    p = b.useCallback(function (S) {
      (n.current = Cc(S)), (r.current = void 0);
    }, []),
    m = b.useCallback(function (S) {
      f(S.type, Ax(S), S.target, u(S, t.lockRef.current));
    }, []),
    y = b.useCallback(function (S) {
      f(S.type, Cc(S), S.target, u(S, t.lockRef.current));
    }, []);
  b.useEffect(function () {
    return (
      Es.push(i),
      t.setCallbacks({
        onScrollCapture: m,
        onWheelCapture: m,
        onTouchMoveCapture: y,
      }),
      document.addEventListener("wheel", c, ks),
      document.addEventListener("touchmove", c, ks),
      document.addEventListener("touchstart", p, ks),
      function () {
        (Es = Es.filter(function (S) {
          return S !== i;
        })),
          document.removeEventListener("wheel", c, ks),
          document.removeEventListener("touchmove", c, ks),
          document.removeEventListener("touchstart", p, ks);
      }
    );
  }, []);
  var v = t.removeScrollBar,
    x = t.inert;
  return b.createElement(
    b.Fragment,
    null,
    x ? b.createElement(i, { styles: H_(o) }) : null,
    v ? b.createElement(ck, { gapMode: t.gapMode }) : null
  );
}
function U_(t) {
  for (var e = null; t !== null; )
    t instanceof ShadowRoot && ((e = t.host), (t = t.host)), (t = t.parentNode);
  return e;
}
const K_ = ak(uk, W_);
var ff = b.forwardRef(function (t, e) {
  return b.createElement(df, Dt({}, t, { ref: e, sideCar: K_ }));
});
ff.classNames = df.classNames;
var Km = ["Enter", " "],
  q_ = ["ArrowDown", "PageUp", "Home"],
  hk = ["ArrowUp", "PageDown", "End"],
  G_ = [...q_, ...hk],
  J_ = { ltr: [...Km, "ArrowRight"], rtl: [...Km, "ArrowLeft"] },
  Q_ = { ltr: ["ArrowLeft"], rtl: ["ArrowRight"] },
  Va = "Menu",
  [Ra, Y_, X_] = CC(Va),
  [Ki, mk] = Ui(Va, [X_, lf, XC]),
  pf = lf(),
  gk = XC(),
  [Z_, qi] = Ki(Va),
  [eF, Wa] = Ki(Va),
  yk = (t) => {
    const {
        __scopeMenu: e,
        open: n = !1,
        children: r,
        dir: o,
        onOpenChange: i,
        modal: l = !0,
      } = t,
      u = pf(e),
      [c, f] = b.useState(null),
      p = b.useRef(!1),
      m = Jn(i),
      y = kC(o);
    return (
      b.useEffect(() => {
        const v = () => {
            (p.current = !0),
              document.addEventListener("pointerdown", x, {
                capture: !0,
                once: !0,
              }),
              document.addEventListener("pointermove", x, {
                capture: !0,
                once: !0,
              });
          },
          x = () => (p.current = !1);
        return (
          document.addEventListener("keydown", v, { capture: !0 }),
          () => {
            document.removeEventListener("keydown", v, { capture: !0 }),
              document.removeEventListener("pointerdown", x, { capture: !0 }),
              document.removeEventListener("pointermove", x, { capture: !0 });
          }
        );
      }, []),
      O.jsx(GC, {
        ...u,
        children: O.jsx(Z_, {
          scope: e,
          open: n,
          onOpenChange: m,
          content: c,
          onContentChange: f,
          children: O.jsx(eF, {
            scope: e,
            onClose: b.useCallback(() => m(!1), [m]),
            isUsingKeyboardRef: p,
            dir: y,
            modal: l,
            children: r,
          }),
        }),
      })
    );
  };
yk.displayName = Va;
var tF = "MenuAnchor",
  uy = b.forwardRef((t, e) => {
    const { __scopeMenu: n, ...r } = t,
      o = pf(n);
    return O.jsx(sy, { ...o, ...r, ref: e });
  });
uy.displayName = tF;
var cy = "MenuPortal",
  [nF, vk] = Ki(cy, { forceMount: void 0 }),
  wk = (t) => {
    const { __scopeMenu: e, forceMount: n, children: r, container: o } = t,
      i = qi(cy, e);
    return O.jsx(nF, {
      scope: e,
      forceMount: n,
      children: O.jsx(br, {
        present: n || i.open,
        children: O.jsx(af, { asChild: !0, container: o, children: r }),
      }),
    });
  };
wk.displayName = cy;
var Pn = "MenuContent",
  [rF, dy] = Ki(Pn),
  xk = b.forwardRef((t, e) => {
    const n = vk(Pn, t.__scopeMenu),
      { forceMount: r = n.forceMount, ...o } = t,
      i = qi(Pn, t.__scopeMenu),
      l = Wa(Pn, t.__scopeMenu);
    return O.jsx(Ra.Provider, {
      scope: t.__scopeMenu,
      children: O.jsx(br, {
        present: r || i.open,
        children: O.jsx(Ra.Slot, {
          scope: t.__scopeMenu,
          children: l.modal
            ? O.jsx(oF, { ...o, ref: e })
            : O.jsx(iF, { ...o, ref: e }),
        }),
      }),
    });
  }),
  oF = b.forwardRef((t, e) => {
    const n = qi(Pn, t.__scopeMenu),
      r = b.useRef(null),
      o = ft(e, r);
    return (
      b.useEffect(() => {
        const i = r.current;
        if (i) return cf(i);
      }, []),
      O.jsx(fy, {
        ...t,
        ref: o,
        trapFocus: n.open,
        disableOutsidePointerEvents: n.open,
        disableOutsideScroll: !0,
        onFocusOutside: Oe(t.onFocusOutside, (i) => i.preventDefault(), {
          checkForDefaultPrevented: !1,
        }),
        onDismiss: () => n.onOpenChange(!1),
      })
    );
  }),
  iF = b.forwardRef((t, e) => {
    const n = qi(Pn, t.__scopeMenu);
    return O.jsx(fy, {
      ...t,
      ref: e,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      disableOutsideScroll: !1,
      onDismiss: () => n.onOpenChange(!1),
    });
  }),
  fy = b.forwardRef((t, e) => {
    const {
        __scopeMenu: n,
        loop: r = !1,
        trapFocus: o,
        onOpenAutoFocus: i,
        onCloseAutoFocus: l,
        disableOutsidePointerEvents: u,
        onEntryFocus: c,
        onEscapeKeyDown: f,
        onPointerDownOutside: p,
        onFocusOutside: m,
        onInteractOutside: y,
        onDismiss: v,
        disableOutsideScroll: x,
        ...S
      } = t,
      C = qi(Pn, n),
      E = Wa(Pn, n),
      N = pf(n),
      $ = gk(n),
      M = Y_(n),
      [I, R] = b.useState(null),
      F = b.useRef(null),
      H = ft(e, F, C.onContentChange),
      U = b.useRef(0),
      re = b.useRef(""),
      ce = b.useRef(0),
      ee = b.useRef(null),
      le = b.useRef("right"),
      de = b.useRef(0),
      xe = x ? ff : b.Fragment,
      oe = x ? { as: Ho, allowPinchZoom: !0 } : void 0,
      se = (V) => {
        var he, we;
        const K = re.current + V,
          D = M().filter((be) => !be.disabled),
          A = document.activeElement,
          X =
            (he = D.find((be) => be.ref.current === A)) == null
              ? void 0
              : he.textValue,
          ne = D.map((be) => be.textValue),
          Q = yF(ne, K, X),
          ie =
            (we = D.find((be) => be.textValue === Q)) == null
              ? void 0
              : we.ref.current;
        (function be($e) {
          (re.current = $e),
            window.clearTimeout(U.current),
            $e !== "" && (U.current = window.setTimeout(() => be(""), 1e3));
        })(K),
          ie && setTimeout(() => ie.focus());
      };
    b.useEffect(() => () => window.clearTimeout(U.current), []), Qg();
    const B = b.useCallback((V) => {
      var D, A;
      return (
        le.current === ((D = ee.current) == null ? void 0 : D.side) &&
        wF(V, (A = ee.current) == null ? void 0 : A.area)
      );
    }, []);
    return O.jsx(rF, {
      scope: n,
      searchRef: re,
      onItemEnter: b.useCallback(
        (V) => {
          B(V) && V.preventDefault();
        },
        [B]
      ),
      onItemLeave: b.useCallback(
        (V) => {
          var K;
          B(V) || ((K = F.current) == null || K.focus(), R(null));
        },
        [B]
      ),
      onTriggerLeave: b.useCallback(
        (V) => {
          B(V) && V.preventDefault();
        },
        [B]
      ),
      pointerGraceTimerRef: ce,
      onPointerGraceIntentChange: b.useCallback((V) => {
        ee.current = V;
      }, []),
      children: O.jsx(xe, {
        ...oe,
        children: O.jsx(nf, {
          asChild: !0,
          trapped: o,
          onMountAutoFocus: Oe(i, (V) => {
            var K;
            V.preventDefault(),
              (K = F.current) == null || K.focus({ preventScroll: !0 });
          }),
          onUnmountAutoFocus: l,
          children: O.jsx(tf, {
            asChild: !0,
            disableOutsidePointerEvents: u,
            onEscapeKeyDown: f,
            onPointerDownOutside: p,
            onFocusOutside: m,
            onInteractOutside: y,
            onDismiss: v,
            children: O.jsx(d_, {
              asChild: !0,
              ...$,
              dir: E.dir,
              orientation: "vertical",
              loop: r,
              currentTabStopId: I,
              onCurrentTabStopIdChange: R,
              onEntryFocus: Oe(c, (V) => {
                E.isUsingKeyboardRef.current || V.preventDefault();
              }),
              preventScrollOnEntryFocus: !0,
              children: O.jsx(JC, {
                role: "menu",
                "aria-orientation": "vertical",
                "data-state": $k(C.open),
                "data-radix-menu-content": "",
                dir: E.dir,
                ...N,
                ...S,
                ref: H,
                style: { outline: "none", ...S.style },
                onKeyDown: Oe(S.onKeyDown, (V) => {
                  const D =
                      V.target.closest("[data-radix-menu-content]") ===
                      V.currentTarget,
                    A = V.ctrlKey || V.altKey || V.metaKey,
                    X = V.key.length === 1;
                  D &&
                    (V.key === "Tab" && V.preventDefault(),
                    !A && X && se(V.key));
                  const ne = F.current;
                  if (V.target !== ne || !G_.includes(V.key)) return;
                  V.preventDefault();
                  const ie = M()
                    .filter((he) => !he.disabled)
                    .map((he) => he.ref.current);
                  hk.includes(V.key) && ie.reverse(), mF(ie);
                }),
                onBlur: Oe(t.onBlur, (V) => {
                  V.currentTarget.contains(V.target) ||
                    (window.clearTimeout(U.current), (re.current = ""));
                }),
                onPointerMove: Oe(
                  t.onPointerMove,
                  Pa((V) => {
                    const K = V.target,
                      D = de.current !== V.clientX;
                    if (V.currentTarget.contains(K) && D) {
                      const A = V.clientX > de.current ? "right" : "left";
                      (le.current = A), (de.current = V.clientX);
                    }
                  })
                ),
              }),
            }),
          }),
        }),
      }),
    });
  });
xk.displayName = Pn;
var sF = "MenuGroup",
  py = b.forwardRef((t, e) => {
    const { __scopeMenu: n, ...r } = t;
    return O.jsx(nt.div, { role: "group", ...r, ref: e });
  });
py.displayName = sF;
var lF = "MenuLabel",
  bk = b.forwardRef((t, e) => {
    const { __scopeMenu: n, ...r } = t;
    return O.jsx(nt.div, { ...r, ref: e });
  });
bk.displayName = lF;
var Dd = "MenuItem",
  Px = "menu.itemSelect",
  hf = b.forwardRef((t, e) => {
    const { disabled: n = !1, onSelect: r, ...o } = t,
      i = b.useRef(null),
      l = Wa(Dd, t.__scopeMenu),
      u = dy(Dd, t.__scopeMenu),
      c = ft(e, i),
      f = b.useRef(!1),
      p = () => {
        const m = i.current;
        if (!n && m) {
          const y = new CustomEvent(Px, { bubbles: !0, cancelable: !0 });
          m.addEventListener(Px, (v) => (r == null ? void 0 : r(v)), {
            once: !0,
          }),
            SC(m, y),
            y.defaultPrevented ? (f.current = !1) : l.onClose();
        }
      };
    return O.jsx(Sk, {
      ...o,
      ref: c,
      disabled: n,
      onClick: Oe(t.onClick, p),
      onPointerDown: (m) => {
        var y;
        (y = t.onPointerDown) == null || y.call(t, m), (f.current = !0);
      },
      onPointerUp: Oe(t.onPointerUp, (m) => {
        var y;
        f.current || (y = m.currentTarget) == null || y.click();
      }),
      onKeyDown: Oe(t.onKeyDown, (m) => {
        const y = u.searchRef.current !== "";
        n ||
          (y && m.key === " ") ||
          (Km.includes(m.key) && (m.currentTarget.click(), m.preventDefault()));
      }),
    });
  });
hf.displayName = Dd;
var Sk = b.forwardRef((t, e) => {
    const { __scopeMenu: n, disabled: r = !1, textValue: o, ...i } = t,
      l = dy(Dd, n),
      u = gk(n),
      c = b.useRef(null),
      f = ft(e, c),
      [p, m] = b.useState(!1),
      [y, v] = b.useState("");
    return (
      b.useEffect(() => {
        const x = c.current;
        x && v((x.textContent ?? "").trim());
      }, [i.children]),
      O.jsx(Ra.ItemSlot, {
        scope: n,
        disabled: r,
        textValue: o ?? y,
        children: O.jsx(f_, {
          asChild: !0,
          ...u,
          focusable: !r,
          children: O.jsx(nt.div, {
            role: "menuitem",
            "data-highlighted": p ? "" : void 0,
            "aria-disabled": r || void 0,
            "data-disabled": r ? "" : void 0,
            ...i,
            ref: f,
            onPointerMove: Oe(
              t.onPointerMove,
              Pa((x) => {
                r
                  ? l.onItemLeave(x)
                  : (l.onItemEnter(x),
                    x.defaultPrevented ||
                      x.currentTarget.focus({ preventScroll: !0 }));
              })
            ),
            onPointerLeave: Oe(
              t.onPointerLeave,
              Pa((x) => l.onItemLeave(x))
            ),
            onFocus: Oe(t.onFocus, () => m(!0)),
            onBlur: Oe(t.onBlur, () => m(!1)),
          }),
        }),
      })
    );
  }),
  aF = "MenuCheckboxItem",
  Ck = b.forwardRef((t, e) => {
    const { checked: n = !1, onCheckedChange: r, ...o } = t;
    return O.jsx(Tk, {
      scope: t.__scopeMenu,
      checked: n,
      children: O.jsx(hf, {
        role: "menuitemcheckbox",
        "aria-checked": Id(n) ? "mixed" : n,
        ...o,
        ref: e,
        "data-state": my(n),
        onSelect: Oe(
          o.onSelect,
          () => (r == null ? void 0 : r(Id(n) ? !0 : !n)),
          { checkForDefaultPrevented: !1 }
        ),
      }),
    });
  });
Ck.displayName = aF;
var kk = "MenuRadioGroup",
  [uF, cF] = Ki(kk, { value: void 0, onValueChange: () => {} }),
  Ek = b.forwardRef((t, e) => {
    const { value: n, onValueChange: r, ...o } = t,
      i = Jn(r);
    return O.jsx(uF, {
      scope: t.__scopeMenu,
      value: n,
      onValueChange: i,
      children: O.jsx(py, { ...o, ref: e }),
    });
  });
Ek.displayName = kk;
var Mk = "MenuRadioItem",
  Ok = b.forwardRef((t, e) => {
    const { value: n, ...r } = t,
      o = cF(Mk, t.__scopeMenu),
      i = n === o.value;
    return O.jsx(Tk, {
      scope: t.__scopeMenu,
      checked: i,
      children: O.jsx(hf, {
        role: "menuitemradio",
        "aria-checked": i,
        ...r,
        ref: e,
        "data-state": my(i),
        onSelect: Oe(
          r.onSelect,
          () => {
            var l;
            return (l = o.onValueChange) == null ? void 0 : l.call(o, n);
          },
          { checkForDefaultPrevented: !1 }
        ),
      }),
    });
  });
Ok.displayName = Mk;
var hy = "MenuItemIndicator",
  [Tk, dF] = Ki(hy, { checked: !1 }),
  Nk = b.forwardRef((t, e) => {
    const { __scopeMenu: n, forceMount: r, ...o } = t,
      i = dF(hy, n);
    return O.jsx(br, {
      present: r || Id(i.checked) || i.checked === !0,
      children: O.jsx(nt.span, { ...o, ref: e, "data-state": my(i.checked) }),
    });
  });
Nk.displayName = hy;
var fF = "MenuSeparator",
  Ak = b.forwardRef((t, e) => {
    const { __scopeMenu: n, ...r } = t;
    return O.jsx(nt.div, {
      role: "separator",
      "aria-orientation": "horizontal",
      ...r,
      ref: e,
    });
  });
Ak.displayName = fF;
var pF = "MenuArrow",
  Rk = b.forwardRef((t, e) => {
    const { __scopeMenu: n, ...r } = t,
      o = pf(n);
    return O.jsx(QC, { ...o, ...r, ref: e });
  });
Rk.displayName = pF;
var hF = "MenuSub",
  [MB, Pk] = Ki(hF),
  ea = "MenuSubTrigger",
  Dk = b.forwardRef((t, e) => {
    const n = qi(ea, t.__scopeMenu),
      r = Wa(ea, t.__scopeMenu),
      o = Pk(ea, t.__scopeMenu),
      i = dy(ea, t.__scopeMenu),
      l = b.useRef(null),
      { pointerGraceTimerRef: u, onPointerGraceIntentChange: c } = i,
      f = { __scopeMenu: t.__scopeMenu },
      p = b.useCallback(() => {
        l.current && window.clearTimeout(l.current), (l.current = null);
      }, []);
    return (
      b.useEffect(() => p, [p]),
      b.useEffect(() => {
        const m = u.current;
        return () => {
          window.clearTimeout(m), c(null);
        };
      }, [u, c]),
      O.jsx(uy, {
        asChild: !0,
        ...f,
        children: O.jsx(Sk, {
          id: o.triggerId,
          "aria-haspopup": "menu",
          "aria-expanded": n.open,
          "aria-controls": o.contentId,
          "data-state": $k(n.open),
          ...t,
          ref: Zd(e, o.onTriggerChange),
          onClick: (m) => {
            var y;
            (y = t.onClick) == null || y.call(t, m),
              !(t.disabled || m.defaultPrevented) &&
                (m.currentTarget.focus(), n.open || n.onOpenChange(!0));
          },
          onPointerMove: Oe(
            t.onPointerMove,
            Pa((m) => {
              i.onItemEnter(m),
                !m.defaultPrevented &&
                  !t.disabled &&
                  !n.open &&
                  !l.current &&
                  (i.onPointerGraceIntentChange(null),
                  (l.current = window.setTimeout(() => {
                    n.onOpenChange(!0), p();
                  }, 100)));
            })
          ),
          onPointerLeave: Oe(
            t.onPointerLeave,
            Pa((m) => {
              var v, x;
              p();
              const y =
                (v = n.content) == null ? void 0 : v.getBoundingClientRect();
              if (y) {
                const S = (x = n.content) == null ? void 0 : x.dataset.side,
                  C = S === "right",
                  E = C ? -5 : 5,
                  N = y[C ? "left" : "right"],
                  $ = y[C ? "right" : "left"];
                i.onPointerGraceIntentChange({
                  area: [
                    { x: m.clientX + E, y: m.clientY },
                    { x: N, y: y.top },
                    { x: $, y: y.top },
                    { x: $, y: y.bottom },
                    { x: N, y: y.bottom },
                  ],
                  side: S,
                }),
                  window.clearTimeout(u.current),
                  (u.current = window.setTimeout(
                    () => i.onPointerGraceIntentChange(null),
                    300
                  ));
              } else {
                if ((i.onTriggerLeave(m), m.defaultPrevented)) return;
                i.onPointerGraceIntentChange(null);
              }
            })
          ),
          onKeyDown: Oe(t.onKeyDown, (m) => {
            var v;
            const y = i.searchRef.current !== "";
            t.disabled ||
              (y && m.key === " ") ||
              (J_[r.dir].includes(m.key) &&
                (n.onOpenChange(!0),
                (v = n.content) == null || v.focus(),
                m.preventDefault()));
          }),
        }),
      })
    );
  });
Dk.displayName = ea;
var Ik = "MenuSubContent",
  Lk = b.forwardRef((t, e) => {
    const n = vk(Pn, t.__scopeMenu),
      { forceMount: r = n.forceMount, ...o } = t,
      i = qi(Pn, t.__scopeMenu),
      l = Wa(Pn, t.__scopeMenu),
      u = Pk(Ik, t.__scopeMenu),
      c = b.useRef(null),
      f = ft(e, c);
    return O.jsx(Ra.Provider, {
      scope: t.__scopeMenu,
      children: O.jsx(br, {
        present: r || i.open,
        children: O.jsx(Ra.Slot, {
          scope: t.__scopeMenu,
          children: O.jsx(fy, {
            id: u.contentId,
            "aria-labelledby": u.triggerId,
            ...o,
            ref: f,
            align: "start",
            side: l.dir === "rtl" ? "left" : "right",
            disableOutsidePointerEvents: !1,
            disableOutsideScroll: !1,
            trapFocus: !1,
            onOpenAutoFocus: (p) => {
              var m;
              l.isUsingKeyboardRef.current &&
                ((m = c.current) == null || m.focus()),
                p.preventDefault();
            },
            onCloseAutoFocus: (p) => p.preventDefault(),
            onFocusOutside: Oe(t.onFocusOutside, (p) => {
              p.target !== u.trigger && i.onOpenChange(!1);
            }),
            onEscapeKeyDown: Oe(t.onEscapeKeyDown, (p) => {
              l.onClose(), p.preventDefault();
            }),
            onKeyDown: Oe(t.onKeyDown, (p) => {
              var v;
              const m = p.currentTarget.contains(p.target),
                y = Q_[l.dir].includes(p.key);
              m &&
                y &&
                (i.onOpenChange(!1),
                (v = u.trigger) == null || v.focus(),
                p.preventDefault());
            }),
          }),
        }),
      }),
    });
  });
Lk.displayName = Ik;
function $k(t) {
  return t ? "open" : "closed";
}
function Id(t) {
  return t === "indeterminate";
}
function my(t) {
  return Id(t) ? "indeterminate" : t ? "checked" : "unchecked";
}
function mF(t) {
  const e = document.activeElement;
  for (const n of t)
    if (n === e || (n.focus(), document.activeElement !== e)) return;
}
function gF(t, e) {
  return t.map((n, r) => t[(e + r) % t.length]);
}
function yF(t, e, n) {
  const o = e.length > 1 && Array.from(e).every((f) => f === e[0]) ? e[0] : e,
    i = n ? t.indexOf(n) : -1;
  let l = gF(t, Math.max(i, 0));
  o.length === 1 && (l = l.filter((f) => f !== n));
  const c = l.find((f) => f.toLowerCase().startsWith(o.toLowerCase()));
  return c !== n ? c : void 0;
}
function vF(t, e) {
  const { x: n, y: r } = t;
  let o = !1;
  for (let i = 0, l = e.length - 1; i < e.length; l = i++) {
    const u = e[i].x,
      c = e[i].y,
      f = e[l].x,
      p = e[l].y;
    c > r != p > r && n < ((f - u) * (r - c)) / (p - c) + u && (o = !o);
  }
  return o;
}
function wF(t, e) {
  if (!e) return !1;
  const n = { x: t.clientX, y: t.clientY };
  return vF(n, e);
}
function Pa(t) {
  return (e) => (e.pointerType === "mouse" ? t(e) : void 0);
}
var xF = yk,
  bF = uy,
  SF = wk,
  CF = xk,
  kF = py,
  EF = bk,
  MF = hf,
  OF = Ck,
  TF = Ek,
  NF = Ok,
  AF = Nk,
  RF = Ak,
  PF = Rk,
  DF = Dk,
  IF = Lk,
  gy = "DropdownMenu",
  [LF, OB] = Ui(gy, [mk]),
  Ut = mk(),
  [$F, _k] = LF(gy),
  Fk = (t) => {
    const {
        __scopeDropdownMenu: e,
        children: n,
        dir: r,
        open: o,
        defaultOpen: i,
        onOpenChange: l,
        modal: u = !0,
      } = t,
      c = Ut(e),
      f = b.useRef(null),
      [p = !1, m] = Jg({ prop: o, defaultProp: i, onChange: l });
    return O.jsx($F, {
      scope: e,
      triggerId: Td(),
      triggerRef: f,
      contentId: Td(),
      open: p,
      onOpenChange: m,
      onOpenToggle: b.useCallback(() => m((y) => !y), [m]),
      modal: u,
      children: O.jsx(xF, {
        ...c,
        open: p,
        onOpenChange: m,
        dir: r,
        modal: u,
        children: n,
      }),
    });
  };
Fk.displayName = gy;
var zk = "DropdownMenuTrigger",
  jk = b.forwardRef((t, e) => {
    const { __scopeDropdownMenu: n, disabled: r = !1, ...o } = t,
      i = _k(zk, n),
      l = Ut(n);
    return O.jsx(bF, {
      asChild: !0,
      ...l,
      children: O.jsx(nt.button, {
        type: "button",
        id: i.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": i.open,
        "aria-controls": i.open ? i.contentId : void 0,
        "data-state": i.open ? "open" : "closed",
        "data-disabled": r ? "" : void 0,
        disabled: r,
        ...o,
        ref: Zd(e, i.triggerRef),
        onPointerDown: Oe(t.onPointerDown, (u) => {
          !r &&
            u.button === 0 &&
            u.ctrlKey === !1 &&
            (i.onOpenToggle(), i.open || u.preventDefault());
        }),
        onKeyDown: Oe(t.onKeyDown, (u) => {
          r ||
            (["Enter", " "].includes(u.key) && i.onOpenToggle(),
            u.key === "ArrowDown" && i.onOpenChange(!0),
            ["Enter", " ", "ArrowDown"].includes(u.key) && u.preventDefault());
        }),
      }),
    });
  });
jk.displayName = zk;
var _F = "DropdownMenuPortal",
  Bk = (t) => {
    const { __scopeDropdownMenu: e, ...n } = t,
      r = Ut(e);
    return O.jsx(SF, { ...r, ...n });
  };
Bk.displayName = _F;
var Hk = "DropdownMenuContent",
  Vk = b.forwardRef((t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t,
      o = _k(Hk, n),
      i = Ut(n),
      l = b.useRef(!1);
    return O.jsx(CF, {
      id: o.contentId,
      "aria-labelledby": o.triggerId,
      ...i,
      ...r,
      ref: e,
      onCloseAutoFocus: Oe(t.onCloseAutoFocus, (u) => {
        var c;
        l.current || (c = o.triggerRef.current) == null || c.focus(),
          (l.current = !1),
          u.preventDefault();
      }),
      onInteractOutside: Oe(t.onInteractOutside, (u) => {
        const c = u.detail.originalEvent,
          f = c.button === 0 && c.ctrlKey === !0,
          p = c.button === 2 || f;
        (!o.modal || p) && (l.current = !0);
      }),
      style: {
        ...t.style,
        "--radix-dropdown-menu-content-transform-origin":
          "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width":
          "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height":
          "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width":
          "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height":
          "var(--radix-popper-anchor-height)",
      },
    });
  });
Vk.displayName = Hk;
var FF = "DropdownMenuGroup",
  zF = b.forwardRef((t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t,
      o = Ut(n);
    return O.jsx(kF, { ...o, ...r, ref: e });
  });
zF.displayName = FF;
var jF = "DropdownMenuLabel",
  Wk = b.forwardRef((t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t,
      o = Ut(n);
    return O.jsx(EF, { ...o, ...r, ref: e });
  });
Wk.displayName = jF;
var BF = "DropdownMenuItem",
  Uk = b.forwardRef((t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t,
      o = Ut(n);
    return O.jsx(MF, { ...o, ...r, ref: e });
  });
Uk.displayName = BF;
var HF = "DropdownMenuCheckboxItem",
  Kk = b.forwardRef((t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t,
      o = Ut(n);
    return O.jsx(OF, { ...o, ...r, ref: e });
  });
Kk.displayName = HF;
var VF = "DropdownMenuRadioGroup",
  WF = b.forwardRef((t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t,
      o = Ut(n);
    return O.jsx(TF, { ...o, ...r, ref: e });
  });
WF.displayName = VF;
var UF = "DropdownMenuRadioItem",
  qk = b.forwardRef((t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t,
      o = Ut(n);
    return O.jsx(NF, { ...o, ...r, ref: e });
  });
qk.displayName = UF;
var KF = "DropdownMenuItemIndicator",
  Gk = b.forwardRef((t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t,
      o = Ut(n);
    return O.jsx(AF, { ...o, ...r, ref: e });
  });
Gk.displayName = KF;
var qF = "DropdownMenuSeparator",
  Jk = b.forwardRef((t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t,
      o = Ut(n);
    return O.jsx(RF, { ...o, ...r, ref: e });
  });
Jk.displayName = qF;
var GF = "DropdownMenuArrow",
  JF = b.forwardRef((t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t,
      o = Ut(n);
    return O.jsx(PF, { ...o, ...r, ref: e });
  });
JF.displayName = GF;
var QF = "DropdownMenuSubTrigger",
  Qk = b.forwardRef((t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t,
      o = Ut(n);
    return O.jsx(DF, { ...o, ...r, ref: e });
  });
Qk.displayName = QF;
var YF = "DropdownMenuSubContent",
  Yk = b.forwardRef((t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t,
      o = Ut(n);
    return O.jsx(IF, {
      ...o,
      ...r,
      ref: e,
      style: {
        ...t.style,
        "--radix-dropdown-menu-content-transform-origin":
          "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width":
          "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height":
          "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width":
          "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height":
          "var(--radix-popper-anchor-height)",
      },
    });
  });
Yk.displayName = YF;
var XF = Fk,
  ZF = jk,
  ez = Bk,
  Xk = Vk,
  Zk = Wk,
  eE = Uk,
  tE = Kk,
  nE = qk,
  rE = Gk,
  oE = Jk,
  iE = Qk,
  sE = Yk;
/**
 * @license lucide-react v0.473.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const tz = (t) => t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(),
  lE = (...t) =>
    t
      .filter((e, n, r) => !!e && e.trim() !== "" && r.indexOf(e) === n)
      .join(" ")
      .trim();
/**
 * @license lucide-react v0.473.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ var nz = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
};
/**
 * @license lucide-react v0.473.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const rz = b.forwardRef(
  (
    {
      color: t = "currentColor",
      size: e = 24,
      strokeWidth: n = 2,
      absoluteStrokeWidth: r,
      className: o = "",
      children: i,
      iconNode: l,
      ...u
    },
    c
  ) =>
    b.createElement(
      "svg",
      {
        ref: c,
        ...nz,
        width: e,
        height: e,
        stroke: t,
        strokeWidth: r ? (Number(n) * 24) / Number(e) : n,
        className: lE("lucide", o),
        ...u,
      },
      [
        ...l.map(([f, p]) => b.createElement(f, p)),
        ...(Array.isArray(i) ? i : [i]),
      ]
    )
);
/**
 * @license lucide-react v0.473.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const sl = (t, e) => {
  const n = b.forwardRef(({ className: r, ...o }, i) =>
    b.createElement(rz, {
      ref: i,
      iconNode: e,
      className: lE(`lucide-${tz(t)}`, r),
      ...o,
    })
  );
  return (n.displayName = `${t}`), n;
};
/**
 * @license lucide-react v0.473.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const oz = [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]],
  aE = sl("Check", oz);
/**
 * @license lucide-react v0.473.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const iz = [["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]],
  sz = sl("ChevronRight", iz);
/**
 * @license lucide-react v0.473.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const lz = [
    ["path", { d: "m7 15 5 5 5-5", key: "1hf1tw" }],
    ["path", { d: "m7 9 5-5 5 5", key: "sgt6xg" }],
  ],
  az = sl("ChevronsUpDown", lz);
/**
 * @license lucide-react v0.473.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const uz = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]],
  cz = sl("Circle", uz);
/**
 * @license lucide-react v0.473.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const dz = [
    ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
    ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }],
  ],
  fz = sl("Search", dz);
/**
 * @license lucide-react v0.473.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const pz = [
    ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
    ["path", { d: "m6 6 12 12", key: "d8bk6v" }],
  ],
  hz = sl("X", pz),
  uE = XF,
  cE = ZF,
  mz = b.forwardRef(({ className: t, inset: e, children: n, ...r }, o) =>
    O.jsxs(iE, {
      ref: o,
      className: Be(
        "flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
        e && "pl-8",
        t
      ),
      ...r,
      children: [n, O.jsx(sz, { className: "ml-auto" })],
    })
  );
mz.displayName = iE.displayName;
const gz = b.forwardRef(({ className: t, ...e }, n) =>
  O.jsx(sE, {
    ref: n,
    className: Be(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]",
      t
    ),
    ...e,
  })
);
gz.displayName = sE.displayName;
const yy = b.forwardRef(({ className: t, sideOffset: e = 4, ...n }, r) =>
  O.jsx(ez, {
    children: O.jsx(Xk, {
      ref: r,
      sideOffset: e,
      className: Be(
        "z-50 max-h-[var(--radix-dropdown-menu-content-available-height)] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]",
        t
      ),
      ...n,
    }),
  })
);
yy.displayName = Xk.displayName;
const Lo = b.forwardRef(({ className: t, inset: e, ...n }, r) =>
  O.jsx(eE, {
    ref: r,
    className: Be(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 cursor-pointer",
      e && "pl-8",
      t
    ),
    ...n,
  })
);
Lo.displayName = eE.displayName;
const yz = b.forwardRef(({ className: t, children: e, checked: n, ...r }, o) =>
  O.jsxs(tE, {
    ref: o,
    className: Be(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      t
    ),
    checked: n,
    ...r,
    children: [
      O.jsx("span", {
        className:
          "absolute left-2 flex h-3.5 w-3.5 items-center justify-center",
        children: O.jsx(rE, { children: O.jsx(aE, { className: "h-4 w-4" }) }),
      }),
      e,
    ],
  })
);
yz.displayName = tE.displayName;
const vz = b.forwardRef(({ className: t, children: e, ...n }, r) =>
  O.jsxs(nE, {
    ref: r,
    className: Be(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      t
    ),
    ...n,
    children: [
      O.jsx("span", {
        className:
          "absolute left-2 flex h-3.5 w-3.5 items-center justify-center",
        children: O.jsx(rE, {
          children: O.jsx(cz, { className: "h-2 w-2 fill-current" }),
        }),
      }),
      e,
    ],
  })
);
vz.displayName = nE.displayName;
const vy = b.forwardRef(({ className: t, inset: e, ...n }, r) =>
  O.jsx(Zk, {
    ref: r,
    className: Be("px-2 py-1.5 text-sm font-semibold", e && "pl-8", t),
    ...n,
  })
);
vy.displayName = Zk.displayName;
const wy = b.forwardRef(({ className: t, ...e }, n) =>
  O.jsx(oE, { ref: n, className: Be("-mx-1 my-1 h-px bg-muted", t), ...e })
);
wy.displayName = oE.displayName;
function wz() {
  const [t, e] = b.useState("16px"),
    { editor: n } = Qo();
  if (!n) return;
  const r = n.getAttributes("textStyle");
  function o(i) {
    const l = n.getAttributes("heading").level;
    l && n.chain().focus().toggleHeading({ level: l }).run(),
      e(i),
      pn(n, "setFontSize", i)();
  }
  return (
    b.useEffect(() => {
      const i = n.getAttributes("textStyle").fontSize;
      e(i ?? "16px");
    }, [n, r]),
    O.jsxs(uE, {
      children: [
        O.jsx(cE, {
          onClick: (i) => {
            console.log("e.isPropagationStopped(): ", i.isPropagationStopped()),
              i.stopPropagation();
          },
          children: O.jsx(bC, { children: t }),
        }),
        O.jsxs(yy, {
          children: [
            O.jsx(vy, { children: "Tamanho da fonte" }),
            O.jsx(wy, {}),
            O.jsx(Lo, { onClick: () => o("16px"), children: "16px" }),
            O.jsx(Lo, { onClick: () => o("20px"), children: "20px" }),
            O.jsx(Lo, { onClick: () => o("24px"), children: "24px" }),
          ],
        }),
      ],
    })
  );
}
function xz() {
  const [t, e] = b.useState("Normal"),
    { editor: n } = Qo();
  if (!n) return;
  const r = n.getAttributes("heading");
  function o(i) {
    n.chain().focus().unsetAllMarks().run(),
      i == 0
        ? (e("Normal"), pn(n, "setParagraph")())
        : (e(`Ttulo ${i}`), pn(n, "setHeading", { level: i })());
  }
  return (
    b.useEffect(() => {
      console.log("attr: ", r);
      const i = r.level;
      e(i ? `Ttulo ${i}` : "Normal");
    }, [n, r]),
    O.jsxs(uE, {
      children: [
        O.jsx(cE, { children: O.jsx(bC, { children: t }) }),
        O.jsxs(yy, {
          children: [
            O.jsx(vy, { children: "Ttulos" }),
            O.jsx(wy, {}),
            O.jsx(Lo, { onClick: () => o(0), children: "Normal" }),
            O.jsx(Lo, { onClick: () => o(1), children: "Ttulo 1" }),
            O.jsx(Lo, { onClick: () => o(2), children: "Ttulo 2" }),
            O.jsx(Lo, { onClick: () => o(3), children: "Ttulo 3" }),
          ],
        }),
      ],
    })
  );
}
function bz(t) {
  return Zn({
    tag: "svg",
    attr: { viewBox: "0 0 15 15", fill: "none" },
    child: [
      {
        tag: "path",
        attr: {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M2 7.5C2 7.22386 2.22386 7 2.5 7H12.5C12.7761 7 13 7.22386 13 7.5C13 7.77614 12.7761 8 12.5 8H2.5C2.22386 8 2 7.77614 2 7.5Z",
          fill: "currentColor",
        },
        child: [],
      },
    ],
  })(t);
}
function Sz() {
  const { editor: t } = Qo();
  if (!t) return;
  const e = (n) => pn(t, "setTextAlign", n);
  return O.jsxs(O.Fragment, {
    children: [
      O.jsx(fn, { onClick: e("justify"), children: O.jsx(AL, {}) }),
      O.jsx(fn, { onClick: e("left"), children: O.jsx(RL, {}) }),
      O.jsx(fn, { onClick: e("center"), children: O.jsx(NL, {}) }),
      O.jsx(fn, { onClick: e("right"), children: O.jsx(PL, {}) }),
    ],
  });
}
var Dx = 1,
  Cz = 0.9,
  kz = 0.8,
  Ez = 0.17,
  Qh = 0.1,
  Yh = 0.999,
  Mz = 0.9999,
  Oz = 0.99,
  Tz = /[\\\/_+.#"@\[\(\{&]/,
  Nz = /[\\\/_+.#"@\[\(\{&]/g,
  Az = /[\s-]/,
  dE = /[\s-]/g;
function qm(t, e, n, r, o, i, l) {
  if (i === e.length) return o === t.length ? Dx : Oz;
  var u = `${o},${i}`;
  if (l[u] !== void 0) return l[u];
  for (var c = r.charAt(i), f = n.indexOf(c, o), p = 0, m, y, v, x; f >= 0; )
    (m = qm(t, e, n, r, f + 1, i + 1, l)),
      m > p &&
        (f === o
          ? (m *= Dx)
          : Tz.test(t.charAt(f - 1))
          ? ((m *= kz),
            (v = t.slice(o, f - 1).match(Nz)),
            v && o > 0 && (m *= Math.pow(Yh, v.length)))
          : Az.test(t.charAt(f - 1))
          ? ((m *= Cz),
            (x = t.slice(o, f - 1).match(dE)),
            x && o > 0 && (m *= Math.pow(Yh, x.length)))
          : ((m *= Ez), o > 0 && (m *= Math.pow(Yh, f - o))),
        t.charAt(f) !== e.charAt(i) && (m *= Mz)),
      ((m < Qh && n.charAt(f - 1) === r.charAt(i + 1)) ||
        (r.charAt(i + 1) === r.charAt(i) && n.charAt(f - 1) !== r.charAt(i))) &&
        ((y = qm(t, e, n, r, f + 1, i + 2, l)), y * Qh > m && (m = y * Qh)),
      m > p && (p = m),
      (f = n.indexOf(c, f + 1));
  return (l[u] = p), p;
}
function Ix(t) {
  return t.toLowerCase().replace(dE, " ");
}
function Rz(t, e, n) {
  return (
    (t = n && n.length > 0 ? `${t + " " + n.join(" ")}` : t),
    qm(t, e, Ix(t), Ix(e), 0, 0, {})
  );
}
function Vt() {
  return (
    (Vt = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
          }
          return t;
        }),
    Vt.apply(null, arguments)
  );
}
function Bs(t, e, { checkForDefaultPrevented: n = !0 } = {}) {
  return function (o) {
    if ((t == null || t(o), n === !1 || !o.defaultPrevented))
      return e == null ? void 0 : e(o);
  };
}
function Pz(t, e) {
  typeof t == "function" ? t(e) : t != null && (t.current = e);
}
function fE(...t) {
  return (e) => t.forEach((n) => Pz(n, e));
}
function Ua(...t) {
  return b.useCallback(fE(...t), t);
}
function Dz(t, e = []) {
  let n = [];
  function r(i, l) {
    const u = b.createContext(l),
      c = n.length;
    n = [...n, l];
    function f(m) {
      const { scope: y, children: v, ...x } = m,
        S = (y == null ? void 0 : y[t][c]) || u,
        C = b.useMemo(() => x, Object.values(x));
      return b.createElement(S.Provider, { value: C }, v);
    }
    function p(m, y) {
      const v = (y == null ? void 0 : y[t][c]) || u,
        x = b.useContext(v);
      if (x) return x;
      if (l !== void 0) return l;
      throw new Error(`\`${m}\` must be used within \`${i}\``);
    }
    return (f.displayName = i + "Provider"), [f, p];
  }
  const o = () => {
    const i = n.map((l) => b.createContext(l));
    return function (u) {
      const c = (u == null ? void 0 : u[t]) || i;
      return b.useMemo(() => ({ [`__scope${t}`]: { ...u, [t]: c } }), [u, c]);
    };
  };
  return (o.scopeName = t), [r, Iz(o, ...e)];
}
function Iz(...t) {
  const e = t[0];
  if (t.length === 1) return e;
  const n = () => {
    const r = t.map((o) => ({ useScope: o(), scopeName: o.scopeName }));
    return function (i) {
      const l = r.reduce((u, { useScope: c, scopeName: f }) => {
        const m = c(i)[`__scope${f}`];
        return { ...u, ...m };
      }, {});
      return b.useMemo(() => ({ [`__scope${e.scopeName}`]: l }), [l]);
    };
  };
  return (n.scopeName = e.scopeName), n;
}
const Lz =
    globalThis != null && globalThis.document ? b.useLayoutEffect : () => {},
  $z = Yx.useId || (() => {});
let _z = 0;
function Xh(t) {
  const [e, n] = b.useState($z());
  return (
    Lz(() => {
      t || n((r) => r ?? String(_z++));
    }, [t]),
    t || (e ? `radix-${e}` : "")
  );
}
function pE(t) {
  const e = b.useRef(t);
  return (
    b.useEffect(() => {
      e.current = t;
    }),
    b.useMemo(
      () =>
        (...n) => {
          var r;
          return (r = e.current) === null || r === void 0
            ? void 0
            : r.call(e, ...n);
        },
      []
    )
  );
}
function Fz({ prop: t, defaultProp: e, onChange: n = () => {} }) {
  const [r, o] = zz({ defaultProp: e, onChange: n }),
    i = t !== void 0,
    l = i ? t : r,
    u = pE(n),
    c = b.useCallback(
      (f) => {
        if (i) {
          const m = typeof f == "function" ? f(t) : f;
          m !== t && u(m);
        } else o(f);
      },
      [i, t, o, u]
    );
  return [l, c];
}
function zz({ defaultProp: t, onChange: e }) {
  const n = b.useState(t),
    [r] = n,
    o = b.useRef(r),
    i = pE(e);
  return (
    b.useEffect(() => {
      o.current !== r && (i(r), (o.current = r));
    }, [r, o, i]),
    n
  );
}
const xy = b.forwardRef((t, e) => {
  const { children: n, ...r } = t,
    o = b.Children.toArray(n),
    i = o.find(Bz);
  if (i) {
    const l = i.props.children,
      u = o.map((c) =>
        c === i
          ? b.Children.count(l) > 1
            ? b.Children.only(null)
            : b.isValidElement(l)
            ? l.props.children
            : null
          : c
      );
    return b.createElement(
      Gm,
      Vt({}, r, { ref: e }),
      b.isValidElement(l) ? b.cloneElement(l, void 0, u) : null
    );
  }
  return b.createElement(Gm, Vt({}, r, { ref: e }), n);
});
xy.displayName = "Slot";
const Gm = b.forwardRef((t, e) => {
  const { children: n, ...r } = t;
  return b.isValidElement(n)
    ? b.cloneElement(n, { ...Hz(r, n.props), ref: e ? fE(e, n.ref) : n.ref })
    : b.Children.count(n) > 1
    ? b.Children.only(null)
    : null;
});
Gm.displayName = "SlotClone";
const jz = ({ children: t }) => b.createElement(b.Fragment, null, t);
function Bz(t) {
  return b.isValidElement(t) && t.type === jz;
}
function Hz(t, e) {
  const n = { ...e };
  for (const r in e) {
    const o = t[r],
      i = e[r];
    /^on[A-Z]/.test(r)
      ? o && i
        ? (n[r] = (...u) => {
            i(...u), o(...u);
          })
        : o && (n[r] = o)
      : r === "style"
      ? (n[r] = { ...o, ...i })
      : r === "className" && (n[r] = [o, i].filter(Boolean).join(" "));
  }
  return { ...t, ...n };
}
const Vz = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "span",
    "svg",
    "ul",
  ],
  Ln = Vz.reduce((t, e) => {
    const n = b.forwardRef((r, o) => {
      const { asChild: i, ...l } = r,
        u = i ? xy : e;
      return (
        b.useEffect(() => {
          window[Symbol.for("radix-ui")] = !0;
        }, []),
        b.createElement(u, Vt({}, l, { ref: o }))
      );
    });
    return (n.displayName = `Primitive.${e}`), { ...t, [e]: n };
  }, {});
function Wz(t, e) {
  t && Ba.flushSync(() => t.dispatchEvent(e));
}
function by(t) {
  const e = b.useRef(t);
  return (
    b.useEffect(() => {
      e.current = t;
    }),
    b.useMemo(
      () =>
        (...n) => {
          var r;
          return (r = e.current) === null || r === void 0
            ? void 0
            : r.call(e, ...n);
        },
      []
    )
  );
}
function Uz(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = by(t);
  b.useEffect(() => {
    const r = (o) => {
      o.key === "Escape" && n(o);
    };
    return (
      e.addEventListener("keydown", r),
      () => e.removeEventListener("keydown", r)
    );
  }, [n, e]);
}
const Jm = "dismissableLayer.update",
  Kz = "dismissableLayer.pointerDownOutside",
  qz = "dismissableLayer.focusOutside";
let Lx;
const Gz = b.createContext({
    layers: new Set(),
    layersWithOutsidePointerEventsDisabled: new Set(),
    branches: new Set(),
  }),
  Jz = b.forwardRef((t, e) => {
    var n;
    const {
        disableOutsidePointerEvents: r = !1,
        onEscapeKeyDown: o,
        onPointerDownOutside: i,
        onFocusOutside: l,
        onInteractOutside: u,
        onDismiss: c,
        ...f
      } = t,
      p = b.useContext(Gz),
      [m, y] = b.useState(null),
      v =
        (n = m == null ? void 0 : m.ownerDocument) !== null && n !== void 0
          ? n
          : globalThis == null
          ? void 0
          : globalThis.document,
      [, x] = b.useState({}),
      S = Ua(e, (H) => y(H)),
      C = Array.from(p.layers),
      [E] = [...p.layersWithOutsidePointerEventsDisabled].slice(-1),
      N = C.indexOf(E),
      $ = m ? C.indexOf(m) : -1,
      M = p.layersWithOutsidePointerEventsDisabled.size > 0,
      I = $ >= N,
      R = Qz((H) => {
        const U = H.target,
          re = [...p.branches].some((ce) => ce.contains(U));
        !I ||
          re ||
          (i == null || i(H),
          u == null || u(H),
          H.defaultPrevented || c == null || c());
      }, v),
      F = Yz((H) => {
        const U = H.target;
        [...p.branches].some((ce) => ce.contains(U)) ||
          (l == null || l(H),
          u == null || u(H),
          H.defaultPrevented || c == null || c());
      }, v);
    return (
      Uz((H) => {
        $ === p.layers.size - 1 &&
          (o == null || o(H),
          !H.defaultPrevented && c && (H.preventDefault(), c()));
      }, v),
      b.useEffect(() => {
        if (m)
          return (
            r &&
              (p.layersWithOutsidePointerEventsDisabled.size === 0 &&
                ((Lx = v.body.style.pointerEvents),
                (v.body.style.pointerEvents = "none")),
              p.layersWithOutsidePointerEventsDisabled.add(m)),
            p.layers.add(m),
            $x(),
            () => {
              r &&
                p.layersWithOutsidePointerEventsDisabled.size === 1 &&
                (v.body.style.pointerEvents = Lx);
            }
          );
      }, [m, v, r, p]),
      b.useEffect(
        () => () => {
          m &&
            (p.layers.delete(m),
            p.layersWithOutsidePointerEventsDisabled.delete(m),
            $x());
        },
        [m, p]
      ),
      b.useEffect(() => {
        const H = () => x({});
        return (
          document.addEventListener(Jm, H),
          () => document.removeEventListener(Jm, H)
        );
      }, []),
      b.createElement(
        Ln.div,
        Vt({}, f, {
          ref: S,
          style: {
            pointerEvents: M ? (I ? "auto" : "none") : void 0,
            ...t.style,
          },
          onFocusCapture: Bs(t.onFocusCapture, F.onFocusCapture),
          onBlurCapture: Bs(t.onBlurCapture, F.onBlurCapture),
          onPointerDownCapture: Bs(
            t.onPointerDownCapture,
            R.onPointerDownCapture
          ),
        })
      )
    );
  });
function Qz(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = by(t),
    r = b.useRef(!1),
    o = b.useRef(() => {});
  return (
    b.useEffect(() => {
      const i = (u) => {
          if (u.target && !r.current) {
            let p = function () {
              hE(Kz, n, f, { discrete: !0 });
            };
            var c = p;
            const f = { originalEvent: u };
            u.pointerType === "touch"
              ? (e.removeEventListener("click", o.current),
                (o.current = p),
                e.addEventListener("click", o.current, { once: !0 }))
              : p();
          } else e.removeEventListener("click", o.current);
          r.current = !1;
        },
        l = window.setTimeout(() => {
          e.addEventListener("pointerdown", i);
        }, 0);
      return () => {
        window.clearTimeout(l),
          e.removeEventListener("pointerdown", i),
          e.removeEventListener("click", o.current);
      };
    }, [e, n]),
    { onPointerDownCapture: () => (r.current = !0) }
  );
}
function Yz(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = by(t),
    r = b.useRef(!1);
  return (
    b.useEffect(() => {
      const o = (i) => {
        i.target &&
          !r.current &&
          hE(qz, n, { originalEvent: i }, { discrete: !1 });
      };
      return (
        e.addEventListener("focusin", o),
        () => e.removeEventListener("focusin", o)
      );
    }, [e, n]),
    {
      onFocusCapture: () => (r.current = !0),
      onBlurCapture: () => (r.current = !1),
    }
  );
}
function $x() {
  const t = new CustomEvent(Jm);
  document.dispatchEvent(t);
}
function hE(t, e, n, { discrete: r }) {
  const o = n.originalEvent.target,
    i = new CustomEvent(t, { bubbles: !1, cancelable: !0, detail: n });
  e && o.addEventListener(t, e, { once: !0 }),
    r ? Wz(o, i) : o.dispatchEvent(i);
}
function _x(t) {
  const e = b.useRef(t);
  return (
    b.useEffect(() => {
      e.current = t;
    }),
    b.useMemo(
      () =>
        (...n) => {
          var r;
          return (r = e.current) === null || r === void 0
            ? void 0
            : r.call(e, ...n);
        },
      []
    )
  );
}
const Zh = "focusScope.autoFocusOnMount",
  em = "focusScope.autoFocusOnUnmount",
  Fx = { bubbles: !1, cancelable: !0 },
  Xz = b.forwardRef((t, e) => {
    const {
        loop: n = !1,
        trapped: r = !1,
        onMountAutoFocus: o,
        onUnmountAutoFocus: i,
        ...l
      } = t,
      [u, c] = b.useState(null),
      f = _x(o),
      p = _x(i),
      m = b.useRef(null),
      y = Ua(e, (S) => c(S)),
      v = b.useRef({
        paused: !1,
        pause() {
          this.paused = !0;
        },
        resume() {
          this.paused = !1;
        },
      }).current;
    b.useEffect(() => {
      if (r) {
        let N = function (R) {
            if (v.paused || !u) return;
            const F = R.target;
            u.contains(F) ? (m.current = F) : ko(m.current, { select: !0 });
          },
          $ = function (R) {
            if (v.paused || !u) return;
            const F = R.relatedTarget;
            F !== null && (u.contains(F) || ko(m.current, { select: !0 }));
          },
          M = function (R) {
            if (document.activeElement === document.body)
              for (const H of R) H.removedNodes.length > 0 && ko(u);
          };
        var S = N,
          C = $,
          E = M;
        document.addEventListener("focusin", N),
          document.addEventListener("focusout", $);
        const I = new MutationObserver(M);
        return (
          u && I.observe(u, { childList: !0, subtree: !0 }),
          () => {
            document.removeEventListener("focusin", N),
              document.removeEventListener("focusout", $),
              I.disconnect();
          }
        );
      }
    }, [r, u, v.paused]),
      b.useEffect(() => {
        if (u) {
          jx.add(v);
          const S = document.activeElement;
          if (!u.contains(S)) {
            const E = new CustomEvent(Zh, Fx);
            u.addEventListener(Zh, f),
              u.dispatchEvent(E),
              E.defaultPrevented ||
                (Zz(oj(mE(u)), { select: !0 }),
                document.activeElement === S && ko(u));
          }
          return () => {
            u.removeEventListener(Zh, f),
              setTimeout(() => {
                const E = new CustomEvent(em, Fx);
                u.addEventListener(em, p),
                  u.dispatchEvent(E),
                  E.defaultPrevented || ko(S ?? document.body, { select: !0 }),
                  u.removeEventListener(em, p),
                  jx.remove(v);
              }, 0);
          };
        }
      }, [u, f, p, v]);
    const x = b.useCallback(
      (S) => {
        if ((!n && !r) || v.paused) return;
        const C = S.key === "Tab" && !S.altKey && !S.ctrlKey && !S.metaKey,
          E = document.activeElement;
        if (C && E) {
          const N = S.currentTarget,
            [$, M] = ej(N);
          $ && M
            ? !S.shiftKey && E === M
              ? (S.preventDefault(), n && ko($, { select: !0 }))
              : S.shiftKey &&
                E === $ &&
                (S.preventDefault(), n && ko(M, { select: !0 }))
            : E === N && S.preventDefault();
        }
      },
      [n, r, v.paused]
    );
    return b.createElement(
      Ln.div,
      Vt({ tabIndex: -1 }, l, { ref: y, onKeyDown: x })
    );
  });
function Zz(t, { select: e = !1 } = {}) {
  const n = document.activeElement;
  for (const r of t)
    if ((ko(r, { select: e }), document.activeElement !== n)) return;
}
function ej(t) {
  const e = mE(t),
    n = zx(e, t),
    r = zx(e.reverse(), t);
  return [n, r];
}
function mE(t) {
  const e = [],
    n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (r) => {
        const o = r.tagName === "INPUT" && r.type === "hidden";
        return r.disabled || r.hidden || o
          ? NodeFilter.FILTER_SKIP
          : r.tabIndex >= 0
          ? NodeFilter.FILTER_ACCEPT
          : NodeFilter.FILTER_SKIP;
      },
    });
  for (; n.nextNode(); ) e.push(n.currentNode);
  return e;
}
function zx(t, e) {
  for (const n of t) if (!tj(n, { upTo: e })) return n;
}
function tj(t, { upTo: e }) {
  if (getComputedStyle(t).visibility === "hidden") return !0;
  for (; t; ) {
    if (e !== void 0 && t === e) return !1;
    if (getComputedStyle(t).display === "none") return !0;
    t = t.parentElement;
  }
  return !1;
}
function nj(t) {
  return t instanceof HTMLInputElement && "select" in t;
}
function ko(t, { select: e = !1 } = {}) {
  if (t && t.focus) {
    const n = document.activeElement;
    t.focus({ preventScroll: !0 }), t !== n && nj(t) && e && t.select();
  }
}
const jx = rj();
function rj() {
  let t = [];
  return {
    add(e) {
      const n = t[0];
      e !== n && (n == null || n.pause()), (t = Bx(t, e)), t.unshift(e);
    },
    remove(e) {
      var n;
      (t = Bx(t, e)), (n = t[0]) === null || n === void 0 || n.resume();
    },
  };
}
function Bx(t, e) {
  const n = [...t],
    r = n.indexOf(e);
  return r !== -1 && n.splice(r, 1), n;
}
function oj(t) {
  return t.filter((e) => e.tagName !== "A");
}
const ij = b.forwardRef((t, e) => {
    var n;
    const {
      container: r = globalThis == null ||
      (n = globalThis.document) === null ||
      n === void 0
        ? void 0
        : n.body,
      ...o
    } = t;
    return r
      ? Ig.createPortal(b.createElement(Ln.div, Vt({}, o, { ref: e })), r)
      : null;
  }),
  Hx = globalThis != null && globalThis.document ? b.useLayoutEffect : () => {};
function sj(t, e) {
  return b.useReducer((n, r) => {
    const o = e[n][r];
    return o ?? n;
  }, t);
}
const mf = (t) => {
  const { present: e, children: n } = t,
    r = lj(e),
    o =
      typeof n == "function" ? n({ present: r.isPresent }) : b.Children.only(n),
    i = Ua(r.ref, o.ref);
  return typeof n == "function" || r.isPresent
    ? b.cloneElement(o, { ref: i })
    : null;
};
mf.displayName = "Presence";
function lj(t) {
  const [e, n] = b.useState(),
    r = b.useRef({}),
    o = b.useRef(t),
    i = b.useRef("none"),
    l = t ? "mounted" : "unmounted",
    [u, c] = sj(l, {
      mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" },
      unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" },
      unmounted: { MOUNT: "mounted" },
    });
  return (
    b.useEffect(() => {
      const f = kc(r.current);
      i.current = u === "mounted" ? f : "none";
    }, [u]),
    Hx(() => {
      const f = r.current,
        p = o.current;
      if (p !== t) {
        const y = i.current,
          v = kc(f);
        t
          ? c("MOUNT")
          : v === "none" || (f == null ? void 0 : f.display) === "none"
          ? c("UNMOUNT")
          : c(p && y !== v ? "ANIMATION_OUT" : "UNMOUNT"),
          (o.current = t);
      }
    }, [t, c]),
    Hx(() => {
      if (e) {
        const f = (m) => {
            const v = kc(r.current).includes(m.animationName);
            m.target === e && v && Ba.flushSync(() => c("ANIMATION_END"));
          },
          p = (m) => {
            m.target === e && (i.current = kc(r.current));
          };
        return (
          e.addEventListener("animationstart", p),
          e.addEventListener("animationcancel", f),
          e.addEventListener("animationend", f),
          () => {
            e.removeEventListener("animationstart", p),
              e.removeEventListener("animationcancel", f),
              e.removeEventListener("animationend", f);
          }
        );
      } else c("ANIMATION_END");
    }, [e, c]),
    {
      isPresent: ["mounted", "unmountSuspended"].includes(u),
      ref: b.useCallback((f) => {
        f && (r.current = getComputedStyle(f)), n(f);
      }, []),
    }
  );
}
function kc(t) {
  return (t == null ? void 0 : t.animationName) || "none";
}
let tm = 0;
function aj() {
  b.useEffect(() => {
    var t, e;
    const n = document.querySelectorAll("[data-radix-focus-guard]");
    return (
      document.body.insertAdjacentElement(
        "afterbegin",
        (t = n[0]) !== null && t !== void 0 ? t : Vx()
      ),
      document.body.insertAdjacentElement(
        "beforeend",
        (e = n[1]) !== null && e !== void 0 ? e : Vx()
      ),
      tm++,
      () => {
        tm === 1 &&
          document
            .querySelectorAll("[data-radix-focus-guard]")
            .forEach((r) => r.remove()),
          tm--;
      }
    );
  }, []);
}
function Vx() {
  const t = document.createElement("span");
  return (
    t.setAttribute("data-radix-focus-guard", ""),
    (t.tabIndex = 0),
    (t.style.cssText =
      "outline: none; opacity: 0; position: fixed; pointer-events: none"),
    t
  );
}
var gE = sk(),
  nm = function () {},
  gf = b.forwardRef(function (t, e) {
    var n = b.useRef(null),
      r = b.useState({
        onScrollCapture: nm,
        onWheelCapture: nm,
        onTouchMoveCapture: nm,
      }),
      o = r[0],
      i = r[1],
      l = t.forwardProps,
      u = t.children,
      c = t.className,
      f = t.removeScrollBar,
      p = t.enabled,
      m = t.shards,
      y = t.sideCar,
      v = t.noIsolation,
      x = t.inert,
      S = t.allowPinchZoom,
      C = t.as,
      E = C === void 0 ? "div" : C,
      N = ly(t, [
        "forwardProps",
        "children",
        "className",
        "removeScrollBar",
        "enabled",
        "shards",
        "sideCar",
        "noIsolation",
        "inert",
        "allowPinchZoom",
        "as",
      ]),
      $ = y,
      M = ik([n, e]),
      I = Dt(Dt({}, N), o);
    return b.createElement(
      b.Fragment,
      null,
      p &&
        b.createElement($, {
          sideCar: gE,
          removeScrollBar: f,
          shards: m,
          noIsolation: v,
          inert: x,
          setCallbacks: i,
          allowPinchZoom: !!S,
          lockRef: n,
        }),
      l
        ? b.cloneElement(b.Children.only(u), Dt(Dt({}, I), { ref: M }))
        : b.createElement(E, Dt({}, I, { className: c, ref: M }), u)
    );
  });
gf.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 };
gf.classNames = { fullWidth: ha, zeroRight: pa };
var Qm = !1;
if (typeof window < "u")
  try {
    var Ec = Object.defineProperty({}, "passive", {
      get: function () {
        return (Qm = !0), !0;
      },
    });
    window.addEventListener("test", Ec, Ec),
      window.removeEventListener("test", Ec, Ec);
  } catch {
    Qm = !1;
  }
var Ms = Qm ? { passive: !1 } : !1,
  uj = function (t) {
    return t.tagName === "TEXTAREA";
  },
  yE = function (t, e) {
    var n = window.getComputedStyle(t);
    return (
      n[e] !== "hidden" &&
      !(n.overflowY === n.overflowX && !uj(t) && n[e] === "visible")
    );
  },
  cj = function (t) {
    return yE(t, "overflowY");
  },
  dj = function (t) {
    return yE(t, "overflowX");
  },
  Wx = function (t, e) {
    var n = e;
    do {
      typeof ShadowRoot < "u" && n instanceof ShadowRoot && (n = n.host);
      var r = vE(t, n);
      if (r) {
        var o = wE(t, n),
          i = o[1],
          l = o[2];
        if (i > l) return !0;
      }
      n = n.parentNode;
    } while (n && n !== document.body);
    return !1;
  },
  fj = function (t) {
    var e = t.scrollTop,
      n = t.scrollHeight,
      r = t.clientHeight;
    return [e, n, r];
  },
  pj = function (t) {
    var e = t.scrollLeft,
      n = t.scrollWidth,
      r = t.clientWidth;
    return [e, n, r];
  },
  vE = function (t, e) {
    return t === "v" ? cj(e) : dj(e);
  },
  wE = function (t, e) {
    return t === "v" ? fj(e) : pj(e);
  },
  hj = function (t, e) {
    return t === "h" && e === "rtl" ? -1 : 1;
  },
  mj = function (t, e, n, r, o) {
    var i = hj(t, window.getComputedStyle(e).direction),
      l = i * r,
      u = n.target,
      c = e.contains(u),
      f = !1,
      p = l > 0,
      m = 0,
      y = 0;
    do {
      var v = wE(t, u),
        x = v[0],
        S = v[1],
        C = v[2],
        E = S - C - i * x;
      (x || E) && vE(t, u) && ((m += E), (y += x)), (u = u.parentNode);
    } while ((!c && u !== document.body) || (c && (e.contains(u) || e === u)));
    return ((p && m === 0) || (!p && y === 0)) && (f = !0), f;
  },
  Mc = function (t) {
    return "changedTouches" in t
      ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY]
      : [0, 0];
  },
  Ux = function (t) {
    return [t.deltaX, t.deltaY];
  },
  Kx = function (t) {
    return t && "current" in t ? t.current : t;
  },
  gj = function (t, e) {
    return t[0] === e[0] && t[1] === e[1];
  },
  yj = function (t) {
    return `
  .block-interactivity-`
      .concat(
        t,
        ` {pointer-events: none;}
  .allow-interactivity-`
      )
      .concat(
        t,
        ` {pointer-events: all;}
`
      );
  },
  vj = 0,
  Os = [];
function wj(t) {
  var e = b.useRef([]),
    n = b.useRef([0, 0]),
    r = b.useRef(),
    o = b.useState(vj++)[0],
    i = b.useState(function () {
      return ay();
    })[0],
    l = b.useRef(t);
  b.useEffect(
    function () {
      l.current = t;
    },
    [t]
  ),
    b.useEffect(
      function () {
        if (t.inert) {
          document.body.classList.add("block-interactivity-".concat(o));
          var S = ok([t.lockRef.current], (t.shards || []).map(Kx), !0).filter(
            Boolean
          );
          return (
            S.forEach(function (C) {
              return C.classList.add("allow-interactivity-".concat(o));
            }),
            function () {
              document.body.classList.remove("block-interactivity-".concat(o)),
                S.forEach(function (C) {
                  return C.classList.remove("allow-interactivity-".concat(o));
                });
            }
          );
        }
      },
      [t.inert, t.lockRef.current, t.shards]
    );
  var u = b.useCallback(function (S, C) {
      if ("touches" in S && S.touches.length === 2)
        return !l.current.allowPinchZoom;
      var E = Mc(S),
        N = n.current,
        $ = "deltaX" in S ? S.deltaX : N[0] - E[0],
        M = "deltaY" in S ? S.deltaY : N[1] - E[1],
        I,
        R = S.target,
        F = Math.abs($) > Math.abs(M) ? "h" : "v";
      if ("touches" in S && F === "h" && R.type === "range") return !1;
      var H = Wx(F, R);
      if (!H) return !0;
      if ((H ? (I = F) : ((I = F === "v" ? "h" : "v"), (H = Wx(F, R))), !H))
        return !1;
      if (
        (!r.current && "changedTouches" in S && ($ || M) && (r.current = I), !I)
      )
        return !0;
      var U = r.current || I;
      return mj(U, C, S, U === "h" ? $ : M);
    }, []),
    c = b.useCallback(function (S) {
      var C = S;
      if (!(!Os.length || Os[Os.length - 1] !== i)) {
        var E = "deltaY" in C ? Ux(C) : Mc(C),
          N = e.current.filter(function (I) {
            return I.name === C.type && I.target === C.target && gj(I.delta, E);
          })[0];
        if (N && N.should) {
          C.cancelable && C.preventDefault();
          return;
        }
        if (!N) {
          var $ = (l.current.shards || [])
              .map(Kx)
              .filter(Boolean)
              .filter(function (I) {
                return I.contains(C.target);
              }),
            M = $.length > 0 ? u(C, $[0]) : !l.current.noIsolation;
          M && C.cancelable && C.preventDefault();
        }
      }
    }, []),
    f = b.useCallback(function (S, C, E, N) {
      var $ = { name: S, delta: C, target: E, should: N };
      e.current.push($),
        setTimeout(function () {
          e.current = e.current.filter(function (M) {
            return M !== $;
          });
        }, 1);
    }, []),
    p = b.useCallback(function (S) {
      (n.current = Mc(S)), (r.current = void 0);
    }, []),
    m = b.useCallback(function (S) {
      f(S.type, Ux(S), S.target, u(S, t.lockRef.current));
    }, []),
    y = b.useCallback(function (S) {
      f(S.type, Mc(S), S.target, u(S, t.lockRef.current));
    }, []);
  b.useEffect(function () {
    return (
      Os.push(i),
      t.setCallbacks({
        onScrollCapture: m,
        onWheelCapture: m,
        onTouchMoveCapture: y,
      }),
      document.addEventListener("wheel", c, Ms),
      document.addEventListener("touchmove", c, Ms),
      document.addEventListener("touchstart", p, Ms),
      function () {
        (Os = Os.filter(function (S) {
          return S !== i;
        })),
          document.removeEventListener("wheel", c, Ms),
          document.removeEventListener("touchmove", c, Ms),
          document.removeEventListener("touchstart", p, Ms);
      }
    );
  }, []);
  var v = t.removeScrollBar,
    x = t.inert;
  return b.createElement(
    b.Fragment,
    null,
    x ? b.createElement(i, { styles: yj(o) }) : null,
    v ? b.createElement(ck, { gapMode: "margin" }) : null
  );
}
const xj = ak(gE, wj);
var xE = b.forwardRef(function (t, e) {
  return b.createElement(gf, Dt({}, t, { ref: e, sideCar: xj }));
});
xE.classNames = gf.classNames;
const bE = "Dialog",
  [SE, TB] = Dz(bE),
  [bj, Gi] = SE(bE),
  Sj = (t) => {
    const {
        __scopeDialog: e,
        children: n,
        open: r,
        defaultOpen: o,
        onOpenChange: i,
        modal: l = !0,
      } = t,
      u = b.useRef(null),
      c = b.useRef(null),
      [f = !1, p] = Fz({ prop: r, defaultProp: o, onChange: i });
    return b.createElement(
      bj,
      {
        scope: e,
        triggerRef: u,
        contentRef: c,
        contentId: Xh(),
        titleId: Xh(),
        descriptionId: Xh(),
        open: f,
        onOpenChange: p,
        onOpenToggle: b.useCallback(() => p((m) => !m), [p]),
        modal: l,
      },
      n
    );
  },
  CE = "DialogPortal",
  [Cj, kE] = SE(CE, { forceMount: void 0 }),
  kj = (t) => {
    const { __scopeDialog: e, forceMount: n, children: r, container: o } = t,
      i = Gi(CE, e);
    return b.createElement(
      Cj,
      { scope: e, forceMount: n },
      b.Children.map(r, (l) =>
        b.createElement(
          mf,
          { present: n || i.open },
          b.createElement(ij, { asChild: !0, container: o }, l)
        )
      )
    );
  },
  Ym = "DialogOverlay",
  Ej = b.forwardRef((t, e) => {
    const n = kE(Ym, t.__scopeDialog),
      { forceMount: r = n.forceMount, ...o } = t,
      i = Gi(Ym, t.__scopeDialog);
    return i.modal
      ? b.createElement(
          mf,
          { present: r || i.open },
          b.createElement(Mj, Vt({}, o, { ref: e }))
        )
      : null;
  }),
  Mj = b.forwardRef((t, e) => {
    const { __scopeDialog: n, ...r } = t,
      o = Gi(Ym, n);
    return b.createElement(
      xE,
      { as: xy, allowPinchZoom: !0, shards: [o.contentRef] },
      b.createElement(
        Ln.div,
        Vt({ "data-state": ME(o.open) }, r, {
          ref: e,
          style: { pointerEvents: "auto", ...r.style },
        })
      )
    );
  }),
  Da = "DialogContent",
  Oj = b.forwardRef((t, e) => {
    const n = kE(Da, t.__scopeDialog),
      { forceMount: r = n.forceMount, ...o } = t,
      i = Gi(Da, t.__scopeDialog);
    return b.createElement(
      mf,
      { present: r || i.open },
      i.modal
        ? b.createElement(Tj, Vt({}, o, { ref: e }))
        : b.createElement(Nj, Vt({}, o, { ref: e }))
    );
  }),
  Tj = b.forwardRef((t, e) => {
    const n = Gi(Da, t.__scopeDialog),
      r = b.useRef(null),
      o = Ua(e, n.contentRef, r);
    return (
      b.useEffect(() => {
        const i = r.current;
        if (i) return cf(i);
      }, []),
      b.createElement(
        EE,
        Vt({}, t, {
          ref: o,
          trapFocus: n.open,
          disableOutsidePointerEvents: !0,
          onCloseAutoFocus: Bs(t.onCloseAutoFocus, (i) => {
            var l;
            i.preventDefault(),
              (l = n.triggerRef.current) === null || l === void 0 || l.focus();
          }),
          onPointerDownOutside: Bs(t.onPointerDownOutside, (i) => {
            const l = i.detail.originalEvent,
              u = l.button === 0 && l.ctrlKey === !0;
            (l.button === 2 || u) && i.preventDefault();
          }),
          onFocusOutside: Bs(t.onFocusOutside, (i) => i.preventDefault()),
        })
      )
    );
  }),
  Nj = b.forwardRef((t, e) => {
    const n = Gi(Da, t.__scopeDialog),
      r = b.useRef(!1),
      o = b.useRef(!1);
    return b.createElement(
      EE,
      Vt({}, t, {
        ref: e,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (i) => {
          var l;
          if (
            ((l = t.onCloseAutoFocus) === null || l === void 0 || l.call(t, i),
            !i.defaultPrevented)
          ) {
            var u;
            r.current ||
              (u = n.triggerRef.current) === null ||
              u === void 0 ||
              u.focus(),
              i.preventDefault();
          }
          (r.current = !1), (o.current = !1);
        },
        onInteractOutside: (i) => {
          var l, u;
          (l = t.onInteractOutside) === null || l === void 0 || l.call(t, i),
            i.defaultPrevented ||
              ((r.current = !0),
              i.detail.originalEvent.type === "pointerdown" &&
                (o.current = !0));
          const c = i.target;
          ((u = n.triggerRef.current) === null || u === void 0
            ? void 0
            : u.contains(c)) && i.preventDefault(),
            i.detail.originalEvent.type === "focusin" &&
              o.current &&
              i.preventDefault();
        },
      })
    );
  }),
  EE = b.forwardRef((t, e) => {
    const {
        __scopeDialog: n,
        trapFocus: r,
        onOpenAutoFocus: o,
        onCloseAutoFocus: i,
        ...l
      } = t,
      u = Gi(Da, n),
      c = b.useRef(null),
      f = Ua(e, c);
    return (
      aj(),
      b.createElement(
        b.Fragment,
        null,
        b.createElement(
          Xz,
          {
            asChild: !0,
            loop: !0,
            trapped: r,
            onMountAutoFocus: o,
            onUnmountAutoFocus: i,
          },
          b.createElement(
            Jz,
            Vt(
              {
                role: "dialog",
                id: u.contentId,
                "aria-describedby": u.descriptionId,
                "aria-labelledby": u.titleId,
                "data-state": ME(u.open),
              },
              l,
              { ref: f, onDismiss: () => u.onOpenChange(!1) }
            )
          )
        ),
        !1
      )
    );
  });
function ME(t) {
  return t ? "open" : "closed";
}
const Aj = Sj,
  Rj = kj,
  Pj = Ej,
  Dj = Oj;
var Jl = '[cmdk-group=""]',
  rm = '[cmdk-group-items=""]',
  Ij = '[cmdk-group-heading=""]',
  Sy = '[cmdk-item=""]',
  qx = `${Sy}:not([aria-disabled="true"])`,
  Xm = "cmdk-item-select",
  Ci = "data-value",
  Lj = (t, e, n) => Rz(t, e, n),
  OE = b.createContext(void 0),
  Ka = () => b.useContext(OE),
  TE = b.createContext(void 0),
  Cy = () => b.useContext(TE),
  NE = b.createContext(void 0),
  AE = b.forwardRef((t, e) => {
    let n = Ps(() => {
        var A, X;
        return {
          search: "",
          value:
            (X = (A = t.value) != null ? A : t.defaultValue) != null ? X : "",
          filtered: { count: 0, items: new Map(), groups: new Set() },
        };
      }),
      r = Ps(() => new Set()),
      o = Ps(() => new Map()),
      i = Ps(() => new Map()),
      l = Ps(() => new Set()),
      u = RE(t),
      {
        label: c,
        children: f,
        value: p,
        onValueChange: m,
        filter: y,
        shouldFilter: v,
        loop: x,
        disablePointerSelection: S = !1,
        vimBindings: C = !0,
        ...E
      } = t,
      N = b.useId(),
      $ = b.useId(),
      M = b.useId(),
      I = b.useRef(null),
      R = Kj();
    Bi(() => {
      if (p !== void 0) {
        let A = p.trim();
        (n.current.value = A), F.emit();
      }
    }, [p]),
      Bi(() => {
        R(6, le);
      }, []);
    let F = b.useMemo(
        () => ({
          subscribe: (A) => (l.current.add(A), () => l.current.delete(A)),
          snapshot: () => n.current,
          setState: (A, X, ne) => {
            var Q, ie, he;
            if (!Object.is(n.current[A], X)) {
              if (((n.current[A] = X), A === "search")) ee(), re(), R(1, ce);
              else if (
                A === "value" &&
                (ne || R(5, le),
                ((Q = u.current) == null ? void 0 : Q.value) !== void 0)
              ) {
                let we = X ?? "";
                (he = (ie = u.current).onValueChange) == null ||
                  he.call(ie, we);
                return;
              }
              F.emit();
            }
          },
          emit: () => {
            l.current.forEach((A) => A());
          },
        }),
        []
      ),
      H = b.useMemo(
        () => ({
          value: (A, X, ne) => {
            var Q;
            X !== ((Q = i.current.get(A)) == null ? void 0 : Q.value) &&
              (i.current.set(A, { value: X, keywords: ne }),
              n.current.filtered.items.set(A, U(X, ne)),
              R(2, () => {
                re(), F.emit();
              }));
          },
          item: (A, X) => (
            r.current.add(A),
            X &&
              (o.current.has(X)
                ? o.current.get(X).add(A)
                : o.current.set(X, new Set([A]))),
            R(3, () => {
              ee(), re(), n.current.value || ce(), F.emit();
            }),
            () => {
              i.current.delete(A),
                r.current.delete(A),
                n.current.filtered.items.delete(A);
              let ne = de();
              R(4, () => {
                ee(),
                  (ne == null ? void 0 : ne.getAttribute("id")) === A && ce(),
                  F.emit();
              });
            }
          ),
          group: (A) => (
            o.current.has(A) || o.current.set(A, new Set()),
            () => {
              i.current.delete(A), o.current.delete(A);
            }
          ),
          filter: () => u.current.shouldFilter,
          label: c || t["aria-label"],
          disablePointerSelection: S,
          listId: N,
          inputId: M,
          labelId: $,
          listInnerRef: I,
        }),
        []
      );
    function U(A, X) {
      var ne, Q;
      let ie =
        (Q = (ne = u.current) == null ? void 0 : ne.filter) != null ? Q : Lj;
      return A ? ie(A, n.current.search, X) : 0;
    }
    function re() {
      if (!n.current.search || u.current.shouldFilter === !1) return;
      let A = n.current.filtered.items,
        X = [];
      n.current.filtered.groups.forEach((Q) => {
        let ie = o.current.get(Q),
          he = 0;
        ie.forEach((we) => {
          let be = A.get(we);
          he = Math.max(be, he);
        }),
          X.push([Q, he]);
      });
      let ne = I.current;
      xe()
        .sort((Q, ie) => {
          var he, we;
          let be = Q.getAttribute("id"),
            $e = ie.getAttribute("id");
          return (
            ((he = A.get($e)) != null ? he : 0) -
            ((we = A.get(be)) != null ? we : 0)
          );
        })
        .forEach((Q) => {
          let ie = Q.closest(rm);
          ie
            ? ie.appendChild(
                Q.parentElement === ie ? Q : Q.closest(`${rm} > *`)
              )
            : ne.appendChild(
                Q.parentElement === ne ? Q : Q.closest(`${rm} > *`)
              );
        }),
        X.sort((Q, ie) => ie[1] - Q[1]).forEach((Q) => {
          let ie = I.current.querySelector(
            `${Jl}[${Ci}="${encodeURIComponent(Q[0])}"]`
          );
          ie == null || ie.parentElement.appendChild(ie);
        });
    }
    function ce() {
      let A = xe().find((ne) => ne.getAttribute("aria-disabled") !== "true"),
        X = A == null ? void 0 : A.getAttribute(Ci);
      F.setState("value", X || void 0);
    }
    function ee() {
      var A, X, ne, Q;
      if (!n.current.search || u.current.shouldFilter === !1) {
        n.current.filtered.count = r.current.size;
        return;
      }
      n.current.filtered.groups = new Set();
      let ie = 0;
      for (let he of r.current) {
        let we =
            (X = (A = i.current.get(he)) == null ? void 0 : A.value) != null
              ? X
              : "",
          be =
            (Q = (ne = i.current.get(he)) == null ? void 0 : ne.keywords) !=
            null
              ? Q
              : [],
          $e = U(we, be);
        n.current.filtered.items.set(he, $e), $e > 0 && ie++;
      }
      for (let [he, we] of o.current)
        for (let be of we)
          if (n.current.filtered.items.get(be) > 0) {
            n.current.filtered.groups.add(he);
            break;
          }
      n.current.filtered.count = ie;
    }
    function le() {
      var A, X, ne;
      let Q = de();
      Q &&
        (((A = Q.parentElement) == null ? void 0 : A.firstChild) === Q &&
          ((ne = (X = Q.closest(Jl)) == null ? void 0 : X.querySelector(Ij)) ==
            null ||
            ne.scrollIntoView({ block: "nearest" })),
        Q.scrollIntoView({ block: "nearest" }));
    }
    function de() {
      var A;
      return (A = I.current) == null
        ? void 0
        : A.querySelector(`${Sy}[aria-selected="true"]`);
    }
    function xe() {
      var A;
      return Array.from(
        (A = I.current) == null ? void 0 : A.querySelectorAll(qx)
      );
    }
    function oe(A) {
      let X = xe()[A];
      X && F.setState("value", X.getAttribute(Ci));
    }
    function se(A) {
      var X;
      let ne = de(),
        Q = xe(),
        ie = Q.findIndex((we) => we === ne),
        he = Q[ie + A];
      (X = u.current) != null &&
        X.loop &&
        (he =
          ie + A < 0
            ? Q[Q.length - 1]
            : ie + A === Q.length
            ? Q[0]
            : Q[ie + A]),
        he && F.setState("value", he.getAttribute(Ci));
    }
    function B(A) {
      let X = de(),
        ne = X == null ? void 0 : X.closest(Jl),
        Q;
      for (; ne && !Q; )
        (ne = A > 0 ? Wj(ne, Jl) : Uj(ne, Jl)),
          (Q = ne == null ? void 0 : ne.querySelector(qx));
      Q ? F.setState("value", Q.getAttribute(Ci)) : se(A);
    }
    let V = () => oe(xe().length - 1),
      K = (A) => {
        A.preventDefault(), A.metaKey ? V() : A.altKey ? B(1) : se(1);
      },
      D = (A) => {
        A.preventDefault(), A.metaKey ? oe(0) : A.altKey ? B(-1) : se(-1);
      };
    return b.createElement(
      Ln.div,
      {
        ref: e,
        tabIndex: -1,
        ...E,
        "cmdk-root": "",
        onKeyDown: (A) => {
          var X;
          if (((X = E.onKeyDown) == null || X.call(E, A), !A.defaultPrevented))
            switch (A.key) {
              case "n":
              case "j": {
                C && A.ctrlKey && K(A);
                break;
              }
              case "ArrowDown": {
                K(A);
                break;
              }
              case "p":
              case "k": {
                C && A.ctrlKey && D(A);
                break;
              }
              case "ArrowUp": {
                D(A);
                break;
              }
              case "Home": {
                A.preventDefault(), oe(0);
                break;
              }
              case "End": {
                A.preventDefault(), V();
                break;
              }
              case "Enter":
                if (!A.nativeEvent.isComposing && A.keyCode !== 229) {
                  A.preventDefault();
                  let ne = de();
                  if (ne) {
                    let Q = new Event(Xm);
                    ne.dispatchEvent(Q);
                  }
                }
            }
        },
      },
      b.createElement(
        "label",
        { "cmdk-label": "", htmlFor: H.inputId, id: H.labelId, style: Gj },
        c
      ),
      yf(t, (A) =>
        b.createElement(
          TE.Provider,
          { value: F },
          b.createElement(OE.Provider, { value: H }, A)
        )
      )
    );
  }),
  $j = b.forwardRef((t, e) => {
    var n, r;
    let o = b.useId(),
      i = b.useRef(null),
      l = b.useContext(NE),
      u = Ka(),
      c = RE(t),
      f =
        (r = (n = c.current) == null ? void 0 : n.forceMount) != null
          ? r
          : l == null
          ? void 0
          : l.forceMount;
    Bi(() => {
      if (!f) return u.item(o, l == null ? void 0 : l.id);
    }, [f]);
    let p = PE(o, i, [t.value, t.children, i], t.keywords),
      m = Cy(),
      y = Hi((R) => R.value && R.value === p.current),
      v = Hi((R) =>
        f || u.filter() === !1
          ? !0
          : R.search
          ? R.filtered.items.get(o) > 0
          : !0
      );
    b.useEffect(() => {
      let R = i.current;
      if (!(!R || t.disabled))
        return R.addEventListener(Xm, x), () => R.removeEventListener(Xm, x);
    }, [v, t.onSelect, t.disabled]);
    function x() {
      var R, F;
      S(), (F = (R = c.current).onSelect) == null || F.call(R, p.current);
    }
    function S() {
      m.setState("value", p.current, !0);
    }
    if (!v) return null;
    let {
      disabled: C,
      value: E,
      onSelect: N,
      forceMount: $,
      keywords: M,
      ...I
    } = t;
    return b.createElement(
      Ln.div,
      {
        ref: Ia([i, e]),
        ...I,
        id: o,
        "cmdk-item": "",
        role: "option",
        "aria-disabled": !!C,
        "aria-selected": !!y,
        "data-disabled": !!C,
        "data-selected": !!y,
        onPointerMove: C || u.disablePointerSelection ? void 0 : S,
        onClick: C ? void 0 : x,
      },
      t.children
    );
  }),
  _j = b.forwardRef((t, e) => {
    let { heading: n, children: r, forceMount: o, ...i } = t,
      l = b.useId(),
      u = b.useRef(null),
      c = b.useRef(null),
      f = b.useId(),
      p = Ka(),
      m = Hi((v) =>
        o || p.filter() === !1 ? !0 : v.search ? v.filtered.groups.has(l) : !0
      );
    Bi(() => p.group(l), []), PE(l, u, [t.value, t.heading, c]);
    let y = b.useMemo(() => ({ id: l, forceMount: o }), [o]);
    return b.createElement(
      Ln.div,
      {
        ref: Ia([u, e]),
        ...i,
        "cmdk-group": "",
        role: "presentation",
        hidden: m ? void 0 : !0,
      },
      n &&
        b.createElement(
          "div",
          { ref: c, "cmdk-group-heading": "", "aria-hidden": !0, id: f },
          n
        ),
      yf(t, (v) =>
        b.createElement(
          "div",
          {
            "cmdk-group-items": "",
            role: "group",
            "aria-labelledby": n ? f : void 0,
          },
          b.createElement(NE.Provider, { value: y }, v)
        )
      )
    );
  }),
  Fj = b.forwardRef((t, e) => {
    let { alwaysRender: n, ...r } = t,
      o = b.useRef(null),
      i = Hi((l) => !l.search);
    return !n && !i
      ? null
      : b.createElement(Ln.div, {
          ref: Ia([o, e]),
          ...r,
          "cmdk-separator": "",
          role: "separator",
        });
  }),
  zj = b.forwardRef((t, e) => {
    let { onValueChange: n, ...r } = t,
      o = t.value != null,
      i = Cy(),
      l = Hi((p) => p.search),
      u = Hi((p) => p.value),
      c = Ka(),
      f = b.useMemo(() => {
        var p;
        let m =
          (p = c.listInnerRef.current) == null
            ? void 0
            : p.querySelector(`${Sy}[${Ci}="${encodeURIComponent(u)}"]`);
        return m == null ? void 0 : m.getAttribute("id");
      }, []);
    return (
      b.useEffect(() => {
        t.value != null && i.setState("search", t.value);
      }, [t.value]),
      b.createElement(Ln.input, {
        ref: e,
        ...r,
        "cmdk-input": "",
        autoComplete: "off",
        autoCorrect: "off",
        spellCheck: !1,
        "aria-autocomplete": "list",
        role: "combobox",
        "aria-expanded": !0,
        "aria-controls": c.listId,
        "aria-labelledby": c.labelId,
        "aria-activedescendant": f,
        id: c.inputId,
        type: "text",
        value: o ? t.value : l,
        onChange: (p) => {
          o || i.setState("search", p.target.value),
            n == null || n(p.target.value);
        },
      })
    );
  }),
  jj = b.forwardRef((t, e) => {
    let { children: n, label: r = "Suggestions", ...o } = t,
      i = b.useRef(null),
      l = b.useRef(null),
      u = Ka();
    return (
      b.useEffect(() => {
        if (l.current && i.current) {
          let c = l.current,
            f = i.current,
            p,
            m = new ResizeObserver(() => {
              p = requestAnimationFrame(() => {
                let y = c.offsetHeight;
                f.style.setProperty("--cmdk-list-height", y.toFixed(1) + "px");
              });
            });
          return (
            m.observe(c),
            () => {
              cancelAnimationFrame(p), m.unobserve(c);
            }
          );
        }
      }, []),
      b.createElement(
        Ln.div,
        {
          ref: Ia([i, e]),
          ...o,
          "cmdk-list": "",
          role: "listbox",
          "aria-label": r,
          id: u.listId,
        },
        yf(t, (c) =>
          b.createElement(
            "div",
            { ref: Ia([l, u.listInnerRef]), "cmdk-list-sizer": "" },
            c
          )
        )
      )
    );
  }),
  Bj = b.forwardRef((t, e) => {
    let {
      open: n,
      onOpenChange: r,
      overlayClassName: o,
      contentClassName: i,
      container: l,
      ...u
    } = t;
    return b.createElement(
      Aj,
      { open: n, onOpenChange: r },
      b.createElement(
        Rj,
        { container: l },
        b.createElement(Pj, { "cmdk-overlay": "", className: o }),
        b.createElement(
          Dj,
          { "aria-label": t.label, "cmdk-dialog": "", className: i },
          b.createElement(AE, { ref: e, ...u })
        )
      )
    );
  }),
  Hj = b.forwardRef((t, e) =>
    Hi((n) => n.filtered.count === 0)
      ? b.createElement(Ln.div, {
          ref: e,
          ...t,
          "cmdk-empty": "",
          role: "presentation",
        })
      : null
  ),
  Vj = b.forwardRef((t, e) => {
    let { progress: n, children: r, label: o = "Loading...", ...i } = t;
    return b.createElement(
      Ln.div,
      {
        ref: e,
        ...i,
        "cmdk-loading": "",
        role: "progressbar",
        "aria-valuenow": n,
        "aria-valuemin": 0,
        "aria-valuemax": 100,
        "aria-label": o,
      },
      yf(t, (l) => b.createElement("div", { "aria-hidden": !0 }, l))
    );
  }),
  on = Object.assign(AE, {
    List: jj,
    Item: $j,
    Input: zj,
    Group: _j,
    Separator: Fj,
    Dialog: Bj,
    Empty: Hj,
    Loading: Vj,
  });
function Wj(t, e) {
  let n = t.nextElementSibling;
  for (; n; ) {
    if (n.matches(e)) return n;
    n = n.nextElementSibling;
  }
}
function Uj(t, e) {
  let n = t.previousElementSibling;
  for (; n; ) {
    if (n.matches(e)) return n;
    n = n.previousElementSibling;
  }
}
function RE(t) {
  let e = b.useRef(t);
  return (
    Bi(() => {
      e.current = t;
    }),
    e
  );
}
var Bi = typeof window > "u" ? b.useEffect : b.useLayoutEffect;
function Ps(t) {
  let e = b.useRef();
  return e.current === void 0 && (e.current = t()), e;
}
function Ia(t) {
  return (e) => {
    t.forEach((n) => {
      typeof n == "function" ? n(e) : n != null && (n.current = e);
    });
  };
}
function Hi(t) {
  let e = Cy(),
    n = () => t(e.snapshot());
  return b.useSyncExternalStore(e.subscribe, n, n);
}
function PE(t, e, n, r = []) {
  let o = b.useRef(),
    i = Ka();
  return (
    Bi(() => {
      var l;
      let u = (() => {
          var f;
          for (let p of n) {
            if (typeof p == "string") return p.trim();
            if (typeof p == "object" && "current" in p)
              return p.current
                ? (f = p.current.textContent) == null
                  ? void 0
                  : f.trim()
                : o.current;
          }
        })(),
        c = r.map((f) => f.trim());
      i.value(t, u, c),
        (l = e.current) == null || l.setAttribute(Ci, u),
        (o.current = u);
    }),
    o
  );
}
var Kj = () => {
  let [t, e] = b.useState(),
    n = Ps(() => new Map());
  return (
    Bi(() => {
      n.current.forEach((r) => r()), (n.current = new Map());
    }, [t]),
    (r, o) => {
      n.current.set(r, o), e({});
    }
  );
};
function qj(t) {
  let e = t.type;
  return typeof e == "function"
    ? e(t.props)
    : "render" in e
    ? e.render(t.props)
    : t;
}
function yf({ asChild: t, children: e }, n) {
  return t && b.isValidElement(e)
    ? b.cloneElement(qj(e), { ref: e.ref }, n(e.props.children))
    : n(e);
}
var Gj = {
    position: "absolute",
    width: "1px",
    height: "1px",
    padding: "0",
    margin: "-1px",
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    borderWidth: "0",
  },
  DE = "Dialog",
  [IE, NB] = Ui(DE),
  [AB, er] = IE(DE),
  LE = "DialogTrigger",
  Jj = b.forwardRef((t, e) => {
    const { __scopeDialog: n, ...r } = t,
      o = er(LE, n),
      i = ft(e, o.triggerRef);
    return O.jsx(nt.button, {
      type: "button",
      "aria-haspopup": "dialog",
      "aria-expanded": o.open,
      "aria-controls": o.contentId,
      "data-state": My(o.open),
      ...r,
      ref: i,
      onClick: Oe(t.onClick, o.onOpenToggle),
    });
  });
Jj.displayName = LE;
var ky = "DialogPortal",
  [Qj, $E] = IE(ky, { forceMount: void 0 }),
  _E = (t) => {
    const { __scopeDialog: e, forceMount: n, children: r, container: o } = t,
      i = er(ky, e);
    return O.jsx(Qj, {
      scope: e,
      forceMount: n,
      children: b.Children.map(r, (l) =>
        O.jsx(br, {
          present: n || i.open,
          children: O.jsx(af, { asChild: !0, container: o, children: l }),
        })
      ),
    });
  };
_E.displayName = ky;
var Ld = "DialogOverlay",
  FE = b.forwardRef((t, e) => {
    const n = $E(Ld, t.__scopeDialog),
      { forceMount: r = n.forceMount, ...o } = t,
      i = er(Ld, t.__scopeDialog);
    return i.modal
      ? O.jsx(br, {
          present: r || i.open,
          children: O.jsx(Yj, { ...o, ref: e }),
        })
      : null;
  });
FE.displayName = Ld;
var Yj = b.forwardRef((t, e) => {
    const { __scopeDialog: n, ...r } = t,
      o = er(Ld, n);
    return O.jsx(ff, {
      as: Ho,
      allowPinchZoom: !0,
      shards: [o.contentRef],
      children: O.jsx(nt.div, {
        "data-state": My(o.open),
        ...r,
        ref: e,
        style: { pointerEvents: "auto", ...r.style },
      }),
    });
  }),
  Vi = "DialogContent",
  zE = b.forwardRef((t, e) => {
    const n = $E(Vi, t.__scopeDialog),
      { forceMount: r = n.forceMount, ...o } = t,
      i = er(Vi, t.__scopeDialog);
    return O.jsx(br, {
      present: r || i.open,
      children: i.modal
        ? O.jsx(Xj, { ...o, ref: e })
        : O.jsx(Zj, { ...o, ref: e }),
    });
  });
zE.displayName = Vi;
var Xj = b.forwardRef((t, e) => {
    const n = er(Vi, t.__scopeDialog),
      r = b.useRef(null),
      o = ft(e, n.contentRef, r);
    return (
      b.useEffect(() => {
        const i = r.current;
        if (i) return cf(i);
      }, []),
      O.jsx(jE, {
        ...t,
        ref: o,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: Oe(t.onCloseAutoFocus, (i) => {
          var l;
          i.preventDefault(), (l = n.triggerRef.current) == null || l.focus();
        }),
        onPointerDownOutside: Oe(t.onPointerDownOutside, (i) => {
          const l = i.detail.originalEvent,
            u = l.button === 0 && l.ctrlKey === !0;
          (l.button === 2 || u) && i.preventDefault();
        }),
        onFocusOutside: Oe(t.onFocusOutside, (i) => i.preventDefault()),
      })
    );
  }),
  Zj = b.forwardRef((t, e) => {
    const n = er(Vi, t.__scopeDialog),
      r = b.useRef(!1),
      o = b.useRef(!1);
    return O.jsx(jE, {
      ...t,
      ref: e,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      onCloseAutoFocus: (i) => {
        var l, u;
        (l = t.onCloseAutoFocus) == null || l.call(t, i),
          i.defaultPrevented ||
            (r.current || (u = n.triggerRef.current) == null || u.focus(),
            i.preventDefault()),
          (r.current = !1),
          (o.current = !1);
      },
      onInteractOutside: (i) => {
        var c, f;
        (c = t.onInteractOutside) == null || c.call(t, i),
          i.defaultPrevented ||
            ((r.current = !0),
            i.detail.originalEvent.type === "pointerdown" && (o.current = !0));
        const l = i.target;
        ((f = n.triggerRef.current) == null ? void 0 : f.contains(l)) &&
          i.preventDefault(),
          i.detail.originalEvent.type === "focusin" &&
            o.current &&
            i.preventDefault();
      },
    });
  }),
  jE = b.forwardRef((t, e) => {
    const {
        __scopeDialog: n,
        trapFocus: r,
        onOpenAutoFocus: o,
        onCloseAutoFocus: i,
        ...l
      } = t,
      u = er(Vi, n),
      c = b.useRef(null),
      f = ft(e, c);
    return (
      Qg(),
      O.jsxs(O.Fragment, {
        children: [
          O.jsx(nf, {
            asChild: !0,
            loop: !0,
            trapped: r,
            onMountAutoFocus: o,
            onUnmountAutoFocus: i,
            children: O.jsx(tf, {
              role: "dialog",
              id: u.contentId,
              "aria-describedby": u.descriptionId,
              "aria-labelledby": u.titleId,
              "data-state": My(u.open),
              ...l,
              ref: f,
              onDismiss: () => u.onOpenChange(!1),
            }),
          }),
          O.jsxs(O.Fragment, {
            children: [
              O.jsx(e5, { titleId: u.titleId }),
              O.jsx(n5, { contentRef: c, descriptionId: u.descriptionId }),
            ],
          }),
        ],
      })
    );
  }),
  Ey = "DialogTitle",
  BE = b.forwardRef((t, e) => {
    const { __scopeDialog: n, ...r } = t,
      o = er(Ey, n);
    return O.jsx(nt.h2, { id: o.titleId, ...r, ref: e });
  });
BE.displayName = Ey;
var HE = "DialogDescription",
  VE = b.forwardRef((t, e) => {
    const { __scopeDialog: n, ...r } = t,
      o = er(HE, n);
    return O.jsx(nt.p, { id: o.descriptionId, ...r, ref: e });
  });
VE.displayName = HE;
var WE = "DialogClose",
  UE = b.forwardRef((t, e) => {
    const { __scopeDialog: n, ...r } = t,
      o = er(WE, n);
    return O.jsx(nt.button, {
      type: "button",
      ...r,
      ref: e,
      onClick: Oe(t.onClick, () => o.onOpenChange(!1)),
    });
  });
UE.displayName = WE;
function My(t) {
  return t ? "open" : "closed";
}
var KE = "DialogTitleWarning",
  [RB, qE] = C4(KE, { contentName: Vi, titleName: Ey, docsSlug: "dialog" }),
  e5 = ({ titleId: t }) => {
    const e = qE(KE),
      n = `\`${e.contentName}\` requires a \`${e.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${e.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${e.docsSlug}`;
    return (
      b.useEffect(() => {
        t && (document.getElementById(t) || console.error(n));
      }, [n, t]),
      null
    );
  },
  t5 = "DialogDescriptionWarning",
  n5 = ({ contentRef: t, descriptionId: e }) => {
    const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${
      qE(t5).contentName
    }}.`;
    return (
      b.useEffect(() => {
        var i;
        const o =
          (i = t.current) == null ? void 0 : i.getAttribute("aria-describedby");
        e && o && (document.getElementById(e) || console.warn(r));
      }, [r, t, e]),
      null
    );
  },
  r5 = _E,
  GE = FE,
  JE = zE,
  QE = BE,
  YE = VE,
  o5 = UE;
const i5 = r5,
  XE = b.forwardRef(({ className: t, ...e }, n) =>
    O.jsx(GE, {
      ref: n,
      className: Be(
        "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
        t
      ),
      ...e,
    })
  );
XE.displayName = GE.displayName;
const s5 = b.forwardRef(({ className: t, children: e, ...n }, r) =>
  O.jsxs(i5, {
    children: [
      O.jsx(XE, {}),
      O.jsxs(JE, {
        ref: r,
        className: Be(
          "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
          t
        ),
        ...n,
        children: [
          e,
          O.jsxs(o5, {
            className:
              "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground",
            children: [
              O.jsx(hz, { className: "h-4 w-4" }),
              O.jsx("span", { className: "sr-only", children: "Close" }),
            ],
          }),
        ],
      }),
    ],
  })
);
s5.displayName = JE.displayName;
const l5 = b.forwardRef(({ className: t, ...e }, n) =>
  O.jsx(QE, {
    ref: n,
    className: Be("text-lg font-semibold leading-none tracking-tight", t),
    ...e,
  })
);
l5.displayName = QE.displayName;
const a5 = b.forwardRef(({ className: t, ...e }, n) =>
  O.jsx(YE, { ref: n, className: Be("text-sm text-muted-foreground", t), ...e })
);
a5.displayName = YE.displayName;
const Oy = b.forwardRef(({ className: t, ...e }, n) =>
  O.jsx(on, {
    ref: n,
    className: Be(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      t
    ),
    ...e,
  })
);
Oy.displayName = on.displayName;
const Ty = b.forwardRef(({ className: t, ...e }, n) =>
  O.jsxs("div", {
    className: "flex items-center border-b px-3",
    "cmdk-input-wrapper": "",
    children: [
      O.jsx(fz, { className: "mr-2 h-4 w-4 shrink-0 opacity-50" }),
      O.jsx(on.Input, {
        ref: n,
        className: Be(
          "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
          t
        ),
        ...e,
      }),
    ],
  })
);
Ty.displayName = on.Input.displayName;
const Ny = b.forwardRef(({ className: t, ...e }, n) =>
  O.jsx(on.List, {
    ref: n,
    className: Be("max-h-[300px] overflow-y-auto overflow-x-hidden", t),
    ...e,
  })
);
Ny.displayName = on.List.displayName;
const Ay = b.forwardRef((t, e) =>
  O.jsx(on.Empty, { ref: e, className: "py-6 text-center text-sm", ...t })
);
Ay.displayName = on.Empty.displayName;
const $d = b.forwardRef(({ className: t, ...e }, n) =>
  O.jsx(on.Group, {
    ref: n,
    className: Be(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      t
    ),
    ...e,
  })
);
$d.displayName = on.Group.displayName;
const ZE = b.forwardRef(({ className: t, ...e }, n) =>
  O.jsx(on.Separator, {
    ref: n,
    className: Be("-mx-1 h-px bg-border", t),
    ...e,
  })
);
ZE.displayName = on.Separator.displayName;
const To = b.forwardRef(({ className: t, ...e }, n) =>
  O.jsx(on.Item, {
    ref: n,
    className: Be(
      "relative flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 cursor-pointer",
      t
    ),
    ...e,
  })
);
To.displayName = on.Item.displayName;
var Ry = "Popover",
  [eM, PB] = Ui(Ry, [lf]),
  qa = lf(),
  [u5, Yo] = eM(Ry),
  tM = (t) => {
    const {
        __scopePopover: e,
        children: n,
        open: r,
        defaultOpen: o,
        onOpenChange: i,
        modal: l = !1,
      } = t,
      u = qa(e),
      c = b.useRef(null),
      [f, p] = b.useState(!1),
      [m = !1, y] = Jg({ prop: r, defaultProp: o, onChange: i });
    return O.jsx(GC, {
      ...u,
      children: O.jsx(u5, {
        scope: e,
        contentId: Td(),
        triggerRef: c,
        open: m,
        onOpenChange: y,
        onOpenToggle: b.useCallback(() => y((v) => !v), [y]),
        hasCustomAnchor: f,
        onCustomAnchorAdd: b.useCallback(() => p(!0), []),
        onCustomAnchorRemove: b.useCallback(() => p(!1), []),
        modal: l,
        children: n,
      }),
    });
  };
tM.displayName = Ry;
var nM = "PopoverAnchor",
  c5 = b.forwardRef((t, e) => {
    const { __scopePopover: n, ...r } = t,
      o = Yo(nM, n),
      i = qa(n),
      { onCustomAnchorAdd: l, onCustomAnchorRemove: u } = o;
    return (
      b.useEffect(() => (l(), () => u()), [l, u]),
      O.jsx(sy, { ...i, ...r, ref: e })
    );
  });
c5.displayName = nM;
var rM = "PopoverTrigger",
  oM = b.forwardRef((t, e) => {
    const { __scopePopover: n, ...r } = t,
      o = Yo(rM, n),
      i = qa(n),
      l = ft(e, o.triggerRef),
      u = O.jsx(nt.button, {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": o.open,
        "aria-controls": o.contentId,
        "data-state": uM(o.open),
        ...r,
        ref: l,
        onClick: Oe(t.onClick, o.onOpenToggle),
      });
    return o.hasCustomAnchor
      ? u
      : O.jsx(sy, { asChild: !0, ...i, children: u });
  });
oM.displayName = rM;
var Py = "PopoverPortal",
  [d5, f5] = eM(Py, { forceMount: void 0 }),
  iM = (t) => {
    const { __scopePopover: e, forceMount: n, children: r, container: o } = t,
      i = Yo(Py, e);
    return O.jsx(d5, {
      scope: e,
      forceMount: n,
      children: O.jsx(br, {
        present: n || i.open,
        children: O.jsx(af, { asChild: !0, container: o, children: r }),
      }),
    });
  };
iM.displayName = Py;
var el = "PopoverContent",
  sM = b.forwardRef((t, e) => {
    const n = f5(el, t.__scopePopover),
      { forceMount: r = n.forceMount, ...o } = t,
      i = Yo(el, t.__scopePopover);
    return O.jsx(br, {
      present: r || i.open,
      children: i.modal
        ? O.jsx(p5, { ...o, ref: e })
        : O.jsx(h5, { ...o, ref: e }),
    });
  });
sM.displayName = el;
var p5 = b.forwardRef((t, e) => {
    const n = Yo(el, t.__scopePopover),
      r = b.useRef(null),
      o = ft(e, r),
      i = b.useRef(!1);
    return (
      b.useEffect(() => {
        const l = r.current;
        if (l) return cf(l);
      }, []),
      O.jsx(ff, {
        as: Ho,
        allowPinchZoom: !0,
        children: O.jsx(lM, {
          ...t,
          ref: o,
          trapFocus: n.open,
          disableOutsidePointerEvents: !0,
          onCloseAutoFocus: Oe(t.onCloseAutoFocus, (l) => {
            var u;
            l.preventDefault(),
              i.current || (u = n.triggerRef.current) == null || u.focus();
          }),
          onPointerDownOutside: Oe(
            t.onPointerDownOutside,
            (l) => {
              const u = l.detail.originalEvent,
                c = u.button === 0 && u.ctrlKey === !0,
                f = u.button === 2 || c;
              i.current = f;
            },
            { checkForDefaultPrevented: !1 }
          ),
          onFocusOutside: Oe(t.onFocusOutside, (l) => l.preventDefault(), {
            checkForDefaultPrevented: !1,
          }),
        }),
      })
    );
  }),
  h5 = b.forwardRef((t, e) => {
    const n = Yo(el, t.__scopePopover),
      r = b.useRef(!1),
      o = b.useRef(!1);
    return O.jsx(lM, {
      ...t,
      ref: e,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      onCloseAutoFocus: (i) => {
        var l, u;
        (l = t.onCloseAutoFocus) == null || l.call(t, i),
          i.defaultPrevented ||
            (r.current || (u = n.triggerRef.current) == null || u.focus(),
            i.preventDefault()),
          (r.current = !1),
          (o.current = !1);
      },
      onInteractOutside: (i) => {
        var c, f;
        (c = t.onInteractOutside) == null || c.call(t, i),
          i.defaultPrevented ||
            ((r.current = !0),
            i.detail.originalEvent.type === "pointerdown" && (o.current = !0));
        const l = i.target;
        ((f = n.triggerRef.current) == null ? void 0 : f.contains(l)) &&
          i.preventDefault(),
          i.detail.originalEvent.type === "focusin" &&
            o.current &&
            i.preventDefault();
      },
    });
  }),
  lM = b.forwardRef((t, e) => {
    const {
        __scopePopover: n,
        trapFocus: r,
        onOpenAutoFocus: o,
        onCloseAutoFocus: i,
        disableOutsidePointerEvents: l,
        onEscapeKeyDown: u,
        onPointerDownOutside: c,
        onFocusOutside: f,
        onInteractOutside: p,
        ...m
      } = t,
      y = Yo(el, n),
      v = qa(n);
    return (
      Qg(),
      O.jsx(nf, {
        asChild: !0,
        loop: !0,
        trapped: r,
        onMountAutoFocus: o,
        onUnmountAutoFocus: i,
        children: O.jsx(tf, {
          asChild: !0,
          disableOutsidePointerEvents: l,
          onInteractOutside: p,
          onEscapeKeyDown: u,
          onPointerDownOutside: c,
          onFocusOutside: f,
          onDismiss: () => y.onOpenChange(!1),
          children: O.jsx(JC, {
            "data-state": uM(y.open),
            role: "dialog",
            id: y.contentId,
            ...v,
            ...m,
            ref: e,
            style: {
              ...m.style,
              "--radix-popover-content-transform-origin":
                "var(--radix-popper-transform-origin)",
              "--radix-popover-content-available-width":
                "var(--radix-popper-available-width)",
              "--radix-popover-content-available-height":
                "var(--radix-popper-available-height)",
              "--radix-popover-trigger-width":
                "var(--radix-popper-anchor-width)",
              "--radix-popover-trigger-height":
                "var(--radix-popper-anchor-height)",
            },
          }),
        }),
      })
    );
  }),
  aM = "PopoverClose",
  m5 = b.forwardRef((t, e) => {
    const { __scopePopover: n, ...r } = t,
      o = Yo(aM, n);
    return O.jsx(nt.button, {
      type: "button",
      ...r,
      ref: e,
      onClick: Oe(t.onClick, () => o.onOpenChange(!1)),
    });
  });
m5.displayName = aM;
var g5 = "PopoverArrow",
  y5 = b.forwardRef((t, e) => {
    const { __scopePopover: n, ...r } = t,
      o = qa(n);
    return O.jsx(QC, { ...o, ...r, ref: e });
  });
y5.displayName = g5;
function uM(t) {
  return t ? "open" : "closed";
}
var v5 = tM,
  w5 = oM,
  x5 = iM,
  cM = sM;
const b5 = v5,
  S5 = w5,
  dM = b.forwardRef(
    ({ className: t, align: e = "center", sideOffset: n = 4, ...r }, o) =>
      O.jsx(x5, {
        children: O.jsx(cM, {
          ref: o,
          align: e,
          sideOffset: n,
          className: Be(
            "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-popover-content-transform-origin]",
            t
          ),
          ...r,
        }),
      })
  );
dM.displayName = cM.displayName;
function C5() {
  const t = ["Arial", "Inter", "Monospace", "Cursive", "serif"],
    [e, n] = b.useState(!1),
    [r, o] = b.useState(""),
    { editor: i } = Qo();
  if (!i) return;
  const l = i.getAttributes("textStyle");
  return (
    b.useEffect(() => {
      o(l.fontFamily ?? "Arial");
    }, [i, l]),
    O.jsxs(b5, {
      open: e,
      onOpenChange: n,
      children: [
        O.jsx(S5, {
          asChild: !0,
          children: O.jsxs(ef, {
            variant: "outline",
            role: "combobox",
            "aria-expanded": e,
            className:
              "w-[130px] justify-between border-none hover:bg-gray-300",
            children: [
              r ? t.find((u) => u === r) : "Fontes",
              O.jsx(az, { className: "ml-2 h-4 w-4 shrink-0 opacity-50" }),
            ],
          }),
        }),
        O.jsx(dM, {
          className: "w-[200px] p-0",
          children: O.jsxs(Oy, {
            children: [
              O.jsx(Ty, { placeholder: "Busque uma fonte..." }),
              O.jsxs(Ny, {
                children: [
                  O.jsx(Ay, { children: "Nenhuma fonte encontrada" }),
                  O.jsx($d, {
                    children: t.map((u) =>
                      O.jsxs(
                        To,
                        {
                          className: "cursor-pointer",
                          value: u,
                          onSelect: (c) => {
                            pn(i, "setFontFamily", u)(),
                              o(c === r ? "" : c),
                              n(!1);
                          },
                          children: [
                            O.jsx(aE, {
                              className: Be(
                                "mr-2 h-4 w-4",
                                r === u ? "opacity-100" : "opacity-0"
                              ),
                            }),
                            u,
                          ],
                        },
                        u
                      )
                    ),
                  }),
                ],
              }),
            ],
          }),
        }),
      ],
    })
  );
}
function k5() {
  const { editor: t } = Qo();
  if (!t) return;
  const e = pn(t, "toggleBold"),
    n = pn(t, "toggleItalic"),
    r = pn(t, "toggleUnderline"),
    o = pn(t, "toggleStrike"),
    i = () => t.chain().focus().toggleBulletList().run(),
    l = pn(t, "toggleOrderedList"),
    u = pn(t, "setHorizontalRule"),
    c = pn(t, "setColor", "#958DF1"),
    f = pn(t, "unsetColor");
  return O.jsxs("div", {
    style: {
      marginBottom: "2rem",
      backgroundColor: "white",
      borderRadius: "6px",
      border: "1px solid #cfcaca",
      height: "3rem",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      gap: "4px",
    },
    children: [
      O.jsx(fn, {
        className: Ss(t, "bold"),
        onClick: e,
        children: O.jsx(DL, {}),
      }),
      O.jsx(fn, {
        className: Ss(t, "italic"),
        onClick: n,
        children: O.jsx(IL, {}),
      }),
      O.jsx(fn, {
        className: Ss(t, "underline"),
        onClick: r,
        children: O.jsx(FL, {}),
      }),
      O.jsx(fn, {
        className: Ss(t, "strike"),
        onClick: o,
        children: O.jsx(_L, {}),
      }),
      O.jsx(Oc, {}),
      O.jsx(fn, {
        className: Ss(t, "orderedList"),
        onClick: l,
        children: O.jsx(LL, {}),
      }),
      O.jsx(fn, {
        className: Ss(t, "bulletList"),
        onClick: i,
        children: O.jsx($L, {}),
      }),
      O.jsx(Oc, {}),
      O.jsx(wz, {}),
      O.jsx(xz, {}),
      O.jsx(C5, {}),
      O.jsx(Oc, {}),
      O.jsx(fn, { onClick: u, children: O.jsx(bz, {}) }),
      O.jsx(fn, { onClick: c, children: "Adicionar cor" }),
      O.jsx(fn, { onClick: f, children: "Remover qualquer cor" }),
      O.jsx(Oc, {}),
      O.jsx(Sz, {}),
    ],
  });
}
function Oc() {
  return O.jsx("span", {
    style: {
      width: "2px",
      height: "70%",
      backgroundColor: "rgb(230, 224, 224)",
    },
  });
}
const E5 = et.create({
    name: "fontFamily",
    addOptions() {
      return { types: ["textStyle"] };
    },
    addGlobalAttributes() {
      return [
        {
          types: this.options.types,
          attributes: {
            fontFamily: {
              default: null,
              parseHTML: (t) => t.style.fontFamily,
              renderHTML: (t) =>
                t.fontFamily ? { style: `font-family: ${t.fontFamily}` } : {},
            },
          },
        },
      ];
    },
    addCommands() {
      return {
        setFontFamily:
          (t) =>
          ({ chain: e }) =>
            e().setMark("textStyle", { fontFamily: t }).run(),
        unsetFontFamily:
          () =>
          ({ chain: t }) =>
            t()
              .setMark("textStyle", { fontFamily: null })
              .removeEmptyTextStyle()
              .run(),
      };
    },
  }),
  fM = b.forwardRef(({ className: t, ...e }, n) =>
    O.jsx("div", {
      ref: n,
      className: Be(
        "rounded-lg border bg-card text-card-foreground shadow-sm",
        t
      ),
      ...e,
    })
  );
fM.displayName = "Card";
const M5 = b.forwardRef(({ className: t, ...e }, n) =>
  O.jsx("div", {
    ref: n,
    className: Be("flex flex-col space-y-1.5 p-6", t),
    ...e,
  })
);
M5.displayName = "CardHeader";
const O5 = b.forwardRef(({ className: t, ...e }, n) =>
  O.jsx("div", {
    ref: n,
    className: Be("text-2xl font-semibold leading-none tracking-tight", t),
    ...e,
  })
);
O5.displayName = "CardTitle";
const T5 = b.forwardRef(({ className: t, ...e }, n) =>
  O.jsx("div", {
    ref: n,
    className: Be("text-sm text-muted-foreground", t),
    ...e,
  })
);
T5.displayName = "CardDescription";
const pM = b.forwardRef(({ className: t, ...e }, n) =>
  O.jsx("div", { ref: n, className: Be("p-6 pt-0", t), ...e })
);
pM.displayName = "CardContent";
const N5 = b.forwardRef(({ className: t, ...e }, n) =>
  O.jsx("div", { ref: n, className: Be("flex items-center p-6 pt-0", t), ...e })
);
N5.displayName = "CardFooter";
const hM = b.forwardRef(({ className: t, type: e, ...n }, r) =>
  O.jsx("input", {
    type: e,
    className: Be(
      "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
      t
    ),
    ref: r,
    ...n,
  })
);
hM.displayName = "Input";
function A5() {
  const { editor: t } = Qo();
  if (t)
    return O.jsxs(xD, {
      editor: null,
      tippyOptions: { placement: "right" },
      children: [
        O.jsx(hM, {
          placeholder: "Pea para a IA fazer algo...",
          className: "mb-5",
        }),
        O.jsx(fM, {
          children: O.jsx(pM, {
            className: "my-8 flex flex-col",
            children: O.jsxs(Oy, {
              children: [
                O.jsx(Ty, { placeholder: "Ache o que procura" }),
                O.jsxs(Ny, {
                  children: [
                    O.jsx(Ay, { children: "Nenhum resultado encontrado" }),
                    O.jsxs($d, {
                      heading: "Escrita",
                      children: [
                        O.jsx(To, {
                          children: "Melhorar escrita do texto selecionado",
                        }),
                        O.jsx(To, {
                          children: "Tornar o texto selecionado mais sucinto",
                        }),
                        O.jsx(To, {
                          children: "Tornar o texto selecionado mais formal",
                        }),
                      ],
                    }),
                    O.jsx(ZE, {}),
                    O.jsxs($d, {
                      heading: "Settings",
                      children: [
                        O.jsx(To, { children: "Profile" }),
                        O.jsx(To, { children: "Billing" }),
                        O.jsx(To, { children: "Settings" }),
                      ],
                    }),
                  ],
                }),
              ],
            }),
          }),
        }),
      ],
    });
}
const R5 = [
    CI.configure({ heading: { levels: [1, 2, 3] } }),
    kI,
    qI,
    JI,
    QI,
    wL,
    bL,
    E5,
    xL.configure({ types: ["heading", "paragraph"], defaultAlignment: "left" }),
  ],
  P5 = "<h2>Ol!!</h2><br><p>Texto qualquer</p>",
  D5 = () =>
    O.jsxs(wD, {
      extensions: R5,
      content: P5,
      slotBefore: O.jsx(k5, {}),
      autofocus: !1,
      editorProps: { attributes: { style: "font-family: Arial, sans-serif;" } },
      children: [
        O.jsx(bD, { editor: null, children: "This is the floating menu" }),
        O.jsx(A5, {}),
      ],
    });
function I5(t) {
  console.log("Valor de properties:", properties),
    alert("VALOR DO PARAMETRO: " + t + " Valor parmetro organizado: " + t);
}
window.testeBubbleForaDoApp = I5;
function L5() {
  return O.jsxs(O.Fragment, {
    children: [
      O.jsx("button", {
        onClick: () => {
          bubble_fn_melhorar_escrita({ output1: "apple", output2: 69 });
        },
        children: "BOTO FEIO DE TESTE",
      }),
      O.jsx(D5, {}),
    ],
  });
}
let $5 = { data: "" },
  _5 = (t) =>
    typeof window == "object"
      ? (
          (t ? t.querySelector("#_goober") : window._goober) ||
          Object.assign(
            (t || document.head).appendChild(document.createElement("style")),
            { innerHTML: " ", id: "_goober" }
          )
        ).firstChild
      : t || $5,
  F5 = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g,
  z5 = /\/\*[^]*?\*\/|  +/g,
  Gx = /\n+/g,
  Ro = (t, e) => {
    let n = "",
      r = "",
      o = "";
    for (let i in t) {
      let l = t[i];
      i[0] == "@"
        ? i[1] == "i"
          ? (n = i + " " + l + ";")
          : (r +=
              i[1] == "f"
                ? Ro(l, i)
                : i + "{" + Ro(l, i[1] == "k" ? "" : e) + "}")
        : typeof l == "object"
        ? (r += Ro(
            l,
            e
              ? e.replace(/([^,])+/g, (u) =>
                  i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (c) =>
                    /&/.test(c) ? c.replace(/&/g, u) : u ? u + " " + c : c
                  )
                )
              : i
          ))
        : l != null &&
          ((i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase()),
          (o += Ro.p ? Ro.p(i, l) : i + ":" + l + ";"));
    }
    return n + (e && o ? e + "{" + o + "}" : o) + r;
  },
  jr = {},
  mM = (t) => {
    if (typeof t == "object") {
      let e = "";
      for (let n in t) e += n + mM(t[n]);
      return e;
    }
    return t;
  },
  j5 = (t, e, n, r, o) => {
    let i = mM(t),
      l =
        jr[i] ||
        (jr[i] = ((c) => {
          let f = 0,
            p = 11;
          for (; f < c.length; ) p = (101 * p + c.charCodeAt(f++)) >>> 0;
          return "go" + p;
        })(i));
    if (!jr[l]) {
      let c =
        i !== t
          ? t
          : ((f) => {
              let p,
                m,
                y = [{}];
              for (; (p = F5.exec(f.replace(z5, ""))); )
                p[4]
                  ? y.shift()
                  : p[3]
                  ? ((m = p[3].replace(Gx, " ").trim()),
                    y.unshift((y[0][m] = y[0][m] || {})))
                  : (y[0][p[1]] = p[2].replace(Gx, " ").trim());
              return y[0];
            })(t);
      jr[l] = Ro(o ? { ["@keyframes " + l]: c } : c, n ? "" : "." + l);
    }
    let u = n && jr.g ? jr.g : null;
    return (
      n && (jr.g = jr[l]),
      ((c, f, p, m) => {
        m
          ? (f.data = f.data.replace(m, c))
          : f.data.indexOf(c) === -1 && (f.data = p ? c + f.data : f.data + c);
      })(jr[l], e, r, u),
      l
    );
  },
  B5 = (t, e, n) =>
    t.reduce((r, o, i) => {
      let l = e[i];
      if (l && l.call) {
        let u = l(n),
          c = (u && u.props && u.props.className) || (/^go/.test(u) && u);
        l = c
          ? "." + c
          : u && typeof u == "object"
          ? u.props
            ? ""
            : Ro(u, "")
          : u === !1
          ? ""
          : u;
      }
      return r + o + (l ?? "");
    }, "");
function vf(t) {
  let e = this || {},
    n = t.call ? t(e.p) : t;
  return j5(
    n.unshift
      ? n.raw
        ? B5(n, [].slice.call(arguments, 1), e.p)
        : n.reduce((r, o) => Object.assign(r, o && o.call ? o(e.p) : o), {})
      : n,
    _5(e.target),
    e.g,
    e.o,
    e.k
  );
}
let gM, Zm, eg;
vf.bind({ g: 1 });
let Jr = vf.bind({ k: 1 });
function H5(t, e, n, r) {
  (Ro.p = e), (gM = t), (Zm = n), (eg = r);
}
function Xo(t, e) {
  let n = this || {};
  return function () {
    let r = arguments;
    function o(i, l) {
      let u = Object.assign({}, i),
        c = u.className || o.className;
      (n.p = Object.assign({ theme: Zm && Zm() }, u)),
        (n.o = / *go\d+/.test(c)),
        (u.className = vf.apply(n, r) + (c ? " " + c : ""));
      let f = t;
      return (
        t[0] && ((f = u.as || t), delete u.as), eg && f[0] && eg(u), gM(f, u)
      );
    }
    return o;
  };
}
var V5 = (t) => typeof t == "function",
  _d = (t, e) => (V5(t) ? t(e) : t),
  W5 = (() => {
    let t = 0;
    return () => (++t).toString();
  })(),
  yM = (() => {
    let t;
    return () => {
      if (t === void 0 && typeof window < "u") {
        let e = matchMedia("(prefers-reduced-motion: reduce)");
        t = !e || e.matches;
      }
      return t;
    };
  })(),
  U5 = 20,
  vM = (t, e) => {
    switch (e.type) {
      case 0:
        return { ...t, toasts: [e.toast, ...t.toasts].slice(0, U5) };
      case 1:
        return {
          ...t,
          toasts: t.toasts.map((i) =>
            i.id === e.toast.id ? { ...i, ...e.toast } : i
          ),
        };
      case 2:
        let { toast: n } = e;
        return vM(t, {
          type: t.toasts.find((i) => i.id === n.id) ? 1 : 0,
          toast: n,
        });
      case 3:
        let { toastId: r } = e;
        return {
          ...t,
          toasts: t.toasts.map((i) =>
            i.id === r || r === void 0
              ? { ...i, dismissed: !0, visible: !1 }
              : i
          ),
        };
      case 4:
        return e.toastId === void 0
          ? { ...t, toasts: [] }
          : { ...t, toasts: t.toasts.filter((i) => i.id !== e.toastId) };
      case 5:
        return { ...t, pausedAt: e.time };
      case 6:
        let o = e.time - (t.pausedAt || 0);
        return {
          ...t,
          pausedAt: void 0,
          toasts: t.toasts.map((i) => ({
            ...i,
            pauseDuration: i.pauseDuration + o,
          })),
        };
    }
  },
  _c = [],
  Oi = { toasts: [], pausedAt: void 0 },
  Ji = (t) => {
    (Oi = vM(Oi, t)),
      _c.forEach((e) => {
        e(Oi);
      });
  },
  K5 = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 },
  q5 = (t = {}) => {
    let [e, n] = b.useState(Oi),
      r = b.useRef(Oi);
    b.useEffect(
      () => (
        r.current !== Oi && n(Oi),
        _c.push(n),
        () => {
          let i = _c.indexOf(n);
          i > -1 && _c.splice(i, 1);
        }
      ),
      []
    );
    let o = e.toasts.map((i) => {
      var l, u, c;
      return {
        ...t,
        ...t[i.type],
        ...i,
        removeDelay:
          i.removeDelay ||
          ((l = t[i.type]) == null ? void 0 : l.removeDelay) ||
          (t == null ? void 0 : t.removeDelay),
        duration:
          i.duration ||
          ((u = t[i.type]) == null ? void 0 : u.duration) ||
          (t == null ? void 0 : t.duration) ||
          K5[i.type],
        style: {
          ...t.style,
          ...((c = t[i.type]) == null ? void 0 : c.style),
          ...i.style,
        },
      };
    });
    return { ...e, toasts: o };
  },
  G5 = (t, e = "blank", n) => ({
    createdAt: Date.now(),
    visible: !0,
    dismissed: !1,
    type: e,
    ariaProps: { role: "status", "aria-live": "polite" },
    message: t,
    pauseDuration: 0,
    ...n,
    id: (n == null ? void 0 : n.id) || W5(),
  }),
  Ga = (t) => (e, n) => {
    let r = G5(e, t, n);
    return Ji({ type: 2, toast: r }), r.id;
  },
  en = (t, e) => Ga("blank")(t, e);
en.error = Ga("error");
en.success = Ga("success");
en.loading = Ga("loading");
en.custom = Ga("custom");
en.dismiss = (t) => {
  Ji({ type: 3, toastId: t });
};
en.remove = (t) => Ji({ type: 4, toastId: t });
en.promise = (t, e, n) => {
  let r = en.loading(e.loading, { ...n, ...(n == null ? void 0 : n.loading) });
  return (
    typeof t == "function" && (t = t()),
    t
      .then((o) => {
        let i = e.success ? _d(e.success, o) : void 0;
        return (
          i
            ? en.success(i, {
                id: r,
                ...n,
                ...(n == null ? void 0 : n.success),
              })
            : en.dismiss(r),
          o
        );
      })
      .catch((o) => {
        let i = e.error ? _d(e.error, o) : void 0;
        i
          ? en.error(i, { id: r, ...n, ...(n == null ? void 0 : n.error) })
          : en.dismiss(r);
      }),
    t
  );
};
var J5 = (t, e) => {
    Ji({ type: 1, toast: { id: t, height: e } });
  },
  Q5 = () => {
    Ji({ type: 5, time: Date.now() });
  },
  ma = new Map(),
  Y5 = 1e3,
  X5 = (t, e = Y5) => {
    if (ma.has(t)) return;
    let n = setTimeout(() => {
      ma.delete(t), Ji({ type: 4, toastId: t });
    }, e);
    ma.set(t, n);
  },
  Z5 = (t) => {
    let { toasts: e, pausedAt: n } = q5(t);
    b.useEffect(() => {
      if (n) return;
      let i = Date.now(),
        l = e.map((u) => {
          if (u.duration === 1 / 0) return;
          let c = (u.duration || 0) + u.pauseDuration - (i - u.createdAt);
          if (c < 0) {
            u.visible && en.dismiss(u.id);
            return;
          }
          return setTimeout(() => en.dismiss(u.id), c);
        });
      return () => {
        l.forEach((u) => u && clearTimeout(u));
      };
    }, [e, n]);
    let r = b.useCallback(() => {
        n && Ji({ type: 6, time: Date.now() });
      }, [n]),
      o = b.useCallback(
        (i, l) => {
          let {
              reverseOrder: u = !1,
              gutter: c = 8,
              defaultPosition: f,
            } = l || {},
            p = e.filter(
              (v) => (v.position || f) === (i.position || f) && v.height
            ),
            m = p.findIndex((v) => v.id === i.id),
            y = p.filter((v, x) => x < m && v.visible).length;
          return p
            .filter((v) => v.visible)
            .slice(...(u ? [y + 1] : [0, y]))
            .reduce((v, x) => v + (x.height || 0) + c, 0);
        },
        [e]
      );
    return (
      b.useEffect(() => {
        e.forEach((i) => {
          if (i.dismissed) X5(i.id, i.removeDelay);
          else {
            let l = ma.get(i.id);
            l && (clearTimeout(l), ma.delete(i.id));
          }
        });
      }, [e]),
      {
        toasts: e,
        handlers: {
          updateHeight: J5,
          startPause: Q5,
          endPause: r,
          calculateOffset: o,
        },
      }
    );
  },
  eB = Jr`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`,
  tB = Jr`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`,
  nB = Jr`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`,
  rB = Xo("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(t) => t.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${eB} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${tB} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(t) => t.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${nB} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`,
  oB = Jr`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`,
  iB = Xo("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(t) => t.secondary || "#e0e0e0"};
  border-right-color: ${(t) => t.primary || "#616161"};
  animation: ${oB} 1s linear infinite;
`,
  sB = Jr`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`,
  lB = Jr`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`,
  aB = Xo("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(t) => t.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${sB} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${lB} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(t) => t.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`,
  uB = Xo("div")`
  position: absolute;
`,
  cB = Xo("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`,
  dB = Jr`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`,
  fB = Xo("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${dB} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`,
  pB = ({ toast: t }) => {
    let { icon: e, type: n, iconTheme: r } = t;
    return e !== void 0
      ? typeof e == "string"
        ? b.createElement(fB, null, e)
        : e
      : n === "blank"
      ? null
      : b.createElement(
          cB,
          null,
          b.createElement(iB, { ...r }),
          n !== "loading" &&
            b.createElement(
              uB,
              null,
              n === "error"
                ? b.createElement(rB, { ...r })
                : b.createElement(aB, { ...r })
            )
        );
  },
  hB = (t) => `
0% {transform: translate3d(0,${t * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`,
  mB = (t) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${t * -150}%,-1px) scale(.6); opacity:0;}
`,
  gB = "0%{opacity:0;} 100%{opacity:1;}",
  yB = "0%{opacity:1;} 100%{opacity:0;}",
  vB = Xo("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`,
  wB = Xo("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`,
  xB = (t, e) => {
    let n = t.includes("top") ? 1 : -1,
      [r, o] = yM() ? [gB, yB] : [hB(n), mB(n)];
    return {
      animation: e
        ? `${Jr(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards`
        : `${Jr(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)`,
    };
  },
  bB = b.memo(({ toast: t, position: e, style: n, children: r }) => {
    let o = t.height
        ? xB(t.position || e || "top-center", t.visible)
        : { opacity: 0 },
      i = b.createElement(pB, { toast: t }),
      l = b.createElement(wB, { ...t.ariaProps }, _d(t.message, t));
    return b.createElement(
      vB,
      { className: t.className, style: { ...o, ...n, ...t.style } },
      typeof r == "function"
        ? r({ icon: i, message: l })
        : b.createElement(b.Fragment, null, i, l)
    );
  });
H5(b.createElement);
var SB = ({
    id: t,
    className: e,
    style: n,
    onHeightUpdate: r,
    children: o,
  }) => {
    let i = b.useCallback(
      (l) => {
        if (l) {
          let u = () => {
            let c = l.getBoundingClientRect().height;
            r(t, c);
          };
          u(),
            new MutationObserver(u).observe(l, {
              subtree: !0,
              childList: !0,
              characterData: !0,
            });
        }
      },
      [t, r]
    );
    return b.createElement("div", { ref: i, className: e, style: n }, o);
  },
  CB = (t, e) => {
    let n = t.includes("top"),
      r = n ? { top: 0 } : { bottom: 0 },
      o = t.includes("center")
        ? { justifyContent: "center" }
        : t.includes("right")
        ? { justifyContent: "flex-end" }
        : {};
    return {
      left: 0,
      right: 0,
      display: "flex",
      position: "absolute",
      transition: yM() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)",
      transform: `translateY(${e * (n ? 1 : -1)}px)`,
      ...r,
      ...o,
    };
  },
  kB = vf`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`,
  Tc = 16,
  EB = ({
    reverseOrder: t,
    position: e = "top-center",
    toastOptions: n,
    gutter: r,
    children: o,
    containerStyle: i,
    containerClassName: l,
  }) => {
    let { toasts: u, handlers: c } = Z5(n);
    return b.createElement(
      "div",
      {
        id: "_rht_toaster",
        style: {
          position: "fixed",
          zIndex: 9999,
          top: Tc,
          left: Tc,
          right: Tc,
          bottom: Tc,
          pointerEvents: "none",
          ...i,
        },
        className: l,
        onMouseEnter: c.startPause,
        onMouseLeave: c.endPause,
      },
      u.map((f) => {
        let p = f.position || e,
          m = c.calculateOffset(f, {
            reverseOrder: t,
            gutter: r,
            defaultPosition: e,
          }),
          y = CB(p, m);
        return b.createElement(
          SB,
          {
            id: f.id,
            key: f.id,
            onHeightUpdate: c.updateHeight,
            className: f.visible ? kB : "",
            style: y,
          },
          f.type === "custom"
            ? _d(f.message, f)
            : o
            ? o(f)
            : b.createElement(bB, { toast: f, position: p })
        );
      })
    );
  };
xO.createRoot(document.getElementById("root")).render(
  O.jsxs(SO, { children: [O.jsx(EB, {}), O.jsx(L5, {})] })
);
